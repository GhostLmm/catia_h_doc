<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisualizationBase/PublicInterfaces/CAT3DViewport.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>VisualizationBase/PublicInterfaces/CAT3DViewport.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CAT3DViewpoint.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DViewpoint.h</a></div>
        <div><a href="CAT3x3Matrix.html">‰∏ã‰∏ÄÈ°µ: CAT3x3Matrix.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CAT3DViewport_H
#define CAT3DViewport_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */


//
// CATIA Version 5 Release 1 Framework Visualization
// Copyright Dassault Systemes 1996
//------------------------------------------------------------------------------
// Abstract :   defines a 3D bounding object (n planes)
// ----------
//
//------------------------------------------------------------------------------
// Usage :      is used by viewer at draw time to define a box where
// ------       representations are supposed to be seen. 
//              (this is used at culling time to avoid to draw representations
//               which bounding sphere is outside of this box)
//
//------------------------------------------------------------------------------
// Class :      CAT3DViewport
// -------        CATViewport
//                  
//------------------------------------------------------------------------------
#include &quot;CATViz.h&quot;
#include &quot;CATViewport.h&quot;

#include &quot;CAT3DBoundingSphere.h&quot;

#include &quot;CATMathPointf.h&quot;
#include &quot;CATMathVectorf.h&quot;
#include &quot;CATMathDirectionf.h&quot;
#include &quot;CAT4x4Matrix.h&quot;

#ifdef _IRIX_SOURCE
 //Ia64+
#include &quot;CATDataType.h&quot;
//Ia64-
/** @nodoc */
extern CATINTPTR DrawMenb (int);
#endif

/**
 *
 * Class that defines a 2D clipping area.
 *
 */
class ExportedByCATViz CAT3DViewport : public CATViewport
{
 CATDeclareClass;

 public :

 /** @nodoc */
  CAT3DViewport ();
 /** @nodoc */
  CAT3DViewport(const CAT3DViewport &amp;viewport);
 /** @nodoc */
  CAT3DViewport (const int, const float [], const float [], const float [], const float []);
 /** @nodoc */
  CAT3DViewport (const int, const CATMathPointf [], const CATMathDirectionf []);

   /**
    *  Affectation operator.
    *  @param viewport  A reference to3D the CAT3DViewport we want to copy  into this one.
    *  @return A reference to this CATViewport
    */
  CAT3DViewport &amp; operator = (const CAT3DViewport &amp;viewport);

  virtual ~CAT3DViewport ();

  /**
   *  Duplicates the Viewport.
   *  @return the copy of this CATViewport
   */
  virtual CATViewport *Clone() const;
  /**
   * Duplicate a Viewport.
   * @param iViewport A pointer to the pointer on the CATViewport into wich we want to duplicate this CATViewport.
   * @return A pointer to the Duplicated CATviewport
   */
  virtual CATViewport *Clone(CATViewport **) const;

  /** 
   * Add the clipping planes of one CAT3DViewport to this one.
   * @param iFrom the CAT3DViewport of which we add the clipping planes
   */
  CAT3DViewport &amp; operator += (const CAT3DViewport &amp;iFrom);
  /** 
   * Remove the clipping planes of one CAT3DViewport to this one.
   * @param iFrom the CAT3DViewport of which we add the clipping planes
   * Use only if you added that CAT3DViewport clipping planes to this CAT3DViewport, and
   * did not add any other in the meantime.
   */
  CAT3DViewport &amp; operator -= (const CAT3DViewport &amp;iFrom);\
  /**
  * Apply the geometric transformatin defined by the CAT4x4Matrix to the clipping planes.
  *  @param iMatrix the transformation to apply.
  */
  CAT3DViewport &amp; operator *= (const CAT4x4Matrix &amp;iMatrix);
  
  /**
   * Determine wether or not a given CAT3DBoundingSphere lies outside the CAT3DViewport.
   * @param iBox  The CAT3DBoundingSphere we want to test
   * @param iratio
   * @return the result of the test
   */
  inline int IsOutside (const CAT3DBoundingSphere &amp;, const float iratio= 1.f) const;
  /**
   * Determine wether or not a given sphere lies outside the CAT2DViewport.
   * @param iCenter  a pointer to an array of coorinates for the center of the sphere
   * @param iRadius  the radius of the spheres
   * @return the result of the test
   */
  inline int IsOutside (const float * iCenter,const float iRadius) const;
  /**
   * Determine wether or not a given sphere lies inside the CAT2DViewport.
   * @param icenter  a pointer to an array of coorinates for the center of the sphere
   * @param iradius  the radius of the spheres
   * @return the result of the test
   */
  int IsInside  (const float *icenter,const float iradius) const;
  /**
   * Determine wether or not a given CAT3DBoundingSphere lies inside the CAT3DViewport.
   * @param iBox  The CAT3DBoundingSphere we want to test
   * @param iratio
   * @return the result of the test
   */
  int IsInside  (const CAT3DBoundingSphere &amp;, const float iratio= 1.f) const;
  /**
   * Determine wether or not a given point lies inside the CAT2DViewport.
   * @param point  a pointer to an array of coordinates for the point
   * @return the result of the test
   */
  int IsInside  (const float point[3]) const;

  /**
   * Get the number of planes.
   * @return the number of planes
   */
  inline int GetNbPlanes() const;
  /**
   * Get the clipping planes equations.
   * @param oa an array of float representing the a param in the plane equation
   * @param ob an array of float representing the b param in the plane equation
   * @param oc an array of float representing the c param in the plane equation
   * @param od an array of float representing the d param in the plane equation
   *  The planes equations are of the form a.x+b.y+c.z+d = 0
   */
  inline void GetPlanes (float **oa, float **ob, float **oc, float **od);

 /** @nodoc */
  virtual int SizeOf();

#ifdef _IRIX_SOURCE
 /** @nodoc */
inline  int IsOutside (const float *box_center, const float *box_dim ) const;
 /** @nodoc */
inline  int IsOutside (const CATMathPointf &amp;min_point, const CATMathPointf &amp;max_point ) const;
 /** @nodoc */
inline int IsOutside (const float x, const float y, const float z ) const;
#endif

 private :

 /** @nodoc */
   int _nbPlanes;
 /** @nodoc */
   float a[12],b[12],c[12],d[12];

 /** @nodoc */
   CATMathVectorf    _working_vector;
 /** @nodoc */
   CATMathDirectionf _working_direction;

};

inline int CAT3DViewport::GetNbPlanes() const
{
 return ( _nbPlanes);
}
struct CATMyBox
{
 CATMathPointf minPoint, maxPoint;
};

inline void CAT3DViewport::GetPlanes(float **oa, float **ob, float **oc, float **od)
{
 *oa = &amp;a[0];
 *ob = &amp;b[0];
 *oc = &amp;c[0];
 *od = &amp;d[0];
}

inline int CAT3DViewport::IsOutside ( const CAT3DBoundingSphere &amp;bs3D,
                                      const float ratio ) const
{
      if ( bs3D._state == EMPTY ) return (1);
 else if ( bs3D._state == INFINIT || bs3D._state == CONTAIN ) return (0);
 else
 {
#ifdef _IRIX_SOURCE
static CATINTPTR d101 = -1;
  if ((d101 &lt; 0) &amp;&amp; (DrawMenb(0) == 1))
   d101=DrawMenb(101);

  if (d101&lt;=0)
  {
   float x = bs3D._center.x;
   float y = bs3D._center.y;
   float z = bs3D._center.z;
   float rayon;
  
   if(bs3D._radius_mm&gt;(1e-6))
    rayon=bs3D._radius+bs3D._radius_mm*ratio;
   else
    rayon=bs3D._radius; 
 
   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   for ( int i = 5; i &gt;= 0 ; i-- )
   { 
    if ( a[i]*x + b[i]*y + c[i]*z + d[i] - rayon &gt; 0 )
    {
      return(1);
    }
   }
  }
  else if (d101 &amp;&amp; bs3D.GetBox())
  {
   CATMyBox *bbox = (CATMyBox*)bs3D.GetBox();
  
   int   i, isect;
   float xmin, ymin, zmin, xmax, ymax, zmax, offset;

   
   //printf(&quot;CAT3DViewport::IsOutside // ratio (%.4f)\n&quot;, ratio);
   //printf(&quot;Bounding Box -&gt; min (%.4f,%.4f,%.4f) // max (%.4f,%.4f,%.4f)\n&quot;, bbox-&gt;minPoint.x, bbox-&gt;minPoint.y, bbox-&gt;minPoint.z, bbox-&gt;maxPoint.x, bbox-&gt;maxPoint.y, bbox-&gt;maxPoint.z);
   //printf(&quot;Bound Sphere -&gt; center (%.4f,%.4f,%.4f) // radius (%.4f) // radius_mm (%.4f)\n&quot;, bs3D._center.x, bs3D._center.y, bs3D._center.z, bs3D._radius, bs3D._radius_mm);
   //printf(&quot;--\n&quot;);
   
   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   if (bbox)
   {
    for ( i = 5; i &gt;= 0; i-- )
    {
     isect  = 0;
     offset = - d[i];

    
     //printf(&quot;Clipping Plane Equation (%.4f,%.4f,%.4f,%.4f,)\n&quot;, a[i], b[i], c[i], d[i]);
    
     xmin = a[i] * bbox-&gt;minPoint.x;
     ymin = b[i] * bbox-&gt;minPoint.y;
     zmin = c[i] * bbox-&gt;minPoint.z;

     if (xmin+ymin+zmin &lt;= offset)
        isect++;
    
     xmax = a[i] * bbox-&gt;maxPoint.x;
     ymax = b[i] * bbox-&gt;maxPoint.y;
     zmax = c[i] * bbox-&gt;maxPoint.z;

     if (xmax+ymax+zmax &lt;= offset)
        isect++;
    
     if (xmin+ymin+zmax &lt;= offset)
        isect++;
    
     if (xmin+ymax+zmin &lt;= offset)
        isect++;
    
     if (xmin+ymax+zmax &lt;= offset)
        isect++;
    
     if (xmax+ymin+zmin &lt;= offset)
        isect++;
    
     if (xmax+ymin+zmax &lt;= offset)
        isect++;
    
     if (xmax+ymax+zmin &lt;= offset)
        isect++;

     //printf(&quot;isect = %d\n&quot;, isect);
    
     if (isect == 0)
     {
      return(1);
     }
    }
   }
   //printf(&quot;--\n&quot;);
  }
#else
  {
   float x = bs3D._center.x;
   float y = bs3D._center.y;
   float z = bs3D._center.z;
   float rayon;
  
   if(bs3D._radius_mm&gt;(1e-6))
    rayon=bs3D._radius+bs3D._radius_mm*ratio;
   else
    rayon=bs3D._radius; 
 
   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   for ( int i = 5; i &gt;= 0 ; i-- )
   { 
    if ( a[i]*x + b[i]*y + c[i]*z + d[i] - rayon &gt; 0 ) return (1);
   }
  }
#endif
 }

 return (0);
}


inline int CAT3DViewport::IsOutside (const float *center, 
                                     const float radius) const
{
  int i;
  
  // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
  // additionnels comme les clipping planes ne sont pas a prendre en compte
  for(i=5;i&gt;=0;i--)
  {
    if(a[i]*center[0]+b[i]*center[1]+c[i]*center[2]+d[i]-radius&gt;0)
      return 1;
  }

  return 0;
}

#ifdef _IRIX_SOURCE
inline int CAT3DViewport::IsOutside (const float x, const float y, const float z ) const
{
   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   for (int i = 5; i &gt;= 0; i-- )
   {
    if ((a[i] *x+b[i] * y+c[i] * z + d[i]) &gt; 0)
   	return 1;
   }
   return 0;
}

inline int CAT3DViewport::IsOutside (const CATMathPointf &amp;min_point, const CATMathPointf &amp;max_point ) const
{
// if (( min_point == NULL )||( max_point == NULL )) return (1);
// else
 {
   int   i, isect;
   float xmin, ymin, zmin, xmax, ymax, zmax, offset;

   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   for ( i = 5; i &gt;= 0; i-- )
   {
    isect  = 0;
    offset = - d[i];
    
    xmin = a[i] * (min_point.x);
    ymin = b[i] * (min_point.y);
    zmin = c[i] * (min_point.z);

    if (xmin+ymin+zmin &lt;= offset)
        isect++;
    
    xmax = a[i] * (max_point.x);
    ymax = b[i] * (max_point.y);
    zmax = c[i] * (max_point.z);

    if (xmax+ymax+zmax &lt;= offset)
        isect++;
    
    if (xmin+ymin+zmax &lt;= offset)
        isect++;
    
    if (xmin+ymax+zmin &lt;= offset)
        isect++;
    
    if (xmin+ymax+zmax &lt;= offset)
        isect++;
    
    if (xmax+ymin+zmin &lt;= offset)
        isect++;
    
    if (xmax+ymin+zmax &lt;= offset)
        isect++;
    
    if (xmax+ymax+zmin &lt;= offset)
        isect++;

    if (isect == 0)
        return(1);
   }
 }
 return (0);
}

inline int CAT3DViewport::IsOutside (const float *box_center, const float *box_dim ) const
{
 if (( box_center == NULL )||( box_dim == NULL )) return (1);
 else
 {
   int   i, isect;
   float xmin, ymin, zmin, xmax, ymax, zmax, offset;

   // Dans le cas du IsOutside on ne prend que les 6 plans de base, les plans
   // additionnels comme les clipping planes ne sont pas a prendre en compte
   for ( i = 5; i &gt;= 0; i-- )
   {
    isect  = 0;
    offset = - d[i];
    
    xmin = a[i] * (box_center[0] - box_dim[0]);
    ymin = b[i] * (box_center[1] - box_dim[1]);
    zmin = c[i] * (box_center[2] - box_dim[2]);

    if (xmin+ymin+zmin &lt;= offset)
        isect++;
    
    xmax = a[i] * (box_center[0] + box_dim[0]);
    ymax = b[i] * (box_center[1] + box_dim[1]);
    zmax = c[i] * (box_center[2] + box_dim[2]);

    if (xmax+ymax+zmax &lt;= offset)
        isect++;
    
    if (xmin+ymin+zmax &lt;= offset)
        isect++;
    
    if (xmin+ymax+zmin &lt;= offset)
        isect++;
    
    if (xmin+ymax+zmax &lt;= offset)
        isect++;
    
    if (xmax+ymin+zmin &lt;= offset)
        isect++;
    
    if (xmax+ymin+zmax &lt;= offset)
        isect++;
    
    if (xmax+ymax+zmin &lt;= offset)
        isect++;

    if (isect == 0)
        return(1);
   }
 }
 return (0);
}
#endif
#endif
</div>
    
    <div class="navigation">
        <div><a href="CAT3DViewpoint.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DViewpoint.h</a></div>
        <div><a href="CAT3x3Matrix.html">‰∏ã‰∏ÄÈ°µ: CAT3x3Matrix.h ‚Üí</a></div>
    </div>
</body>
</html>