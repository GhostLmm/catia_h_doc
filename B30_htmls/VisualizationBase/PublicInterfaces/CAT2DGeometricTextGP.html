<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisualizationBase/PublicInterfaces/CAT2DGeometricTextGP.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>VisualizationBase/PublicInterfaces/CAT2DGeometricTextGP.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CAT2DGeomTextStructures.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT2DGeomTextStructures.h</a></div>
        <div><a href="CAT2DImagePixelGP.html">‰∏ã‰∏ÄÈ°µ: CAT2DImagePixelGP.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CAT2DGeometricTextGP_H
#define CAT2DGeometricTextGP_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */

#include &quot;CATViz.h&quot;     
#include &quot;CAT2DGeomTextStructures.h&quot;
#include &quot;CAT2DTextGP.h&quot;
#include &quot;CATUnicodeString.h&quot;
class CATRender;
class CATFont;
class CATStreamer;

/**
* Class to create a dynamic graphic primitive of 2D geometric text.
* &lt;b&gt;Role&lt;/b&gt;: 
* These Graphic primitives have a continuous zoom. 
* @see CAT2DAnnotationTextGP
*/ 
class ExportedByCATViz CAT2DGeometricTextGP: public CAT2DTextGP
{
   CATDeclareClass;
 
   public:

      /**
      * Constructs a 2D geometric text Graphic primitive.
      * @param iPoint
      *	the position of the Graphic Primitive in a 2D space.
      * @param iString
      *	the string of characters which composes the text of 
      *	the 2D geometric text.
      * @param iHeight
      *	the Height of the 2D geometric text.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	the default value is 10.
      * @param iHorJustification
      *	the orthogonal justification of the 2D geometric text.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : normal&lt;/li&gt;
      *	&lt;li&gt; 1 : centered&lt;/li&gt;
      *	&lt;li&gt; 2 : opposite&lt;/li&gt;&lt;/ul&gt;
      *	&lt;br&gt; NB : for a code page where characters are
      *			displayed in a directional
      *			way from left to right, normal = left
      *			and opposite = right
      * @param iVerJustification
      *	the vertical justification of the 2D geometric text.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : top&lt;/li&gt;
      *	&lt;li&gt; 1 : cap&lt;/li&gt;
      *	&lt;li&gt; 2 : half&lt;/li&gt;
      *	&lt;li&gt; 3 : base&lt;/li&gt;
      *	&lt;li&gt; 4 : bottom&lt;/li&gt;&lt;/ul&gt;
      * @param iFont
      *	the font of the 2D geometric text.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	the default value is NULL. It represents the default font.
      * @param iPitch
      *	the pitch of the font.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : fixed&lt;/li&gt;
      *	&lt;li&gt; 1 : variable&lt;/li&gt;&lt;/ul&gt;
      * @param iPath
      *	the way where each character is drawn with respect to the last one drawn.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : left to right&lt;/li&gt;
      *	&lt;li&gt; 1 : top to bottom&lt;/li&gt;
      *	&lt;li&gt; 2 : right to left&lt;/li&gt;
      *	&lt;li&gt; 3 : bottom to top&lt;/li&gt;&lt;/ul&gt;
      *	&lt;br&gt; Exemple :
      *&lt;pre&gt;
      * 0:  TEST  | 1:  T   | 2:  TSET  | 3:  T
      *           |     E   |           |     S
      *           |     S   |           |     E
      *           |     T   |           |     T
      *&lt;/pre&gt;
      * @param iOrientationAngle
      *	an angle in degree to rotate the 2D geometric text in the 2D plan.
      *	The inital angle is determined by &lt;tt&gt;iPath&lt;/tt&gt;.
      * @param iSpacingFactor
      *	the space factor between each character of the &lt;tt&gt;iString&lt;/tt&gt;.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	the default value is -10000.
      *	&lt;br&gt; it represents 1/7 for stroke font and 0 for type1 font.
      * @param iCompFactor
      *	the compression/extension factor of each character of the &lt;tt&gt;iString&lt;/tt&gt;.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	the default value is 1. It means that there is no extension and no compression.
      * @param iSlantAngle
      *	slant angle in degrees. The slant transformation has the following matrix: &lt;pre&gt;
      *  +-                   -+
      *  ! 1  sin(iSlantAngle) !
      *  !                     !
      *  ! 0  cos(iSlantAngle) ! 
      *  +-                   -+&lt;/pre&gt;
      *
      *	For example, when 0&lt;&lt;tt&gt;iSlantAngle&lt;/tt&gt;&lt;90 , it can be 
      *	considered as the composition of the two following 
      *	transformations:
      *	&lt;ul&gt;&lt;li&gt;Y affinity with a cos(iSlantAngle) coefficient&lt;/li&gt;
      *	&lt;li&gt;shear transformation (&quot;transvection&quot; or &quot;cisaillement&quot; in french) whose:
      *	&lt;ul&gt;&lt;li&gt;X axis is the axis which each point is invariant&lt;/li&gt;
      *	&lt;li&gt;top-right coefficient of the matrix is tangent(&lt;tt&gt;iSlantAngle&lt;/tt&gt;)&lt;/li&gt;&lt;/li&gt;&lt;/ul&gt;
      * @param iKerningEnable
      *  to apply the kerning value between pair of glyph. Only used for OpenType font.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : default value, no kerning value will be applied&lt;/li&gt;
      *	&lt;li&gt; 1 : kerning value is applied (if the font is an OpenType font)&lt;/li&gt;&lt;/ul&gt;
      * @param iTextVersion
      *  to apply the code enhancement to the text display.
      *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : default value, no code enhancement will be applied&lt;/li&gt;
      *	&lt;li&gt; xxyzz : enhancement is applied if the version is great or eqale to current version&lt;/li&gt;&lt;/ul&gt;
      */
      CAT2DGeometricTextGP (const float iPoint[2],
                            const CATUnicodeString &amp;iString,
                            const float iHeight=10.,
                            const int iHorJustification = 1,
                            const int iVerJustification = 3,
                            const int iPitch = 0,
                            const CATFont * iFont = NULL,
                            const int iPath = 0, 
                            const float iOrientationAngle = 0.f,
                            const float iSpacingFactor = -10000.f, 
                            const float iCompFactor = 1.f,
                            const float iSlantAngle = 0.f,
                            const int iKerningEnable = 0,
                            const unsigned int iTextVersion = 0);

      /** @nodoc */
      CAT2DGeometricTextGP (const CATUnicodeString &amp; iString,
                            const CAT2DGeomTextAttributeSet iAttributeSet,
                            const CATFont * iFont = NULL);

      /** @nodoc */
      CAT2DGeometricTextGP ();

      /** @nodoc */
      virtual ~CAT2DGeometricTextGP() ;
      
      //Streaming
      /** @nodoc */
      virtual void Stream(CATStreamer&amp; str,int savetype=0);
      /** @nodoc */
      virtual void UnStream(CATStreamer&amp; str);
      
      /**
      * Retrieves data about the 2D geometric text.
      * @param oCharCountPtr
      *	the number of characters of the string of the 2D geometric text.
      * @param oStringPtr
      *	the string of characters of the 2D geometric text.
      * @param oFontPtr
      *	the font used to display the 2D geometric text.
      * @param oGeomAttSetPtr
      *	the attribute set for the 2D geometric text (it contains the position, the pitch, the height,...).
      * @param oBoundingBoxPtr
      *	the bounding box for the 2D geometric text.
      */
      virtual void Get ( int* oCharCountPtr,
                         char** oStringPtr,
                         CATFont** oFontPtr,
                         CAT2DGeomTextAttributeSet* oGeomAttSetPtr,
                         CAT2DGeomTextBoundingBox* oBoundingBoxPtr );
      
      /**
      * Gets a 4-points bounding box (Parallelepiped) around the 2D geometric text.
      * @param oPoint
      *	four 2D points of the bounding box (0:x1 , 1:y1, 2:x2 , 3:y2,  4:x3 , 5:y3, 6:x4 , 7:y4 
      *	Caution: oPoint must be allocated by the calling service (length = 8))
      */
      virtual void GetBoundingBox( float* oPoint );// 0:x1 , 1:y1, 2:x2 , 3:y2, 4:x3 , 5:y3, 6:x4 , 7:y4 
                                                   // Caution: oPoint must be allocated by the calling service (length = 8) */
      
      /**
      * Retrieves data about the stroke 2D geometric text.
      * @param oCharCountPtr
      *	the number of characters of the string of the stroke 2D geometric text.
      * @param oStringPtr
      *	the string of characters of the stroke 2D geometric text.
      * @param oFontPtr
      *	the font used to display the stroke 2D geometric text.
      * @param oGeomAttSetPtr
      *	the attribute set for the stroke 2D geometric text (it contains the position, the pitch, the height,...).
      * @param oBoundingBoxPtr
      *	the bounding box for the stroke 2D geometric text.
      */
      virtual void GetStroke ( int* oCharCountPtr,
                               char** oStringPtr,
                               CATFont** oFontPtr,
                               CAT2DGeomTextAttributeSet* oGeomAttSetPtr,
                               CAT2DGeomTextBoundingBox* oBoundingBoxPtr);
      
#ifdef _WINDOWS_SOURCE
      /**
      * Retrieves GDI attributes.
      * @param oTrueTypeEquivalent
      *	the flag to know if an equivalent truetype 2D geometric text exists.
      *	Following attributs have a sense only if &lt;tt&gt;oTrueTypeEquivalent&lt;/tt&gt; == 1 
      *	&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : no TrueType equivalent exist.&lt;/li&gt;
      *	&lt;li&gt; 1 : the TrueType equivalent exists.&lt;/li&gt;&lt;/ul&gt;
      * @param oCellHeight
      *	the cell height in model coordinates to create the equivalent true type font.
      * @param oWidth
      *	equal to -1 (there&#x27;s no utility here).
      * @param oEscapement
      *	the escapement in tenths of degrees to create the equivalent true type font.
      * @param oOrientation
      *	the orientation in tenths of degrees to create the equivalent true type font.
      * @param oWeight
      *	the Weight to create the equivalent true type font.
      * @param oItalicFlag
      *	the flag to specify if the equivalent true type font is an italic or not italic font.
      *	&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : the equivalent true type font is not an italic font.&lt;/li&gt;
      *	&lt;li&gt; 1 : the equivalent true type font is an italic font.&lt;/li&gt;&lt;/ul&gt;
      * @param oCharSet
      *	the character set to create the equivalent true type font.
      * @param oPitchAndFamily
      *	the PitchAndFamily to create the equivalent true type font.
      * @param oTypeFaceName
      *	the FaceName to create the equivalent true type font.
      * @param oAlignment
      *	the alignement (an attribute for SetTextAlign).
      * @param oExtraSpacing
      *	the extra spacing in model coordinates (an attribute for SetTextCharacterExtra).
      * @param oString
      *	the string to create the equivalent 2D geometric text.
      * @param oCharCount
      *	the number of characters of &lt;tt&gt;oString&lt;/tt&gt;
      * @param oXPoint
      *	the X position in model coordinates of the equivalent D geometric text.
      * @param oYPoint
      *	the Y position in model coordinates of the equivalent D geometric text.
      */
      virtual void GetGDI ( int&amp; oTrueTypeEquivalent,
                            float&amp; oCellHeight,      
                            float&amp; oWidth,          
                            int&amp; oEscapement,       
                            int&amp; oOrientation,      
                            int&amp; oWeight,
                            int&amp; oItalicFlag,       
                            int&amp; oCharSet,
                            int&amp; oPitchAndFamily, 
                            CATUnicodeString&amp; oTypeFaceName,
                            unsigned int&amp; oAlignment, 
                            float&amp; oExtraSpacing,    
                            CATUnicodeString&amp; oString,
                            int&amp; oCharCount,
                            float&amp; oXPoint, 
                            float&amp; oYPoint);         
#endif

      /**
      * Retrieves applicative up values.
      *	This up values are independent of the content of the CAT2DGeometricText
      *	string: they are related to the whole font character set.
      *	If the font contains no symbol, the top and bottom values provided
      *	correspond to the maximum and minimum values of the font characters
      *	bounding box. If the font contains symbols, they are not taken into
      *	account.
      * @param oUpValues
      *	Up values ( &lt;tt&gt;oUpValues&lt;/tt&gt; must be allocated by the  calling service)
      *	&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
      *	&lt;ul&gt;&lt;li&gt; 0 : base -&gt; bottom&lt;/li&gt;
      *	&lt;li&gt; 1 : base -&gt; half&lt;/li&gt;
      *	&lt;li&gt; 2 : base -&gt; cap&lt;/li&gt;
      *	&lt;li&gt; 3 : base -&gt; top&lt;/li&gt;
      *	&lt;li&gt; 4 : bottom -&gt; top&lt;/li&gt;&lt;/ul&gt;
      */
      void GetApplicativeUpValues(float oUpValues[5]); 
      
      
      /**
      * Sets the applicative picking rectangle.
      * This service is a dirty solution. The problem is that, currently, there is
      * no way, in Immediate draw, to know if the CATRender corresponds to a picking
      * or not. Consequently, the best solution (distinguish the picking case in
      * Immediate draw and let the application create a new applicative GP which
      * inherits from the CAT2DGeometricTextGP) cannot be implemented. Consequently
      * we are obliged:
      *  &lt;ul&gt;&lt;li&gt;to put code in CATPickingRender::Draw2DGeometricText&lt;/li&gt;
      *  &lt;li&gt;manage the applicative picking in the CAT2DGeometricTextGP itself&lt;/li&gt;&lt;/ul&gt;
      * @param iAnchorToFirstAlgebraicValue
      *	if you consider the line which is along the 
      *	deplacement direction, and passes through the
      *	anchor point, oriented by the deplacement
      *	direction, this value is the algebraic value
      *	from the anchor point to the intersection with: 
      *	&lt;ul&gt;&lt;li&gt;Path right case: left side of the rectangle &lt;/li&gt;
      *	&lt;li&gt;path down case: up side of the rectangle&lt;/li&gt;
      *	&lt;li&gt;Path left case: right side of the rectangle&lt;/li&gt;
      *	&lt;li&gt;path up case: bottom side of the rectangle&lt;/li&gt;&lt;/ul&gt;
      * @param iAnchorToSecondAlgebraicValue
      *	the same as &lt;tt&gt;iAnchorToFirstAlgebraicValue&lt;/tt&gt;, except that you take the opposite side of the rectangle 
      * @param iAnchorToTransversalBottom
      *	consider the line which passes through the anchor
      *	point, perpendicular to the deplacement 
      *	direction, with an associated unitary vector, 
      *	oriented so that:&lt;ul&gt;
      *	&lt;li&gt;Path right case: the scalar product between
      *	the unitary vector and the up vector is
      *	positive &lt;/li&gt;
      *	&lt;li&gt;path down case: the scalar product between
      *	the unitary vector and the base vector is
      *	positive &lt;/li&gt;
      *	&lt;li&gt;Path left case: the scalar product between
      *	the unitary vector and the up vector is
      *	positive   &lt;/li&gt;
      *	&lt;li&gt;path up case: the scalar product between
      *	the unitary vector and the base vector is
      *	positive &lt;/li&gt;&lt;/ul&gt;
      *	Then, this value is the algebraic value, along 
      *	this line, from the anchor point to the 
      *	intersection of this line with the following
      *	side of the rectangle:
      *	&lt;ul&gt;&lt;li&gt;Path right case: bottom&lt;/li&gt;
      *	&lt;li&gt;path down case: left&lt;/li&gt;
      *	&lt;li&gt;Path left case: bottom&lt;/li&gt;
      *	&lt;li&gt;path up case: left&lt;/li&gt;&lt;/ul&gt;
      * @param iAnchorToTransversalTop
      *	the same as &lt;tt&gt;iAnchorToTransversalBottom&lt;/tt&gt;, except that you take the opposite side of the rectangle.
      */
      void SetApplicativePickingRectangle( float iAnchorToFirstAlgebraicValue, 
                                           float iAnchorToSecondAlgebraicValue,
                                           float iAnchorToTransversalBottom,
                                           float iAnchorToTransversalTop);
      
      /**
      *	Reset the applicative picking rectangle.
      */
      void ResetApplicativePickingRectangle();
      
      
      /** @nodoc */
      static void sComputeBoundingBox(CAT2DGeomTextAttributeSet&amp; iGeomAttSet,
                                      CAT2DGeomTextBoundingBox&amp; iBoundingBox,
                                      float* oPoint);// 0:x1 , 1:y1, 2:x2 , 3:y2, 4:x3 , 5:y3, 6:x4 , 7:y4 
                                                     // Caution: oPoint must be allocated by the calling service (length = 8)
      
      
      
      /**
      * Draws the dynamic graphic primitive with a render.
      * @param iRender
      *	the render used to draw the dynamic graphic primitive.
      */
      virtual void Draw (CATRender&amp; iRender);
      
      
      
      /** 
      * Draws a 2D geometric text.
      * @param iRender
      *	the render used to draw the 2D geometric text.
      * @param iViewpoint
      *	the viewpoint used to draw the 2D geometric text.
      * @param iViewport
      *	the viewport used to draw the 2D geometric text.
      */
      virtual void ImmediateDraw (CATRender &amp; iRender,const CATViewpoint* iViewpoint, const CATViewport* iViewport);   
      
      /** @nodoc */
      float* _ApplicativePickingRectangle;
      
      /** @nodoc */
      int _ApplicativeMetricsFirstCharIndex; 
      
      /** @nodoc */
      int _ApplicativeMetricsSecondCharIndex;
          
      /** @nodoc */
      float* _ApplicativeMetricsFirstSide;
      
      /** @nodoc */
      float* _ApplicativeMetricsSecondSide;
      
      /**
      *	Sets the 2D geometric text background.
      *	This method allows to describe the background of the 2D geometric text.
      *	The background is a polygon filled with one color.
      *	@param iPoint
      *		Points which describe the polygon (they are 2D points).
      *		This is an array of float and its size is equal to two times the number of points (XYXYXY...).
      *		&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: the default value is NULL. It means there is no background available.
      *	@param iNb_point
      *		Number of 2D points.
      *		&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: the default value is 0. 	
      *	@param iColor
      *		table which describes the color of the background. The lenght of this 
      *		table is 3 (RGB).
      *		&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: the default value is NULL.
      */
      void SetTextBackground(float * iPoint=NULL, int iNb_point=0, int * iColor=NULL);
      
      /**
      *	Removes data about the 2D geometric text background.
      *	It initalizes to 0 all datas on the background.
      */
      void UnsetTextBackground();
      
//--------------------------------------------------------------------------

   protected:


      /** @nodoc */
      CAT2DGeomTextAttributeSet _AttributeSet;
      
      /** @nodoc */
      CAT2DGeomTextBoundingBox _BoundingBox;
      
      /** @nodoc */
      CAT2DGeomTextAttributeSet* _StrokeAttributeSetPtr;
      
      /** @nodoc */
      CAT2DGeomTextBoundingBox* _StrokeBoundingBoxPtr;
      
   private:
      
      float * _bkgPolygonPt;
      int     _textBkg, _nbBkgPolygonPt;
      int   * _bkgPolygonColor;
      
      // Get 4 points font bounding box (rectangle, independante of the text string)
      virtual void GetFontBoundingBox( float* oPoint );// 0:x1 , 1:y1, 2:x2 , 3:y2, 4:x3 , 5:y3, 6:x4 , 7:y4 
                                                       // Caution: oPoint must be allocated by the calling service (length = 8)

      void InitWithAttributeSet(const CAT2DGeomTextAttributeSet iAttributeSet);
};

// CAT2DGeometricTextGP_H
#endif 









</div>
    
    <div class="navigation">
        <div><a href="CAT2DGeomTextStructures.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT2DGeomTextStructures.h</a></div>
        <div><a href="CAT2DImagePixelGP.html">‰∏ã‰∏ÄÈ°µ: CAT2DImagePixelGP.h ‚Üí</a></div>
    </div>
</body>
</html>