<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDMRuntime/PublicInterfaces/SdaiAppInstance.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>SDMRuntime/PublicInterfaces/SdaiAppInstance.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="SdaiAppBag.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SdaiAppBag.h</a></div>
        <div><a href="SdaiAppIterator.html">‰∏ã‰∏ÄÈ°µ: SdaiAppIterator.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/**
 * @quickReview LDI 02:06:21
 */
// COPYRIGHT DASSAULT SYSTEMES  1996
//=============================================================================
//
// SdaiAppInstance:
//  an instance of an entity in an application schema
//
//=============================================================================
// Usage Notes:
//
// cf. Norm ISO 10303-22 (binding C++)
//=============================================================================
// Feb. 96   Creation                                   C. Vandaele
//=============================================================================

#ifndef SdaiAppInstance_H
#define SdaiAppInstance_H

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */


#include &lt;SdaiMacro.h&gt;
#include &lt;CATCollec.h&gt;
#include &quot;KS0LATE.h&quot;
#include &lt;SdaiEntityInstance.h&gt;
#include &quot;CATSmallAllocatorPerBlock.h&quot;

class SdaiAttr;
class CATSdaiAppInstance;
class SdaiList;
class SdaiExplicitAttr;
class SdaiBoolean;
class SdaiEntity;
class CATSdaiAttrValue;
class CATLISTP(SdaiAttr);


// ------------------------------------------------------------------------------------------------
// Constant Declaration
// ------------------------------------------------------------------------------------------------
ExportedByKS0LATE extern const SdaiInteger BASE_SAVE;

// ------------------------------------------------------------------------------------------------
// Definition :
//
//	&#x27;SdaiAppInstance&#x27; est la super-classe de toutes les entits applicatives.
//
// ------------------------------------------------------------------------------------------------
// Definition EXPRESS :
//
//	ENTITY	application_instance
//
//		SUBTYPE OF (entity_instance)
//
//	END_ENTITY ;
//
// ------------------------------------------------------------------------------------------------

// (CECI ETAIT DANS LA NORME SDAI : class SdaiAppInstance : virtual public SdaiEntityInstance )
// Modification OFR : sinon problemes avec SdaiEntityInstance qui devient une base virtuelle
/**
 * Class for SDAI application schema instances.
 */
class ExportedByKS0LATE SdaiAppInstance : public SdaiEntityInstance
{
    /** @nodoc pour utilisation de l operateur prive delete */ 
    friend class CATSdaiTRSInstanceCreation;
    /** @nodoc pour utilisation de l operateur prive delete */ 
    friend class CATSdaiTRSInstanceErasure;
    /** @nodoc pour CreateEntityInstance */ 
    friend class SdaiEntityInstance;
    /** @nodoc pour acces au destructeur */ 
    friend class CATSdaiModelContents;
    /** @nodoc pour acces au destructeur (methode statique DriverDelete) */
    friend class CATSdaiAppInstance;

    // ****************************************************************************************
    // C O N S T R U C T O R S
    // D E S T R U C T O R
    // ****************************************************************************************
    public :
    /** @nodoc */
    SdaiAppInstance();

    // Constructeur dans un modele
    /** @nodoc */
    SdaiAppInstance( SdaiModelH) {}
    
    /** @nodoc */
    SdaiAppInstance( const SdaiAppInstance&amp; a_repliquer );

    protected :
    /** @nodoc virtual */	
    virtual ~SdaiAppInstance();	// Destruction physique

public:
  /** @nodoc */
  void release();

    // ****************************************************************************************
    // M E M O R Y   M A N A G M E N T   O P E R A T I O N S
    // ****************************************************************************************
    public :
    // Operateur new (qui ne doit pas etre defini : cf D.10.5.3, p. 365)
    /** @nodoc */
    //static void* operator new ( size_t l) { return ::operator new(l); }
#ifndef NO_CATSmallAllocatorPerBlock
    /** @nodoc */
    static void* operator new ( size_t, SdaiModelH );
#endif
    protected :
    // Norme C++ : L&#x27;operateur delete doit toujours avoir un premier argument de type void *
    // (bmx0398) static void operator delete (void * p) {::operator delete(p);}

    // ****************************************************************************************
    // S D A I    O P E R A T I O N    D E C L A R A T I O N S
    // ****************************************************************************************
    public :
    /**
     * Destroys a SdaiAppInstance.
     *  @param appInst - the concerned SdaiAppInstance
     */
    static void Delete ( SdaiAppInstanceH appInst );

    // determine si l&#x27;instance et le parametre entInst sont egales (au sens de l&#x27;operateur :=:)
    /** @nodoc */
    virtual const SdaiLogical &amp; 	IsSame ( const SdaiEntityInstanceH&amp;	entInst )  const;

    /**
     * Gets the value of an attribute.
     *  @param attName - the name of the attribute
     *
     * JNI 05/03/02 GetAttr calls are always in &quot;current context&quot;, if a driver context view is
     * needed (this is usually only needed by the driver itself), then use AttrValueAccess.
     * 
     */
    const SdaiPrimitiveH &amp;		GetAttr	( const SdaiString&amp;  attName )	const;
    /** @nodoc
     * Same as above, except its works with the attribute definition, and therefore is faster (especially
     * if you need to read the same attribute on many objects of the same type.
     */
    virtual const SdaiPrimitiveH &amp;		GetAttr	( const SdaiAttrH&amp;  attDef )	const;
  
    /**
     * Tests if an attibute has a valid value.
     *  @param att_name - the name of the attribute
     */
    const SdaiBoolean &amp;	TestAttr( const SdaiString&amp;  att_name )  const;
    /** @nodoc */
    const SdaiBoolean &amp;	TestAttr( const SdaiAttrH&amp;  att_def )	 const;

    /**
     * Erases the value of an attribute.
     *  @param attName - the name of the attribute
     */
    virtual void UnsetAttr ( const SdaiString&amp; attName ) ;
    
    /** @nodoc 
     * Erases the value of an attribute
     * @param -the definition of the attribute
     * @iCtxt only available if compiled with transaction context support
     *        
     */
#ifndef SDAI_MULTI_TRANS_BCC  
		virtual void UnsetAttr ( const SdaiAttrH&amp; attDef ) ;
#else
		/** @nodoc */
    virtual void UnsetAttr ( const SdaiAttrH&amp; attDef , SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) ; 
#endif

    // assigne une valeur a un attribut
    /** @nodoc */
    void	PutAttr ( const SdaiString&amp;	attrName,
            SdaiPrimitiveType	attrType,
            const SdaiPrimitiveH&amp;	attrVal );
    /** @nodoc */
    void	PutAttr ( const SdaiAttrH&amp;	attrDef,
            SdaiPrimitiveType	attrType,
            const SdaiPrimitiveH&amp;	attrVal);

    /**
     * Assigns a value to an attribute.
    *  @param attName - the name of the attribute
    *  @param attrVal - the value of the attribute
    */
    void	PutAttr ( const SdaiString&amp;	attrName,
            const SdaiPrimitiveH&amp;	attrVal );
    /** @nodoc */
#ifdef SDAI_MULTI_TRANS_BCC    
    inline void	PutAttr ( const SdaiAttrH&amp;	attrDef,
            const SdaiPrimitiveH&amp;	attrVal )
    {
        PutAttrContextSensitive( attrDef, 
                attrVal, CurrentTransactionContext);

    }
    /** @nodoc
     * Valuate an attribute.
     * The value iCtxt will determine if the attribute is valuated in the
     * current transaction context (normal case) or in the default transaction
     * context (only to be used by drivers which are valuating the attribute
     * from persistent data)
     */
    virtual void PutAttrContextSensitive( const SdaiAttrH&amp;	attrDef, 
            const SdaiPrimitiveH&amp;	attrVal, SdaiRoot::ContextSensitivity iCtxt);

#else
		/** @nodoc */
    virtual void	PutAttr ( const SdaiAttrH&amp;	attrDef,
            const SdaiPrimitiveH&amp;	attrVal );
#endif
    // cree une copie du receveur dans le &#x27;targetModel&#x27; (le modele courant par defaut)
    /** @nodoc */
    SdaiAppInstanceH CopyApplInstance ();
    /** @nodoc */
    SdaiAppInstanceH CopyApplInstance (SdaiModelH&amp; targetModel);

    // effectue tous les controles de coherence sur le receveur
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateInstance () const;

    // verifie que chaque attribut explicite du receveur est value
    /** @nodoc */
    virtual const SdaiBoolean &amp; ValidateRequiredExplicitAttrsAssigned (CATLISTP(SdaiAttr)*&amp;) const;

    // verifie que chaque attribut inverse du receveur verifie ses contrintes de cardinalite
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateInverseAttrs () const;

    // verifie les regles d&#x27;unicite (se fait directement a partir
    // du modele)
    // const SdaiLogical&amp; CompareAttrValues ( const SdaiAppInstanceH, const SDAIAGGRH( SdaiList,SdaiAttrH ) ) const ;

    //	virtual const SdaiLogical &amp; ValidateUniquenessRule ( const SdaiString&amp; ruleName ) const;
    //	virtual const SdaiLogical &amp; ValidateUniquenessRule ( const SdaiUniquenessRuleH&amp; ruleDef ) const;

    // verifie les regles WHERE du receveur
    /**
     * Checks the WHERE rule of the receiver.
     *  @param ruleName - the name of the rule
     *  @return
     *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;
     *   &lt;dl&gt;
     *     &lt;dt&gt;SdaiTRUE&lt;/dt&gt;
     *     &lt;dd&gt;Rule is verified&lt;/dd&gt;
     *	  &lt;dt&gt;SdaiFALSE&lt;/dt&gt;
     *     &lt;dd&gt;Rule is not verified&lt;/dd&gt;
     *	  &lt;dt&gt;sdaiUNKNOWN&lt;/dt&gt;
     *     &lt;dd&gt;Rule can not be verify&lt;/dd&gt;
     *   &lt;/dl&gt;
     *
     */
    virtual const SdaiLogical &amp; ValidateWhereRule ( const SdaiString&amp; ruleName ) const;
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateWhereRule ( const SdaiWhereRuleH&amp; ruleDef ) const;

    // verifie que les attributs de type reference du receveur sont du bon type
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateExplicitAttrsReferences () const;

    // verifie que les attributs de type agregat du receveur ont une taille conforme a la specif.
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateAggrSize (CATLISTP(SdaiAttr)*&amp;) const;

    // verifie que les attributs de type UNIQUE agregat du receveur sont corrects
    /** @nodoc */
    virtual const SdaiLogical &amp; ValidateAggrUniqueness () const;

    // conversion de type
    /** @nodoc */
    static	SdaiAppInstanceH	Castdown ( SdaiEntityInstanceH&amp;		baseClass);
#ifndef	_WINDOWS_SOURCE
    /** @nodoc */
    static	const SdaiAppInstanceH	Castdown ( const SdaiEntityInstanceH&amp;	baseClass);
#endif	// _WINDOWS_SOURCE

    /**
     * Creates a empty attribute of type aggregate.
     *  @param attName - the name of the attribute to create
     *  @return - the attibute created
     */
    SdaiAggrInstanceH CreateAggrInstance ( const SdaiString&amp; attName);
    /** @nodoc */
    virtual SdaiAggrInstanceH CreateAggrInstance ( const SdaiExplicitAttrH&amp; attrDef);

    /* Methode renvoyant le nom en clair de la classe */
    /** @nodoc */
    virtual const SdaiString &amp;      GetInstanceTypeName()   const ;

    /**
     * Tests if an instance is of a specified type or one of the subtypes of this type.
     *  @param typeName - the type specified
     */
    virtual	const SdaiBoolean &amp; IsKindOf	( const SdaiString&amp;	typeName )  const;
    /** @nodoc */
    const SdaiBoolean &amp; IsKindOf	( const SdaiEntityH&amp;	typeEnt )  const;

    // determine si l&#x27;instance est d&#x27;un type donne.
    /** @nodoc */
    virtual	const SdaiBoolean &amp;	IsInstanceOf	( const SdaiEntityH&amp;	typeEnt )  const;

    /**
     * Tests if an instance is an instance of specified type.
     *  @param iString - the type specified
     */
    virtual	const SdaiBoolean &amp;	IsInstanceOf	( const SdaiString&amp;	iString )  const;

    /**
     * Gets the name of the type of an instance.
     *  @return - the name of the type
     */
    virtual	const	SdaiNamedTypeH	GetInstanceType ( )  const;

    // ****************************************************************************************
    // D S    O P E R A T I O N    D E C L A R A T I O N S
    // ****************************************************************************************
    public:
    /** @nodoc
     * make all the modification done in the CurrentContext available in the DriverContext
     */

    // renvoie le nom du schema de l&#x27;instance
    /** @nodoc */
    virtual const 	SdaiString &amp;	GetInstanceSchemaName ()	const;

    // Fonction d&#x27;acces a l&#x27;identificateur de l&#x27;instance  - Ajout CCT -
    /** @nodoc */
    virtual const char * GetInstanceName () const ;
    /** @nodoc */
    virtual unsigned int GetInstanceNameId () const ;

    // ***** BACKUP *****: 
    // Retract        : l&#x27;etat courant est remplace par une sauvegarde 
    // Assert         : Suppression de sauvegardes intermediaires
    // Backup         : Sauvegarde
    // NumberOfBackup : Nombre de sauvegardes de l&#x27;instance
    // CurrentStatusId: Identificateur de l&#x27;etat courant (=numero de la prochaine sauvegarde)
    // TestBackup     : Teste si l&#x27;instance possede des sauvegardes
    /** @nodoc */
    unsigned char Retract(SdaiInteger s = BASE_SAVE);
    /** @nodoc */
    unsigned char Assert (SdaiInteger s = BASE_SAVE);
    /** @nodoc */
    unsigned char Backup ();
    /** @nodoc */
    SdaiInteger   NumberOfBackup();
    /** @nodoc */
    SdaiInteger   CurrentStatusId();
    /** @nodoc */
    unsigned char TestBackup() const;
    /** @nodoc */
    void	      DumpBackup() const;
    /** @nodoc */
    int	      BackupListSize() const;

    // Teste si l&#x27;etat courant de l&#x27;instance est marque detruit
    /** @nodoc */
    const SdaiBoolean &amp; DeletedInstance() const;

    // Dump de l&#x27;instance  - Ajout CCT -
    /** @nodoc */
    void  DumpInstance( ostream&amp; ) ;

    // determine si l&#x27;attribut a ete value ou mis a unset
    /** @nodoc */
    unsigned char	TestDefinedAttr	( const SdaiString&amp;  att_name )  const;
    /** @nodoc */
    unsigned char	TestDefinedAttr	( const SdaiAttrH&amp;  att_def )	const;

    // Remove the attribute value memory associated with this SDAI app instance
    /** @nodoc */
#define _SdaiAppInstUnloadAvail_ 1
    /** @nodoc */
    enum		UnloadMode { DefaultMode, RawMode };
    /** @nodoc */
  virtual void 		Unload( SdaiAppInstance::UnloadMode iMode );

    /* acces a l&#x27;implementation */
    /** @nodoc */
    inline  CATSdaiAppInstance *   AppInstance()  const { return  _AppInstance; }

    // ****************************************************************************************
    // I M P L E M E N T A T I O N
    // ****************************************************************************************
    protected :
    // Pointeur sur implementation
    /** @nodoc */
    CATSdaiAppInstance * _AppInstance;


    CATSmallAllocatorPerBlockDeclare

  public :
    /** @nodoc */
    virtual const SdaiBoolean &amp;	FastTestAttr ( const SdaiAttrH&amp;  ) const;
    /** @nodoc */
    virtual const SdaiPrimitiveH &amp;	FastGetAttr ( const SdaiAttrH&amp; ) const;


#ifdef SDAI_MULTI_TRANS_BCC    
public:
  /**
   * @nodoc
   */
    enum UndefMethod {
      ForceUndef,  // don&#x27;t raise any errors, undefine all attribute values on the instance, possibly losing changes in other contexts.
      NormalUndef, // raise an error if undefining an attribute loses another context&#x27;s changes. overwrite driver &amp; current context changes silently.
      ContextUndef,// refresh current context, overwrite privates changes without raising an error.
      DriverUndef  // raise an error if undefining an attribute loses changes in current context.
    };
    /** @nodoc */
    void UndefInstance(SdaiAppInstance::UndefMethod how = SdaiAppInstance::ContextUndef);

  /**
   * @nodoc
   * Apps shouldn&#x27;t have to use this service, it is only there for the purposes of SdaiStorableLog,
   * to find an attribute by its (block &amp; rank) indices.
   *
   */
  SdaiAttrH AttrDef(int block, int val);
#endif
}; 

#ifdef SDAI_MULTI_TRANS_BCC    
/**
 * @nodoc
 * retrieves an AttrValue.
 *
 * This method is not to be used outside of SDMRuntime &amp; SDAI_RDB.
 *
 * Low level method to gain access to an attribute value, this implements a copy on write
 * behaviour depending on the transaction context.
 * the AttrValue returned depends on the transaction context and on the intent (writing or reading).
 * if iCtxt is DriverTransactionContext, iForWrite is ignored and the value in _value_blocs (the default or
 * driver transaction context) is returned.
 * if the iCtxt is CurrentTransactionContext and iForWrite == 0 the AttrValue is the one in the
 * bloc corresponding to the current transaction. This may be the same as the one in the DriverTransactionContext 
 *  in some cases (if this value has not yet been modified in the current transaction).
 * 
 * If iCtxt is CurrentTransactionContext and iForWrite != 0 additional computation is done to implement a CopyOnWrite
 * mechanism between the DriverTransactionContext and all the additional transaction contexts.
 *
 * @param app       the instance for which the AttrValue will be returned
 * @param att_def   the attribute which is asked for
 * @param iForWrite indicates if this is used for writing or reading the attribute
 * @param iCtxt     the context for which the value needs to be returned (the Driver/Default context or the Current Context).
 *                  the DriverTransactionContext is called like that because the persistence driver is the only one 
 *                  which should ever access it directly
 *                  the CurrentTransactionContext is the default for this
 * @return the appropriate AttributeValue
 */

ExportedByKS0LATE CATSdaiAttrValue * AttrValueAccess(const SdaiAppInstanceH app ,const SdaiAttrH att_def, int iForWrite = 0, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
/** @nodoc */
ExportedByKS0LATE CATSdaiAttrValue * AttrValueAccessForUndef(const SdaiAppInstanceH app, const SdaiAttrH iAttDef,
                                                             SdaiAppInstance::UndefMethod meth, int&amp; error_raised);

#else
// Recuperation d&#x27;un acces a la valeur d&#x27;un attribut dans une instance
/** @nodoc */
ExportedByKS0LATE CATSdaiAttrValue * AttrValueAccess(const SdaiAppInstanceH app ,const SdaiAttrH att_def);
#endif

// Fonction globale determinant si une SdaiEntityInstance est valide (renvoie sdaiTRUE)
// ou invalide [ == NULL !? ] (renvoie sdaiFALSE)
/** @nodoc */
ExportedByKS0LATE extern const SdaiBoolean &amp;	EXISTS ( const SdaiAppInstanceH ) ;


// Global function to toggle on/off optimisation for cartesian points:
// Non null value = on, 0 = off.
/** @nodoc */
ExportedByKS0LATE void setCartesianPointOptim(int on);

// Global function to know if optimisation for cartesian points:
// 1 if on, 0 if off.
/** @nodoc */
ExportedByKS0LATE int getCartesianPointOptim();

# endif	/* _SDAI_APP_INSTANCE_H_ */




</div>
    
    <div class="navigation">
        <div><a href="SdaiAppBag.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SdaiAppBag.h</a></div>
        <div><a href="SdaiAppIterator.html">‰∏ã‰∏ÄÈ°µ: SdaiAppIterator.h ‚Üí</a></div>
    </div>
</body>
</html>