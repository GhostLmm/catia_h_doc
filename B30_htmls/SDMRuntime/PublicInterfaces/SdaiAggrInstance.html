<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SDMRuntime/PublicInterfaces/SdaiAggrInstance.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>SDMRuntime/PublicInterfaces/SdaiAggrInstance.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="SdaiAggr.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SdaiAggr.h</a></div>
        <div><a href="SdaiAggrType.html">‰∏ã‰∏ÄÈ°µ: SdaiAggrType.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/**
 * @quickReview LDI 02:06:21
 */
// COPYRIGHT DASSAULT SYSTEMES  1995
//=============================================================================
//
// SdaiAggrInstance
//      root class for all agregates
//=============================================================================
// Usage notes : 
//   SDAI -- C++ Language Binding
//   cf. Norme ISO 10303-23
//=============================================================================
// Aug. 93   Creation                                   C. Vandaele
// Nov. 95   Suppression of templates                   P.Y. Ramee
// May. 2002 Added COW for Enovia                       J.B. Nivoit
//=============================================================================
//
// Note that as of May 2002, when SDAI_MULTI_TRANS_BCC is turned on, aggregates
// have the capability to support Copy-On-Write when created properly. Not all
// aggregates need this ( SdaiList_Of_SdaiErrorEventH for instance does not need
// it, as any of the SDMRuntime private data ) : only aggregates that hold model
// data do. When created through SdaiAppInstance::CreateAggrInstance (that is,
// with a CATSdaiAggrPrototype), the aggregate yielded may or may not support COW:
// the behaviour can be determined per instance, although it usually is only per-model
// (so that one model can have COW for all the model data, while another one only
// supports direct writes). Be careful that aggregates created manually using &quot;new&quot;
// (creating instances of subclasses of SdaiAggrInstance on the stack is forbidden),
// will not by default support COW, so should never call PutAttr with such an
// aggregate, and always pass PutAttr an aggregate retrieved through CreateAggrInstance
// or GetAttr.
//
// One of the reasons for this is that the code generated by the Express compiler should
// not need to be modified, thus it is compulsory that as a default aggregates don&#x27;t have
// COW capability (to support code that creates a list of entities for the schema).
//
//

#ifndef SdaiAggrInstance_H
#define SdaiAggrInstance_H

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */

#include &lt;KS0SIMPL.h&gt;
#include &lt;SdaiRoot.h&gt;
#include &lt;SdaiBoolean.h&gt;

class SdaiBoolean;
class SdaiString;
class SdaiPrimitiveH;
class CATSdaiGenericAggr;
class CATSdaiWAggr;
class CATSdaiCOWAggr;
class CATSdaiAggrPrototype;

/** @nodoc */
enum AggType { Array, Bag, List, Set };

//-----------------------------------------------------------------------------
/**
 * Class aggregating SDAI instances.
 */
class ExportedByKS0SIMPL SdaiAggrInstance : public SdaiRoot
{
  friend class CATSdaiGenericAggr;
  friend class DeleteAggrVisitor2;

  friend class CATSdaiWAggr;
  friend class CATSdaiCOWAggr;
  
  friend class SdaiIterInstance;
  friend class CATSdaiTRSAttributeModification;
  friend class CATSdaiTRSAttrAggrCreation;
  friend class CATSdaiTRSAggrErasure;
  friend class SdaiAppInstance;
  friend class CATSdaiAppInstance;
  friend class CATSdaiAttrValue;

public:
  
  //------
  // &#x27;tors
  //------
/** @nodoc */
	SdaiAggrInstance(); // this is necessary to remain runtime-compatible while SDAI_MULTI_TRANS_BCC is not turned on.
/** @nodoc */
	SdaiAggrInstance( const SdaiAggrInstance&amp; iCopy);
/** @nodoc */
	SdaiAggrInstance&amp; operator=( const SdaiAggrInstance&amp; iCopy);

#ifdef SDAI_MULTI_TRANS_BCC
public:
  // JNI: this is necessary to allow logical destruction of an instance in a specific context while it is
  // still referred to in another private context.
	/** @nodoc */
  CATLONG32 refs;
	/** @nodoc */
  void addref();
	/** @nodoc */
  void release();
#endif  

public:
    //------------------
	// public generic utilities
    //------------------
	/**
    * Gets the type of a SdaiAggrInstance.
    *  @return
    *   The type of the instance
    */
	virtual const SdaiString &amp; GetInstanceTypeName()  const ; // ex : &quot;SdaiArray_Of_SdaiModel&quot; 

	/**
    * Tests if a SdaiAggrInstance is of a specified type.
    * @param iTypename - the specified type
    */
	virtual const SdaiBoolean &amp; IsKindOf ( const SdaiString&amp; iTypename)  const;

    //------------------
    // SDAI Operation declarations
    //------------------
	/**
    * Gets the number of items in the SdaiAggrInstance, or the size if it is an array.
    */
#ifndef SDAI_MULTI_TRANS_BCC
	SdaiInteger  GetMemberCount () const;           //TODO make that context sensitive
#else
	/** @nodoc */
	SdaiInteger  GetMemberCount (SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) const;           //TODO make that context sensitive
#endif
  
/** @nodoc */
	virtual SdaiPrimitiveType GetAggrElementsType() const = 0;  // Return general type of items
/** @nodoc */
	const   SdaiString &amp; GetAggrTypeName() const ;  // Returns &quot;ARRAY&quot; , &quot;BAG&quot; , &quot;LIST&quot; or &quot;SET&quot;
/** @nodoc */
	AggType GetAggrType() const ;                  // Returns Array , Bag , List or Set
/** @nodoc */
	virtual const SdaiString&amp; GetAggrElementsTypeName() const = 0;// ex : &quot;SdaiModel&quot;

	/**
    * Destroys a SdaiAggrInstance logically.
    *  @param ioAggr - the concerned SdaiAggrInstance
    */
#ifndef SDAI_MULTI_TRANS_BCC    
  //TODO make context sensitive
	static void DeleteAggr (SdaiAggrInstanceH ioAggr) ;
#else
	/** @nodoc */
	static void DeleteAggr (SdaiAggrInstanceH ioAggr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
#endif
  
	// extensions 
	// note: other operations are declared in SdaiAggr, Sdai[Un]Ordered and SdaiList
	/**
    * Empties a SdaiAggrInstance.
    */
#ifndef SDAI_MULTI_TRANS_BCC
  //TODO make context sensitive
	virtual int Empty ();
#else
	/** @nodoc */
	virtual int Empty (SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
#endif

	/**
    * Tests if a specified SdaiPrimitive is a member of a SdaiAggrAggrInstance.
		*  @param iMbr - the specified SdaiPrimitive
    */
#ifndef SDAI_MULTI_TRANS_BCC
	const SdaiBoolean&amp; IsMember(const SdaiPrimitiveH&amp; iMbr) const;     // Late  binding IsMember	
#else
	/** @nodoc */
	const SdaiBoolean&amp; IsMember(const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) const;     // Late  binding IsMember
#endif
  
	/**
    * Adds a SdaiPrimitive in a SdaiAggrInstance.
		*  @param iMbr - the SdaiPrimitive to add
    *  @return
    *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;
    *   &lt;dl&gt;
    *     &lt;dt&gt;SdaiTRUE&lt;/dt&gt;
		*     &lt;dd&gt;Add succeeded&lt;/dd&gt;
		*	  &lt;dt&gt;SdaiFALSE&lt;/dt&gt;
		*     &lt;dd&gt;Add failed&lt;/dd&gt;
    *   &lt;/dl&gt;
    *
    */
#ifndef SDAI_MULTI_TRANS_BCC
	virtual const SdaiBoolean&amp; AddMember(const SdaiPrimitiveH&amp; iMbr);     // Late  binding Add //TODO make context sensitive
#else
	/** @nodoc */
	virtual const SdaiBoolean&amp; AddMember(const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
#endif

	/**
    * Removes a SdaiPrimitive from a SdaiAggrInstance.
		*  @param iMbr - the SdaiPrimitive to remove
    *  @return
    *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;
    *   &lt;dl&gt;
    *     &lt;dt&gt;0&lt;/dt&gt;
		*     &lt;dd&gt; Remove succeeded&lt;/dd&gt;
		*	  &lt;dt&gt;1&lt;/dt&gt;
		*     &lt;dd&gt;Remove failed&lt;/dd&gt;
    *   &lt;/dl&gt;
    *
    */
#ifndef SDAI_MULTI_TRANS_BCC
	int RemoveMember(const SdaiPrimitiveH&amp; iMbr);  // Late  binding Remove      //TODO make context sensitive
#else
	/** @nodoc */
	int RemoveMember(const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);  // Late  binding Remove
#endif
  
/** @nodoc */
	SdaiAggrInstanceH  PrimitiveAggr();  // Late  binding Cast
/** @nodoc */
	const SdaiAggrInstanceH  PrimitiveAggr() const;  // Late  binding Cast
/** @nodoc */
	SdaiAggrInstanceH CreateNestedAggrInstance (SdaiIterInstance&amp;);         //TODO make context sensitive

    //------------------
    // Private even if declared as public
    //------------------
#ifdef SDAI_MULTI_TRANS_BCC
  
/** @nodoc */
	void DeletedAggr(const int, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
/** @nodoc */
	int PutMember(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
/** @nodoc */
	int InsertBeforeCurrent(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
/** @nodoc */
	int InsertAfterCurrent(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
  
#else
  
/** @nodoc */
	void DeletedAggr(const int) ;           //TODO make context sensitive
/** @nodoc */
	int PutMember(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr);       //TODO make context sensitive
/** @nodoc */
	int InsertBeforeCurrent(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr);     //TODO make context sensitive
/** @nodoc */
	int InsertAfterCurrent(const SdaiIterInstance&amp; iIter, const SdaiPrimitiveH&amp; iMbr);      //TODO make context sensitive
  
#endif

  
/** @nodoc */
	inline CATSdaiGenericAggr* GenericAggr()                    //TODO make context sensitive
	  {return CATagg_ ;} // says public, but private. 

  protected:
    //------
    // destructor
    //------
    // Physical Destruction is reserved (see static DeleteAggr)
	virtual ~SdaiAggrInstance() ;
  

    // other protected functions
/** @nodoc */
    void Init(CATSdaiGenericAggr* CATagg);
	/*virtual SdaiIterInstance* CreateIteratorInstance() const = 0;*/
#ifdef SDAI_MULTI_TRANS_BCC
/** @nodoc */
	SdaiPrimitiveH RemoveMember(const SdaiIterInstance&amp; iIter, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);      //TODO make context sensitive
/** @nodoc */
	virtual const SdaiPrimitiveH&amp; GetMember(const SdaiIterInstance&amp; iIter, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) const;  //TODO make context sensitive
/** @nodoc */
	const SdaiBoolean&amp; IndexedTest(int iIdx, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) const;     //TODO make context sensitive
#else
/** @nodoc */
	const SdaiPrimitiveH&amp; RemoveMember(const SdaiIterInstance&amp; iIter);      //TODO make context sensitive
/** @nodoc */
	virtual const SdaiPrimitiveH&amp; GetMember(const SdaiIterInstance&amp; iIter) const;  //TODO make context sensitive
/** @nodoc */
	const SdaiBoolean&amp; IndexedTest(int iIdx) const;     //TODO make context sensitive
#endif
  
	
	// check : 0 for OK

#ifdef SDAI_MULTI_TRANS_BCC
/** @nodoc */
	int CheckDeleted(SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);     //TODO make context sensitive
#else
/** @nodoc */
	int CheckDeleted();     //TODO make context sensitive
#endif

  /** @nodoc */
	int CheckModifiable(int&amp; oInv) const;

/** @nodoc */
	int CheckIterator(const SdaiIterInstance&amp; iIter) const;     //TODO make context sensitive

#ifdef SDAI_MULTI_TRANS_BCC
/** @nodoc */
	int CheckDuplicate(const SdaiPrimitiveH&amp; anItem,const int iExclPos, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext) const;  //TODO make context sensitive
	//int LocatePosition() const;
/** @nodoc */
	int InsertAtPosition(const SdaiIterInstance&amp; itr, const SdaiPrimitiveH&amp; anItem, int position, int iDrEvtType,int inverse, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);    //TODO make context sensitive
/** @nodoc */
	int Resize(const int iMore, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);            //TODO make context sensitive
#else
/** @nodoc */
	int CheckDuplicate(const SdaiPrimitiveH&amp; anItem,const int iExclPos) const;  //TODO make context sensitive
	//int LocatePosition() const;
/** @nodoc */
	int InsertAtPosition(const SdaiIterInstance&amp; itr, const SdaiPrimitiveH&amp; anItem, int position, int iDrEvtType,int inverse );    //TODO make context sensitive
/** @nodoc */
	int Resize(const int iMore);            //TODO make context sensitive
#endif

	// data (pointer to internal class)
/** @nodoc */
	CATSdaiGenericAggr  *   CATagg_;

  private:
#ifdef SDAI_MULTI_TRANS_BCC
	SdaiPrimitiveH RemoveMember(const SdaiIterInstance&amp; iIter, const SdaiBoolean&amp; calledByRMByPosition, SdaiRoot::ContextSensitivity iCtxt = SdaiRoot::CurrentTransactionContext);
#else
	const SdaiPrimitiveH&amp; RemoveMember(const SdaiIterInstance&amp; iIter, const SdaiBoolean&amp; calledByRMByPosition);
#endif

  public :
	/**
	 * @nodoc
	 */
  // Do not use this method. It is reserved for the exclusive use of SDMRuntime.
	virtual ostream&amp; OutPutAggr(ostream&amp; );

public:
  // forwards calls into CATSdaiGenericAggr
	/**
	 * @nodoc
	 */
  const SdaiBaseTypeH&amp;	Domain()  const;
	/**
	 * @nodoc
	 */
  // we cannot remove this method because it is used by the CATSdaiArrayBody.h macros.
  int Start_Index() const;
protected:
  CATSdaiAggrPrototype * GetSubAggrPrototype();
  void CopyOwningEntity(SdaiAggrInstance *newagg);
};

class CATListPtrSdaiPrimitiveH;

/** @nodoc */
void ExportedByKS0SIMPL SdaiAggrAddMembers(const CATListPtrSdaiPrimitiveH&amp; iList, SdaiAggrInstanceH iAggr);

#endif



</div>
    
    <div class="navigation">
        <div><a href="SdaiAggr.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SdaiAggr.h</a></div>
        <div><a href="SdaiAggrType.html">‰∏ã‰∏ÄÈ°µ: SdaiAggrType.h ‚Üí</a></div>
    </div>
</body>
</html>