<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KnowledgeInterfaces/PublicInterfaces/CATICkeParmFactory.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>KnowledgeInterfaces/PublicInterfaces/CATICkeParmFactory.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATICkeParm.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICkeParm.h</a></div>
        <div><a href="CATICkeRelation.html">‰∏ã‰∏ÄÈ°µ: CATICkeRelation.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATICkeParmFactory_H
#define CATICkeParmFactory_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/** 
 * @CAA2Level L1
 * @CAA2Usage U3
 */

// module declaration
#include &quot;KnowledgeItf.h&quot;
#include &quot;CATIVisitor.h&quot;
#include &quot;CATPathElement.h&quot;

// inherited from
#include &quot;CATBaseUnknown.h&quot;

// Forward declaration
#include &quot;CATICkeRelationForwards.h&quot;
class CATIContainer_var;
class CATIList_var;

// interfaces used 
//#include &quot;CATISpecObject.h&quot;
#include &quot;CATICkeMKSUnit.h&quot;
#include &quot;CATICkeMagnitude.h&quot;
#include &quot;CATIParmPublisher.h&quot;
#include &quot;CATIEnumere.h&quot;
#include &quot;CATIType.h&quot;


// OLE iid
#ifndef LOCAL_DEFINITION_FOR_IID
extern IID ExportedByKnowledgeItf IID_CATICkeParmFactory;
#else
extern &quot;C&quot; const IID IID_CATICkeParmFactory;
#endif


/**   
 * Interface dedicated to parameters and relations factory.
 * &lt;b&gt;Role&lt;/b&gt;: This interface helps you to create parameters and relations.&lt;br&gt;
 * WATCH OUT : &lt;br&gt;
 * Dont forget to Initialise Literals environnement on the&lt;br&gt; 
 * Literals.feat catalog before any kind of work with parameters&lt;br&gt;
 * This interface is implemented on any Feature containers: thus it creates persistant parameters and relations.&lt;br&gt;
 * It is also implemented on a volatile static object (CATCKEVolatileFactory): thus it creates volatile parameters.&lt;br&gt;
 *   &lt;br&gt;
 *     Usage :&lt;br&gt;
 * //////////////////////////////////////////////////////////////////////////&lt;br&gt;
 *&lt;br&gt;
 *      #include &quot;CATCke.h&quot;&lt;br&gt;
 *
 *      #include &quot;CATICkeUnit.h&quot;&lt;br&gt;
 *      #include &quot;CATICkeMKSUnit.h&quot;&lt;br&gt;
 *      #include &quot;CATICkeMagnitude.h&quot;&lt;br&gt;
 *      #include &quot;CATICkeParmFactory.h&quot;&lt;br&gt;
 *      #include &quot;CATICkeParm.h&quot;&lt;br&gt;
 *
 *      //------------------------------------------------&lt;br&gt;
 *      // Get this factory from your feat container&lt;br&gt;
 *      // to create features (persistent)  &lt;br&gt;
 *      //------------------------------------------------&lt;br&gt;
 *      CATICkeParmFactory_var fact = cont; &lt;br&gt;
 * &lt;br&gt;
 *      //------------------------------------------------&lt;br&gt;
 *      // Or use the Volatile factory&lt;br&gt;
 *      //------------------------------------------------&lt;br&gt;
 *      CATICkeParmFactory_var fact = CATCKEVolatileFactory; &lt;br&gt;
 *     &lt;br&gt;
 *      //------------------------------------------------&lt;br&gt;
 *      // you can create parameters&lt;br&gt;
 *      //------------------------------------------------&lt;br&gt;
 *      CATICkeParm_var p1 = fact-&gt;CreateLength (&quot;L&quot;,3.3);&lt;br&gt;
 *&lt;br&gt;
 * @see CATICkeMagnitude, CATICkeUnit, CATIEnumere, CATICkeParm, CATICkeRelation
 */


//-----------------------------------------------------------------------------
class ExportedByKnowledgeItf CATICkeParmFactory : public CATBaseUnknown
{

public:



/**
 * Initialise LiteralFeatures environnement.&lt;br&gt;
 * It finds all startups needed in this container.&lt;br&gt;
 * This method should be used on Literals.feat catalog container.
 */
virtual void InitStartUps () = 0;
  
/**
 * Please do not use it
 * @nodoc
 */
virtual void SetCurrent () = 0;



/**
 * Creates string parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value
 */
virtual CATICkeParm_var CreateString  (const CATUnicodeString &amp;iParameterName,
									   const CATUnicodeString &amp;iParameterValue) = 0;

/**
 * Creates integer parameter.
 * @param iParameterName  parameter name (never changed)
 * @param iParameterValue parameter value
 */
virtual CATICkeParm_var CreateInteger (const CATUnicodeString &amp;iParameterName,
									   const int iParameterValue) = 0;

/**
 * Creates boolean parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value
 */
virtual CATICkeParm_var CreateBoolean (const CATUnicodeString &amp;iParameterName,
									   const CATCke::Boolean iParameterValue) = 0;

/**
 * Creates real parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value
 */
virtual CATICkeParm_var CreateReal    (const CATUnicodeString &amp;iParameterName,
									   const double    iParameterValue) = 0;


/**
 * Creates length parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value in MKS !!! (i.e. meters)
 */
virtual CATICkeParm_var CreateLength  (const CATUnicodeString &amp;iParameterName,
									   const double    iParameterValue) = 0;

									   
/**
 * Creates angle parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value in MKS !!! (i.e. radian)
 */
virtual CATICkeParm_var CreateAngle   (const CATUnicodeString &amp;iParameterName,
									   const double    iParameterValue) =0;

/**
 * @nodoc Do not use it. Use CreateDimension (CATParmDictionary::FindMagnitude(&quot;TIME&quot;)) instead
 * Creates time parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value in MKS !!! (i.e. second)
 */
virtual CATICkeParm_var CreateTime   (const CATUnicodeString &amp;iParameterName,
									  const double    iParameterValue) =0;

/**
 * @nodoc Do not use it. Use CreateDimension (CATParmDictionary::FindMagnitude(&quot;MASS&quot;)) instead
 * Creates mass parameter.
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value in MKS !!! (i.e. gram)
 */
virtual CATICkeParm_var CreateMass   (const CATUnicodeString &amp;iParameterName,
									  const double    iParameterValue) =0;

/**
 * Creates dimension parameter.
 * @param iMagnitude parameters type
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value in MKS !!! 
 */
virtual CATICkeParm_var CreateDimension (const CATICkeMagnitude_var &amp;iMagnitude,
                                         const CATUnicodeString &amp;iParameterName,
                                         const double iParameterValue) =0;  // raises InvalidType

/**
 * Creates dimension parameter.
 * @param iMagnitude parameters type
 * @param iParameterName parameter name (never changed)
 * @param iParameterValue parameter value 
 */
virtual CATICkeParm_var CreateDimension (const CATICkeMagnitude_var &amp;iMagnitude,
                                         const CATUnicodeString &amp;iParameterName,
                                         const CATICkeInst_var &amp;iParameterValue) =0; // raises InvalidType, UnrecognisedUnit

/**
 * Creates an enumerated parameter from rank name (1 to n).
 * @param iEnumereType enumerated type 
 * @param iParameterName parameter name
 * @param iParameterRank parameter rank (from 1 to n)
 */
virtual CATICkeParm_var CreateEnumere (const CATIEnumere_var   &amp;iEnumereType,
                                       const CATUnicodeString  &amp;iParameterName,
                                       const int                iParameterRank) = 0; 
/**
 * Creates a literal from its type.
 * @param iParameterType parameter type
 * @param iParameterName parameter name
 */
virtual CATICkeParm_var CreateLiteral (const CATICkeType_var   &amp;iParameterType,
                                       const CATUnicodeString  &amp;iParameterName) = 0;
  


/**
 * Creates a MKS Unit equivalent to a scalar.
 */
virtual CATICkeMKSUnit_var   CreateMKSUnit () = 0;

/**
 * Creates a MKS Unit equivalent to a primitive magnitude.&lt;br&gt;
 * (example m2, s-1).
 * @param iBasicMagnitude primitive magnitude
 * @param iCoeff exponent
 * @return CATICkeMKSUnit_var  MKSUnit created
 */
virtual CATICkeMKSUnit_var   CreateMKSUnit (const CATICkeMKSUnit::Basic iBasicMagnitude,
											const int iCoeff) = 0;

/**
 * Creates a MKS Unit equivalent to a combination of primitive magnitude.&lt;br&gt;
 * (example kgxs-2)
 * @param iMeterCoeff exponent for length
 * @param iKilogramCoeff exponent for mass
 * @param iSecondCoeff exponent for time
 * @param iAmperCoeff exponent for amper
 * @param iTemperatureCoeff exponent for temperature
 * @param iCandelaCoeff exponent for candela
 * @param iMoleNumberCoeff exponent for mole number
 * @param iPriceCoeff exponent for price
 * @param iRadianCoeff exponent for radian
 * @param iSteradianCoeff exponent for steradian
 */
virtual CATICkeMKSUnit_var   CreateMKSUnit (const int iMeterCoeff,
                                            const int iKilogramCoeff,
                                            const int iSecondCoeff,
                                            const int iAmperCoeff,
                                            const int iTemperatureCoeff,
                                            const int iCandelaCoeff,
                                            const int iMoleNumberCoeff,
                                            const int iPriceCoeff,
                                            const int iRadianCoeff,
                                            const int iSteradianCoeff) = 0;
     



/**
 * @nodoc
 */
virtual CATICkeUnit_var      CreateUnit (const CATUnicodeString &amp;name,
                                         const CATUnicodeString &amp;symbol,
                                         const double factor) = 0;

/**
 * @nodoc
 */
virtual CATICkeMagnitude_var CreateMagnitude  (const CATUnicodeString &amp;name,
                                               const CATCkeListOfUnit lu,
                                               const CATICkeMKSUnit_var &amp;mks,
                                               const double epsilon=0) =0;


/**
 * @nodoc 
 * Creates an enumerated type (startup). Watch out. This should be used only to define Catalogs
 * @param iEnumName enum type name
 * @param iValues list of possible values
 */
virtual CATIEnumere_var CreateEnumereType (const CATUnicodeString &amp;iEnumName,
                                           const CATListOfCATUnicodeString &amp;iValues) = 0;
  

/**
 * Creates an enumerated parameter from value.
 * @param iEnumereType enumerated type 
 * @param iParameterName parameter name
 * @param iParameterValue parameter value
 */
virtual CATICkeParm_var CreateEnumere (const CATIEnumere_var &amp;iEnumereType,
                                       const CATUnicodeString          &amp;iParameterName,
                                       const CATUnicodeString          &amp;iParameterValue) = 0; 

 

/**
 * Creates a parm manipulator. This manipulator will not change the persistent parameters range.
 * This method is used to build a manipulator that will block temporarily the user manipulations.
 * In no case this manipulator will change the persistent bounds of the parameter.
 * If you want to persistently change the bounds of the parameter refer to the CATICkeParm interface.
 * &lt;br&gt;
 * Use only on Volatile Factory.
 */
virtual CATIParmManipulator_var  CreateParmManipulator () = 0;

/**
 * Create a formula between parameters (example : y=3*x).&lt;br&gt;
 * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised&lt;br&gt;
 * @param iRelationName formula&#x27;s name
 * @param iComment no more used for formula !!
 * @param iFamily not used !!
 * @param iOutputParameter valuated parameter (y in our example)
 * @param iListOfParameters  (pointer on list of CATBaseUnknown_var) contains literal used in inputs (x in our example)  
 * @param iBody contains the string describing the formula (&quot;3*x&quot; in our example)
 * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method&lt;br&gt; 
 * and so to be able to recognize parameters by their name &lt;br&gt;
 * Not used in realnames = false mode&lt;br&gt;
 * @param iRealnames  = 2 possibilities to name a parameter in the body.&lt;br&gt; 
 * &lt;tt&gt;CATCke::True&lt;/tt&gt;  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
 * &lt;tt&gt;CATCke::False&lt;/tt&gt; names used are a1,a2,a3,etc...&lt;br&gt;
 *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....&lt;br&gt;
 * We advise you strongly to use this second method in your application to avoid NLS problems .  &lt;br&gt;
 * &lt;br&gt;
 * @return Formula created or NULL_var if syntax error&lt;br&gt;
 */
virtual CATICkeRelation_var CreateFormula (const CATUnicodeString    &amp;iRelationName,
					     const CATUnicodeString    &amp;iComment,
					     const CATUnicodeString    &amp;iFamily,
					     const CATICkeParm_var     &amp;iOutputParameter,
					     const CATCkeListOfParm     iListOfParameters,
					     const CATUnicodeString    &amp;iBody,
					     const CATIParmPublisher_var &amp;iRoot = NULL_var,
					     const CATCke::Boolean     &amp;iRealnames = 1) = 0;

/**
 * Create a rule between parameters (example : if (x&gt; 3) y=3*x else y = 2).&lt;br&gt;
 * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised&lt;br&gt;
 * @param iRelationName  program&#x27;s name
 * @param iComment comment  !!
 * @param iFamily not used !!
 * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs or outputs (x and y  in our example)  
 * @param iBody contains the string describing the program (&quot;if (x&gt; 3) y=3*x else y = 2&quot; in our example)
 * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method &lt;br&gt;
 * and so to be able to recognize parameters by their name&lt;br&gt;
 * Not used in realnames = false mode&lt;br&gt;
 * @param iRealnames  = 2 possibilities to name a parameter in the body.&lt;br&gt; 
 * &lt;tt&gt;CATCke::True&lt;/tt&gt;  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
 * &lt;tt&gt;CATCke::False&lt;/tt&gt; names used are a1,a2,a3,etc...&lt;br&gt;
 *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....&lt;br&gt;
 * We advise you strongly to use this second method in your application to avoid NLS problems .  
 * &lt;br&gt; 
 * @return Rule created or NULL_var if syntax error
 */
virtual CATICkeRelation_var CreateProgram (const CATUnicodeString    &amp;iRelationName,
					     const CATUnicodeString    &amp;iComment,
					     const CATUnicodeString    &amp;iFamily,
					     const CATCkeListOfParm     iListOfParameters,
					     const CATUnicodeString    &amp;iBody,
					     const CATIParmPublisher_var &amp;iRoot = NULL_var,
					     const CATCke::Boolean     &amp;iRealnames = 1) = 0;

/**
 * Create a check between parameters (example : x &gt; 3).&lt;br&gt;
 * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised&lt;br&gt;
 * @param iRelationName program&#x27;s name
 * @param iComment comment
 * @param iFamily not used !!
 * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs (x and y  in our example)  
 * @param iBody contains the string describing the check (&quot;x&gt; 3&quot; in our example)
 * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method&lt;br&gt; 
 * and so to be able to recognize parameters by their name&lt;br&gt;
 * Not used in realnames = false mode&lt;br&gt;
 * @param iRealnames  = 2 possibilities to name a parameter in the body. &lt;br&gt;
 * &lt;tt&gt;CATCke::True&lt;/tt&gt;  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
 * &lt;tt&gt;CATCke::False&lt;/tt&gt; names used are a1,a2,a3,etc...&lt;br&gt;
 *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....&lt;br&gt;
 * We advise you strongly to use this second method in your application to avoid NLS problems .  
 * &lt;br&gt;
 * @return check created or NULL_var if syntax error
 */
virtual CATICkeRelation_var CreateCheck   (const CATUnicodeString     &amp;iRelationName,
					     const CATUnicodeString     &amp;iComment,
					     const CATUnicodeString     &amp;iFamily,
					     const CATCkeListOfParm    iListOfParameters,
					     const CATUnicodeString     &amp;iBody,
					     const CATIParmPublisher_var &amp;iRoot = NULL_var,
					     const CATCke::Boolean    &amp;iRealnames = 1) = 0;

/**
 * @nodoc
 * Create a simple relation between 2 parameters &#x27;y = ax+b&#x27;.
 * with x is first parameter, y is second one. This relation is synchronous &lt;br&gt;
 * 
 * @param iRelationName  relations name
 * @param iComment comment
 * @param iFamily not used !!
 * @param iX input literal
 * @param iY output literal
 * @param iA a
 * @param iB b
 * @return relation created
 */
virtual CATICkeRelation_var CreateSymetricalRelation (const CATUnicodeString &amp;iRelationName,
							const CATUnicodeString &amp;iComment,
							const CATUnicodeString &amp;iFamily,
							const CATICkeParm_var &amp;iX,
							const CATICkeParm_var &amp;iY,
							const double iA,
							const double iB) = 0;

/**
 * Creates a fully functional design table (with its embedded sheet) from a file (excel or text file).&lt;br&gt;
 * @Returns an handler on the new design table. if a problem occurs while creating it (bad file format), returns NULL_var 
 * @param iRelationName The name of the design table
 * @param iComment The comment associated to the design table
 * @param iFilePath
 *	The path of the sheet file.
 *	- If param sheetWithoutFile = 0 :
 *			if this path contains &quot;.xls&quot;, the Excel format is assumed, else the tabulated text format is used.
 *			If this path is empty, no sheet is aggregated to the design table, and the user has to create a sheet 
 *			(method CreateSheet) and associate it to an excel or text file)
 *	- If param sheetWithoutFile = 1 :
 *			no matter with the content of this path
 * @param orientation
 *  1 if vertical, 0 else (used only if path != &quot;&quot; and sheetWithoutFile = 0)
 * @param sheetWithoutFile
 *	If sheetWithoutFile = 1, a model sheet is created (sheet with persitent memory storage, but no file)
 *	and it won&#x27;t be possible to associate a file to this sheet.
*/
   virtual CATIDesignTable_var CreateDesignTable(const CATUnicodeString     &amp;iRelationName,
	   const CATUnicodeString &amp;iComment,
	   const CATUnicodeString &amp;iFilePath,
	   int orientation = 1,
	   int sheetWithoutFile = 0 ) = 0;


/**
 * Create a design table sheet. 
 * @param iFilePath The path of the source file. It can be an Excel or a Lotus sheet
 * or a tabulated text file, or an empty path (if iType != 4, you&#x27;ll have to call 
 * CreateSourceFile on CATICkeSheet interface).
 * If the path isn&#x27;t empty and the type is different from 4, and the file doesn&#x27;t exist,
 * the file is created.
 * @param iType
 * - if iType = 4, whatever the content of the path, a model sheet 
 *   is created (sheet with persitent memory storage, but no file) 
 * - if path is empty, uses the type to know what kind of sheet has to be created
 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: the test can be either
 *   &lt;tt&gt;1&lt;/tt&gt; Excel one.
 *   &lt;tt&gt;2&lt;/tt&gt; Text one
 *   &lt;tt&gt;3&lt;/tt&gt; Lotus one
 *   &lt;tt&gt;4&lt;/tt&gt; Model one
 * @return
 * the created sheet. It returns NULL_var if the file creation failed (in the case where the file has to be created) or if Excel or Lotus is asked on UNIX
 */
virtual CATICkeSheet_var CreateSheet(const CATUnicodeString &amp;iFilePath,int iType = 0) = 0;


/**
 * Creates feature reference.&lt;br&gt;
 * A feature reference is a way to see a feature as a parameter,&lt;br&gt;
 * Such a feature reference can only be used in input of Knowledgeware relations.&lt;br&gt;
 * @param iFeature feature to be referenced : should implement CATICkeFeature.
 * @return CATICkeParm_var feature reference created
 */
virtual CATICkeParm_var CreateObjectReference  (const CATBaseUnknown_var &amp;iFeature) = 0;




/**
 * Initialise Literals Catalog and wakes up all relations.&lt;br&gt;
 * Should be done when creating a new container or loading it.&lt;br&gt;
 * This method replaces InitStartups. It loads the Literals.feat catalog and does InitStartups on it.&lt;br&gt;
 * This should be used on the feature container where relations have been stored.&lt;br&gt;
 */
    virtual void InitAndWakeUp () = 0;
  

/**
 * @nodoc
 */
	virtual CATICkeParm_var CreateObjectReference  (const CATICkeType_var &amp;t,const CATUnicodeString &amp;name ) = 0;

/**
 * @nodoc
 */
	virtual CATICkeParm_var CreateRelativeParameter(const CATUnicodeString&amp; iRelativePath) = 0;

/**
 * @nodoc
 * Creates an imported parameter. These parameter are created when pasting as 
 * result with link, when creating a formula in context, or between parameters 
 * of different documents.
 */
	virtual CATICkeParm_var CreateImportedParameter(const CATICkeParm_var&amp; iReference, int withLink = 1, int refref = 0) = 0;



/**
 * Creates a literal from another by copying its value.
 * Note that at the end, the parameter is not aggregated.
 * One option is to copy the existing formula that valuates the literal if any,&lt;br&gt;
 * The formula is also not aggregated. It will reference the same input parameters as the original formula.
 * @param iParameterToCopy parameter to copy
 * @param iWithFormula indicates if we wish to copy the formula (note that the formula copied won&#x27;t be agregated to anything).
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 
 * &lt;tt&gt;0&lt;/tt&gt; No copy of the formula.
 * &lt;tt&gt;1&lt;/tt&gt; Copy of the formula.
 * @return CATICkeParm_var : literal copied
 */
virtual CATICkeParm_var Copy (const CATICkeParm_var     &amp;iParameterToCopy,
					          const CATCke::Boolean     &amp;iWithFormula = 0) = 0 ;


/**
 * Creates a relation from another by copying it.
 * Works on formula only
 * Note that second relation will reference the same parameters, so il will be deactivated.
 * The copied relation is not aggregated.
 * @param iRelationToCopy parameter to copy
 * @return CATICkeRelation_var relation copied
 */
virtual CATICkeRelation_var Copy (const CATICkeRelation_var     &amp;iRelationToCopy) = 0 ;


/**
 * Create an optimization constraint (example : x + y &gt; 3).
 * 
 * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised&lt;br&gt;
 * 
 * @param iRelationName program&#x27;s name
 * @param iComment comment
 * @param iFamily not used !!
 * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs (x and y  in our example)
 * @param iBody contains the string describing the constraint (&quot;x&gt; 3&quot; in our example)
 * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method 
 * and so to be able to recognize parameters by their name &lt;br&gt;
 * Not used in realnames = false mode
 * @param iRealnames 2 possibilities to name a parameter in the body. &lt;br&gt;
 * &lt;tt&gt;CATCke::True&lt;/tt&gt;  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
 * &lt;tt&gt;CATCke::False&lt;/tt&gt; names used are a1,a2,a3,etc...&lt;br&gt;
 *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....&lt;br&gt;
 * We advise you strongly to use this second method in your application to avoid NLS problems .  
 * 
 * @return = constraint created or NULL_var if syntax error
 */
virtual CATICkeRelation_var CreateOptimizationConstraint   (const CATUnicodeString     &amp;iRelationName,
										        const CATUnicodeString     &amp;iComment,
												double iPrecision,
												int iPriority,
					                            const CATCkeListOfParm    iListOfParameters,
					                            const CATUnicodeString     &amp;iBody,
					                            const CATIParmPublisher_var &amp;iRoot = NULL_var,
					                            const CATCke::Boolean    &amp;iRealnames = 1) = 0;

/**
 * Create a law between parameters and formal parameters (example : y = sin(x) + Real.1).&lt;br&gt;
 * if a syntax error occurs, NULL_var is returned and a CATCkeParseException exception is raised&lt;br&gt;
 * @param iRelationName  program&#x27;s name
 * @param iComment comment  !!
 * @param iFamily not used !!
 * @param iListOfParameters (pointer on list of CATBaseUnknown_var) contains literal used in inputs or outputs (Real.1 in our example)  
 * @param iListOfFormalParameters (pointer on list of CATBaseUnknown_var) contains formal literal used in inputs or outputs (x and y  in our example)  
 * @param iBody contains the string describing the program (&quot;y = sin(x) + Real.1&quot; in our example)
 * @param iRoot (CATIParmPublisher) used to name parameters with RelativeName (root) method &lt;br&gt;
 * and so to be able to recognize parameters by their name&lt;br&gt;
 * Not used in realnames = false mode&lt;br&gt;
 * @param iRealnames  = 2 possibilities to name a parameter in the body.&lt;br&gt; 
 * &lt;tt&gt;CATCke::True&lt;/tt&gt;  names used are the one returned by RelativeName (root) and we try to recognize names used in the body with parameters of iListParameters..
 * &lt;tt&gt;CATCke::False&lt;/tt&gt; names used are a1,a2,a3,etc...&lt;br&gt;
 *                        a1 meaning the first parameter of iListParameters, a2, the second one, etc....&lt;br&gt;
 * We advise you strongly to use this second method in your application to avoid NLS problems .  
 * &lt;br&gt; 
 * @return Rule created or NULL_var if syntax error
 */
virtual CATICkeRelation_var CreateLaw (const CATUnicodeString    &amp;iRelationName,
					     const CATUnicodeString    &amp;iComment,
					     const CATUnicodeString    &amp;iFamily,
					     const CATCkeListOfParm     iListOfParameters,
					     const CATCkeListOfParm     iListOfFormalParameters,
					     const CATUnicodeString    &amp;iBody,
					     const CATIParmPublisher_var &amp;iRoot = NULL_var,
					     const CATCke::Boolean     &amp;iRealnames = 1) = 0;


/**
* @nodoc
*/
virtual void InitFactory() = 0;


/**
 * @nodoc
 */
virtual CATICkeParm_var CreateTechnicalParameter  (const CATICkeType_var &amp;t,const CATUnicodeString &amp;name ,const CATUnicodeString &amp; iTechnicalPath, const CATICkeParm_var&amp; iFinalParameter) = 0;
/**
 * @nodoc
 */
virtual CATISpecObject_var CreateDeletedFeature  (const CATIType_var &amp;t,const CATUnicodeString &amp;name ) = 0;

/**
 * Creates a List object.&lt;br&gt;
 * @param iName name of the list.
 */
virtual CATIList_var   CreateList (const CATUnicodeString &amp;iName) = 0;
     
/**
* Creates a standard visitor to perform visit via CATIParmPublisher::VisitChildren.&lt;br&gt; 
* When calling CATIParmPublisher::VisitChildren with this visitor, it &lt;br&gt;
* adds visited instances in the list if they implement the interface which clsid is iVisitclsid
*
*   For example:
*
* In order to retrieve the parameters use CATICkeParm as interface identifier.
* To retrieve the instances use CATIInstance as interface identifier. 
* 
* @param iVisitclsid the interface identifier.
* @param ioListToFill the list to be filled by the visitor.
*
* CAUTION: the returned visitor must be deleted before the list you give in input, because it keeps
* a reference to the list.
*
*/
virtual CATIVisitor_var CreateStandardVisitor(const GUID&amp; iVisitclsid, const CATLISTV(CATBaseUnknown_var) *ioListToFill) = 0;

	/**
 * @nodoc
 * Creates an imported parameter. These parameter are created when pasting as 
 * result with link, when creating a formula in context, or between parameters 
 * of different documents.
 */
	virtual CATICkeParm_var CreateImport(CATPathElement* selected_element, CATPathElement* object_in_work = NULL) = 0 ; 

private :  

  // 2 define ClassName
  CATDeclareInterface;

};


CATDeclareHandler(CATICkeParmFactory,CATBaseUnknown);


#endif

</div>
    
    <div class="navigation">
        <div><a href="CATICkeParm.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICkeParm.h</a></div>
        <div><a href="CATICkeRelation.html">‰∏ã‰∏ÄÈ°µ: CATICkeRelation.h ‚Üí</a></div>
    </div>
</body>
</html>