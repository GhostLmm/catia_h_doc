<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GMOperatorsInterfaces/PublicInterfaces/CATICGMTopCorner.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GMOperatorsInterfaces/PublicInterfaces/CATICGMTopCorner.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATICGMTopCompatible.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICGMTopCompatible.h</a></div>
        <div><a href="CATICGMTopCrvToNurbsCrvOperator.html">‰∏ã‰∏ÄÈ°µ: CATICGMTopCrvToNurbsCrvOperator.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATICGMTopCorner_h_
#define CATICGMTopCorner_h_

// COPYRIGHT DASSAULT SYSTEMES 2006

/**
 * @CAA2Level L1
 * @CAA2Usage U1
*/

#include &quot;CATGMOperatorsInterfaces.h&quot;
#include &quot;CATICGMTopTangentCurveOperator.h&quot;

class CATBody;
class CATMathDirection;
class CATMathPoint;
class CATWire;
class CATTopData;

extern ExportedByCATGMOperatorsInterfaces IID IID_CATICGMTopCorner;

/**
* Class representing the operator that computes a round corner between two wire bodies.
* &lt;br&gt;There is no unique solution to the corner computation: the input wires
* cut the corner in two portions. These two portions can be retrieved together, or one can choose
* the portion to keep (&lt;tt&gt;CATCircleMode&lt;/tt&gt;).
* Moreover, when choosing  the &lt;tt&gt;Direct&lt;/tt&gt; or &lt;tt&gt;Complementary&lt;/tt&gt; modes, the operator
* can assemble the computed corner
* on the input wires on demand (&lt;tt&gt;SetSupportTrimmingMode&lt;/tt&gt;).
* &lt;br&gt;The center of the corner is defined at the intersection of the parallels
* to the input wires. Once given a wire on a shell, there are two parallel
* to a wire: one on each side. The side defines the orientation of the
* parallel:
* &lt;ul&gt;
* &lt;li&gt;The cross product of the normal to the shell and the tangent to the wire is positive
* side (+1)
* &lt;li&gt;The opposite of the cross product of the normal to the shell and the tangent 
* to the wire is the negative side (-1).
* &lt;/ul&gt; 
* &lt;br&gt;The CATICGMTopCorner operator satisfies the smart mechanism: the
* input bodies are not modified. A new resulting body is created, 
* possibly sharing data with the input bodies.
* It follows the global frame of the topological operators, except that it can return several 
* bodies, corresponding to the multiple solution it found.
*&lt;ul&gt;
* &lt;li&gt;A CATICGMTopCorner operator is created with the &lt;tt&gt;CATCGMCreateTopCorner&lt;/tt&gt; global method.
* It must be directly released with the &lt;tt&gt;Release&lt;/tt&gt; method after use. It is not streamable. 
*&lt;li&gt;Options can be precised with the &lt;tt&gt;SetXxx&lt;/tt&gt; methods, before
* asking for the computation with the &lt;tt&gt;Run&lt;/tt&gt; method. 
*&lt;li&gt;The result is accessed with 
* &lt;ul&gt;&lt;li&gt;the &lt;tt&gt;GetResult&lt;/tt&gt; method: all the computed corners are put in the same resulting body.
*     &lt;li&gt;the iterator on the solutions (&lt;tt&gt;BeginningCorner&lt;/tt&gt;, &lt;tt&gt;NextCorner&lt;/tt&gt;, &lt;tt&gt;GetCorner&lt;/tt&gt;):
* each solution corner is put in a different body.
* &lt;/ul&gt; 
* If you do not want 
* to keep the resulting bodies, use the @href CATICGMContainer#Remove method to remove them from the 
* geometric factory, after the operator deletion.
*&lt;/ul&gt;
*/
class ExportedByCATGMOperatorsInterfaces CATICGMTopCorner: public CATICGMTopTangentCurveOperator
{
public:
  /**
   * Constructor
   */
  CATICGMTopCorner();

  /**
	* Runs &lt;tt&gt;this&lt;/tt&gt; operator.
	*/
  virtual int Run() = 0;

  /**
	* Returns the number of computed corners.
	* @return
	* The number of corners.
	*/
  virtual CATLONG32 GetNumberOfCorners() const = 0;

  /**
	* Initializes the iterator of the resulting corners.
	*/
  virtual void BeginningCorner() = 0;

  /**
	* Skips to the next solution corner of &lt;tt&gt;this&lt;/tt&gt; CATICGMTopCorner operator.
	*&lt;br&gt;After &lt;tt&gt;BeginningCorner&lt;/tt&gt;, it skips to the first solution. 
	* @return
	* The existence of the next solution.
	* &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
	* &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt; &lt;dd&gt;if there is a solution
	*    &lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt; &lt;dd&gt;no more solution.&lt;/dl&gt;
	*/
  virtual CATBoolean NextCorner() = 0;

  // This method returns 
  //    a one-domain body if the geometric solution is full in face 
  //    a multi-domain if not
  /**
	* Creates the current corner.
	* @param iCurrentJournal
	* The pointer to the journal corresponding to the creation of the current corner.
	* If &lt;tt&gt;NULL&lt;/tt&gt;, the journal is not written.
	* @return
	* The pointer to the created body. If you do not want to keep it,
	* use the @CATICGMContainer#Remove method to remove it from the geometric factory, after the deletion
	* of &lt;tt&gt;this&lt;/tt&gt; operator.
    */
  virtual CATBody *GetCorner(CATCGMJournalList *iCurrentJournal = NULL) = 0;

  /**
	* Retrieves the orientation of the parallels used to compute the center
	* of the corner.
	* @param ioOr1
	* The orientation of the parallel to the first wire.
	* @param ioOr2
	* The orientation of the parallel to the second wire.
	* @param ioOr3
	* The orientation of the parallel to the third wire, only in case of
	* tritangent corner.
	*/
  virtual void GetCurOrients(
    CATOrientation &amp;ioOr1,
    CATOrientation &amp;ioOr2,
    CATOrientation &amp;ioOr3) const = 0;

  /**
	* Returns the definition of the current corner.
	* &lt;br&gt;To be called after the &lt;tt&gt;GetCorner&lt;/tt&gt; method.
	* @param ioCenter
	* The center of the current corner.
	* @param ioRadius
	* The radius value of the current corner.
	*/
  virtual void GetCenterRadius(CATMathPoint &amp;ioCenter, double &amp;ioRadius) = 0;

  /**
 * Defines the orientations to take for the parallels to the input wires.
 * @param iOrientCrv1
 * The orientation of the parallel to the first wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed.
 * @param iOrientCrv2
 * The orientation of the parallel to the second wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed.
 * @param iOrientCrv3
 * The orientation of the parallel to the third wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed. In case of tritangent corner only.
 */
  virtual void SetOffsetOrientation(
    int iOrientCrv1,
    int iOrientCrv2,
    int iOrientCrv3 = 0) = 0;

  /**
 * Retrieves the defined orientations to take for the parallels to the input wires.
 * @param ioOrientCrv1
 * The orientation of the parallel to the first wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed.
 * @param ioOrientCrv2
 * The orientation of the parallel to the second wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed.
 * @param ioOrientCrv3
 * The orientation of the parallel to the third wire. If &lt;tt&gt;0&lt;/tt&gt;, 
 * the two sides parallels are computed. In case of tritangent corner only.
	*/
  virtual void GetOffsetOrientation(
    int &amp;ioOrientCrv1,
    int &amp;ioOrientCrv2,
    int &amp;ioOrientCrv3) const = 0;

  /**
	* Returns all the computed corners in a single body.
	* &lt;br&gt;In this case, &lt;tt&gt;GetNumberOfCorners&lt;/tt&gt; and &lt;tt&gt;GetResult()-&gt;GetNumberOfDomain()&lt;/tt&gt; can be different.
	* @return
	* The pointer to the resulting body. If you do not want to keep it, use the @href CATICGMContainer#Remove method
	* to remove it from the geometric factory after the &lt;tt&gt;delet&lt;/tt&gt;ion&lt;/tt&gt; of &lt;tt&gt;this&lt;/tt&gt; operator.
	*/
  virtual CATBody *GetResult() = 0;

  /**
  * Defines whether the input wires can be assembled in the resulting body, and how they can be assembled.
  * @param iTrimmingSide
  * The assembly side
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 
  * &lt;tt&gt;0&lt;/tt&gt; if the assembly can be done for all input wires,
  * &lt;tt&gt;1&lt;/tt&gt; if the assembly can be done just for the first input wire,
  * &lt;tt&gt;2&lt;/tt&gt; if the assembly can be done just for the last input wire.
  * @param iTrimmingMode
  * The assembly mode.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;tt&gt;1&lt;/tt&gt; if the assembly must be done, &lt;tt&gt;0&lt;/tt&gt; otherwise.
  * @return
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;tt&gt;1&lt;/tt&gt; if the assembly must be done, &lt;tt&gt;0&lt;/tt&gt; otherwise.
  * In this last case, &lt;tt&gt;CATCircleMode&lt;/tt&gt; must changed to &lt;tt&gt;Direct&lt;/tt&gt;.
  */
  virtual CATLONG32 SetSupportTrimmingSideAndMode(
    const CATLONG32 iTrimmingSide,
    const CATLONG32 iTrimmingMode) = 0;

  /**
  * Returns whether the input wires can be assembled in the resulting body, and how they can be assembled.
  * In this case, the iterator cannot be used.
  * @param oTrimmingSide
  * The assembly side.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;tt&gt;0&lt;/tt&gt; if the assembly can be done for all input wires,
  * &lt;tt&gt;1&lt;/tt&gt; if the assembly can be done just for the first input wire,
  * &lt;tt&gt;2&lt;/tt&gt; if the assembly can be done just for the last input wire.
  * @param oTrimmingMode
  * The assembly mode.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;tt&gt;1&lt;/tt&gt; if the assembly must be done, &lt;tt&gt;0&lt;/tt&gt; otherwise.
  * @return
  * &lt;tt&gt;0&lt;/tt&gt; if the assembly is compatible with the relimitation mode, &lt;tt&gt;1&lt;/tt&gt; otherwise. 
  */
  virtual CATLONG32 GetSupportTrimmingSideAndMode(
    CATLONG32 &amp;oTrimmingSide,
    CATLONG32 &amp;oTrimmingMode) = 0;

  /**
	* Defines the relimition mode of &lt;tt&gt;this&lt;/tt&gt; corner operator.
	* @param iCircleMode
	* The relimitation mode of the corner. Do not use the &lt;tt&gt;Angular&lt;/tt&gt;
	* value.
	* @param iStart
	* Not to be used.
	* @param iEnd
	* Not to be used.
	* @return
	* &lt;tt&gt;0&lt;/tt&gt; if the relimitation mode is compatible with the assembly mode, &lt;tt&gt;1&lt;/tt&gt; otherwise.
	* In this last case, the &lt;tt&gt;Direct&lt;/tt&gt; mode must be set.
	*/
  virtual CATLONG32 SetCircleMode(
    CATCircleMode iCircleMode,
    double iStart = 0.0,
    double iEnd = 0.0) = 0;

  /**
	* Retrieves the relimitation mode of &lt;tt&gt;this&lt;/tt&gt; corner operator.
	* @param ioCircleMode
	* The relimitation mode.
	* @param ioStart
	* The value is not touched.
	* @param ioEnd
	* The value is not touched.
	*/
  virtual void GetCircleMode(
    CATCircleMode &amp;ioCircleMode,
    double &amp;ioStart,
    double &amp;ioEnd) = 0;

#ifdef CATIACGMR217CAA
  /**
	* Set the direction .
  * To be used only in case of 3D corner definition (by default a direction will be automatically calculated)
	* @param iDirectionFor3DCorner
	* This is the direction of the cylinder which will be the support of the 3D corner.
	*/
  virtual void SetDirection(const CATMathDirection &amp;iDirectionFor3DCorner) = 0;

  /**
	* Get the direction.
  * To be used only in case of 3D corner definition (by default a direction will be automatically calculated)
	* @param oDirectionFor3DCorner
	* The computed direction.
	* @param oAutomaticModeForDirection
  * Returns whether the direction has been computed.
	*/
  virtual void GetDirection(
    CATMathDirection &amp;oDirectionFor3DCorner,
    CATBoolean &amp;oAutomaticModeForDirection) = 0;
#endif

protected:
  /**
   * Destructor
   */
  virtual ~CATICGMTopCorner(); // -&gt; delete can&#x27;t be called
};

/**
* Creates a CATICGMTopCorner operator that computes a rounded corner between two wires lying
* on a shell domain.
* &lt;br&gt;&lt;b&gt;Orientation&lt;/b&gt;: The resulting wire is oriented from the first input wire
* to the second one for open corner. On the other hand,
* a complete corner is oriented in the direct sense with regards to the shell orientation.&lt;br&gt;
* &lt;br&gt;&lt;b&gt;Journal&lt;/b&gt;: The corner edge is written as created.
* @param iFactory
* The pointer to the factory of the resulting body.
* @param iData
* The pointer to the data defining the software configuration and the journal. If the journal inside &lt;tt&gt;iData&lt;/tt&gt; 
* is &lt;tt&gt;NULL&lt;/tt&gt;, it is not filled.
* @param iCurve1
* The pointer to the body defining the first wire. 
* @param iCurve2
* The pointer to the body defining the second wire.
* @param iSupport
* The pointer to the body defining the common support of the two input wires.
* @param iRadius
* The radius of the rounded corner.
* @return [out, IUnknown#Release]
* The pointer to the created operator. To be released with the &lt;tt&gt;Release&lt;/tt&gt; method after use.
*/
ExportedByCATGMOperatorsInterfaces CATICGMTopCorner *CATCGMCreateTopCorner(
  CATGeoFactory *iFactory,
  CATTopData *iTopData,
  CATBody *iCurve1,
  CATBody *iCurve2,
  CATBody *iSupport,
  double iRadius);

#endif /* CATICGMTopCorner_h_ */
</div>
    
    <div class="navigation">
        <div><a href="CATICGMTopCompatible.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICGMTopCompatible.h</a></div>
        <div><a href="CATICGMTopCrvToNurbsCrvOperator.html">‰∏ã‰∏ÄÈ°µ: CATICGMTopCrvToNurbsCrvOperator.h ‚Üí</a></div>
    </div>
</body>
</html>