<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GMOperatorsInterfaces/PublicInterfaces/CATICGMFrFTopologicalSweep.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GMOperatorsInterfaces/PublicInterfaces/CATICGMFrFTopologicalSweep.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATICGMFrFSmoothingOper.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICGMFrFSmoothingOper.h</a></div>
        <div><a href="CATICGMGeoToTopOperator.html">‰∏ã‰∏ÄÈ°µ: CATICGMGeoToTopOperator.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATICGMFrFTopologicalSweep_h_
#define CATICGMFrFTopologicalSweep_h_

// COPYRIGHT DASSAULT SYSTEMES 2006

/**
 * @CAA2Level L1
 * @CAA2Usage U3
*/

#include &quot;CATIACGMLevel.h&quot;
#include &quot;CATGMOperatorsInterfaces.h&quot;
#include &quot;CATICGMTopOperator.h&quot;
#include &quot;CATFrFTopologicalSweepDef.h&quot;
#include &quot;CATDataType.h&quot;

class CATBody;
class CATCompositeLaw;
class CATFrFMovingFrame;
class CATFrFSweepChecker;
class CATGeometry;
class CATLaw;
class CATMathAxis;
class CATMathDirection;
class CATSectionSolverEngine;
class CATSoftwareConfiguration;
class CATSweep;
class CATMathPoint;
class CATLISTP(CATCurve);
class CATLISTP(CATVertex);
class CATLISTP(CATGeometry);

extern ExportedByCATGMOperatorsInterfaces IID IID_CATICGMFrFTopologicalSweep;

/**
 * Class representing the topological operator that computes swept surfaces.
 * &lt;br&gt;A sweep operation is defined by:
 * &lt;ul&gt;&lt;li&gt; One or several guides that are along the sweeping direction.
 * &lt;li&gt;One profile that is swept, or several profiles thru which the swept surface passes. 
 * In case of segment or circle profile, the profile is implicitely given.
 * &lt;li&gt;Optionally a spine curve, that defines the sweeping plane (also called moving frame @href CATMovingFrameType ).
 * &lt;/ul&gt;
 * This operator can create, according to the chosen options:
 * &lt;ul&gt;
 * &lt;li&gt; Unspec sweep: one profile, one guide
 * &lt;li&gt; BiRail sweep: one profile, two guides
 * &lt;li&gt; Segment sweep: Define:
 * &lt;ul&gt;&lt;li&gt;A1, A2: Angle Laws
 * &lt;li&gt;R: Radius Law
 * &lt;li&gt;LG, MG, FG: Limit, Middle, Functional Guide
 * &lt;li&gt;R1, R2: Length Laws
 * &lt;li&gt;LS, MS, FS: Limit, Middle, Functional Surface
 *&lt;/ul&gt;
 * The following describes the needed inputs for each case: 
 * &lt;pre&gt; 
 *          R2         R1
 * Case 1: &lt;--*-----*-----&gt;   2 Limit Guides L1 and L2
 * ------     L2    L1        2 Length Laws  (giving values R1 and R2)
 *
 *
 *           R2  LG  R1
 * Case 2:  &lt;-----*-----&gt;      1 Limit Guide LG + 1 Functional Guide FG
 * ------        A \           2 Length Laws R1 and R2 + 1 Angle Law A
 *                  *FG
 *
 *
 * Case 3:   LG    MG
 * ------     *-----*-----      1 Limit Guide LG + 1 Middle Guide MG
 *
 *
 *           R2  LG  R1
 * Case 4:  &lt;-----*-----&gt;      1 Limit Guide LG (PCurve)
 * ------       |---|S         2 Length Laws R1 and R2 +
 *                A            1 Angle Law A (% Surface Reference)
 *
 * &lt;/pre&gt;
 * &lt;li&gt;Circle sweep: For the same notations as those for the segment sweep, 
 * &lt;pre&gt;
 * Case 1: *-----*-----*     3 Limit Guides L1 L2 and L3
 * ------  L1    L2    L3    No Laws
 *
 *
 *
 * Case 2:  *----------*      2 Limit Guides L1 and L2
 * ------   L1    \    L2     1 Radius Law R
 *                 R
 *
 *
 * Case 3:   F*
 * ------     |A1 *
 *            |  / o           1 Middle Guide + 1 Functional Guide
 *            | /A2 o          2 Angular Laws A1 and A2
 *           M*------*
 *
 *
 * Case 4:       ---           1 Middle Guide
 * ------      | R|  |         1 Radius Law R
 *            |   *   |
 *             |     |
 *               ---
 *
 *
 *           A1  MG  A2
 * Case 5:  &lt;-----*-----&gt;      1 Middle Guide MG
 * ------       |---|S         2 Angle Laws A1 and A2 (% Surface Reference)
 *                R            1 Radius Law
 *
 *     
 *             o
 *        L1 o   o        
 * Case 6:  *     * L2        2 Limit Guides L1 and L2
 * ------  ! o   o             1 Reference Surface
 *         !   o   
 *         !
 *         ! Reference Surface 
 *
 * &lt;/pre&gt;
 * &lt;li&gt;Conic sweep: For the same notations as those for the segment or circle 
 * sweep, 
 * &lt;pre&gt;
 * Case 1:                     5 Limit Guides
 * ------ 
 *  L1   
 *   *
 *    o
 *     o
 *       * L2
 *          o    
 *             o  L3 
 *                *   
 *                   o   L4      L5
 *                       *  o  o  *
 *
 * Case 2:                     4 Limit Guides L1 to L5
 * ------                      1 Slope (angle law % reference surface)
 *
 *  L1   
 *   *
 *    o
 *     o
 *       * L2
 *         o
 *            o  L3 
 *               *
 *                   o                    
 *                        o             L4
 *                               o   o  *----------------------- slope 
 *                                 -    angle
 *                                   -
 *                                     -
 *                                       - reference surface
 *                      
 * Case 3:                     3 Limit Guides
 * ------                      2 Slopes (angle law % reference surface)
 *                      
 *  L1   
 *  !*
 *  ! o
 *  !  o
 *  !    o
 *  !       o    
 *  !          o  L2 
 *  !             *   
 *  !                o 
 *  !                     o         L3
 *  o                            o  *----------------------- slope 
 *  slope                          -    angle
 * (angle + reference)               -
 *                                     -
 *                                       - reference surface
 *                      
 * Case 4:                     2 Limit Guides
 * ------                      2 Slopes (angle law % reference surface)
 *                             1 Rho Law
 *  L1   
 *  !*
 *  ! o
 *  !  o
 *  !    o
 *  !       o    
 *  !          o  
 *  !             o              L2  
 *  !                 o   o  o  o  *----------------------- slope 
 *  slope                          -    angle
 * (angle + reference)               -
 *                                     -
 *                                       - reference surface
 *                      
 * &lt;/pre&gt;
 *&lt;/ul&gt;
 *&lt;br&gt;
 * The CATICGMFrFTopologicalSweep operator follows the global frame of the topological operators 
 * and satisfies the smart mechanism: 
 * the input bodies are not modified. A new resulting body is created, 
 * possibly sharing data with the input bodies.
 *&lt;ul&gt;
 * &lt;li&gt;A CATICGMFrFTopologicalSweep operator is created with the &lt;tt&gt;CATCGMCreateFrFTopologicalSweep&lt;/tt&gt; global method:
 * It must be directly released with the &lt;tt&gt;Release&lt;/tt&gt; method after use. It is not streamable. 
 *&lt;li&gt;In case of &lt;tt&gt;BASIC&lt;/tt&gt;
 * mode, the operation is automatically performed at the operator creation. 
 * In case of &lt;tt&gt;ADVANCED&lt;/tt&gt;
 * mode, options can be precised with the &lt;tt&gt;SetXxx&lt;/tt&gt; methods, before
 * asking for the computation with the &lt;tt&gt;Run&lt;/tt&gt; method.  
 *&lt;li&gt;In both cases, the result is accessed with the &lt;tt&gt;GetResult&lt;/tt&gt; method. If you do not want 
 * to keep the resulting body, use the @href CATICGMContainer#Remove method to remove it from the 
 * geometric factory.
 *&lt;/ul&gt; 
 */
class ExportedByCATGMOperatorsInterfaces CATICGMFrFTopologicalSweep: public CATICGMTopOperator
{
public:
  /**
   * Constructor
   */
                   CATICGMFrFTopologicalSweep             ();

  /**
 * Upgrade default operator settings.
 * (for historical and compatibility reasons old fashioned default settings are still active without this call).
 * Must be called immediatly after operator creation.
 * Level 1 default setting changes:
 * &lt;ul&gt;
 * &lt;li&gt;Twist detection is activated.
 * &lt;li&gt;Wrap detection is activated.
 * &lt;li&gt;All angles are defined in degree including in circular sweep case.
 * &lt;li&gt;In case of profile or guide support, internal laydown will be done.
 * &lt;/ul&gt;
 * @param iSettingsLevel
 * the default settings level (if 0, always set the operator to the best so far default settings)
 */
  virtual void     SetUpgradedDefaultSettings             (int                           iSettingsLevel            = 0) = 0;

  /**
 * Explicit downgrade query for one upgraded setting.
 * (must be done between SetUpgradedDefaultSettings() and other specifications definition).
 * @param iSettingDowngrade
 * setting downgrade query
 */
  virtual void     SetDowngradeSetting                    (CATFrFTopologicalDowngradeSetting_Type
                                                                                         iSettingDowngrade         )    = 0;

  /**
 * Runs &lt;tt&gt;this&lt;/tt&gt; operator.
 */
  virtual int      Run                                    ()                                                            = 0;

  /**
 * Returns the result of &lt;tt&gt;this&lt;/tt&gt; operator.
 * @return
 * The pointer to the created body. You must delete it with the @href CATICGMContainer#Remove 
 * method if you do not want to keep it. 
 */
  virtual CATBody* GetResult                              ()                                                            = 0 ;

  /**
 * Defines the spine.
 * @param iSpine
 * The pointer to the CATCurve or the wire body defining the spine. For a multi profiles sweep,
 * if &lt;tt&gt;iSpine=NULL&lt;/tt&gt; and if
 * &lt;tt&gt;iSpineType=CATFrFTopologicalSweepSpine_Implicit&lt;/tt&gt;, the spine is automatically computed
 * using the input profiles.
 * @param iSpineType
 * The spine type.
 */
  virtual void     SetSpine                               (CATGeometry                *  iSpine                    ,
                                                           CATFrFTopologicalSweepSpine_Type
                                                                                         iSpineType                = CATFrFTopologicalSweepSpine_Explicit) = 0;

  /**
 * Returns the spine.
 * @return
 * The pointer to the input or computed spine. The computed (or implicit) spine belongs to
 * this operator and is deleted at the operator deletion.
 */
  virtual CATGeometry* GetSpine                           ()                                                            = 0;

  /**
 * Moving frame type definition.
 * @param   iMFViewingDir
 * Used as viewing direction
 *   (if not provided, an automatic viewing direction will
 *   be computed)
 * if type is CATFrFTopologicalSweepMF_ParallelToPlane:
 * @param   iMFDir
 * Used as plane normal
 * Moving frame is computed using spine provided by SetSpine()
 * or first guide if no spine provided)
 */
  virtual void     SetMovingFrameParms                    (CATFrFTopologicalSweepMF_Type iMFType                   ,
                                                           CATMathDirection*             iMFViewingDir             = NULL,
                                                           CATMathDirection*             iMFDir                    = NULL) = 0;

  /**
 * (temporary and restricted use).
 * Manages motion axis twist with a variable (local) viewing direction.
 * To be used only with following conditions;
 * &lt;ul&gt;
 * &lt;li&gt;Standard moving frame type (CATFrFTopologicalSweepMF_Ortho).
 * &lt;li&gt;Unspec sweep (with profile)
 * &lt;li&gt;Spine with a complex 3D curve
 * &lt;/ul&gt;
 */
  virtual void     ForceVariableViewingDirMode            ()                                                            = 0;

  /**
 * Sets the simplification mode.
 * @param iSimplify
 * The simplification mode.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; for simplifying the adjacent faces on the same surface
 * (typically plane), &lt;tt&gt;FALSE&lt;/tt&gt; otherwise (default mode at the operator creation).
 */
  virtual void     SetSimplification                      (CATBoolean                    iSimplify                 = CATBoolean(1)) = 0;

  /**
 * Sets the plane detection mode.
 * @param iPlanesDetection
 * The plane detection mode.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; for replacing planar surfaces by planes,
 * &lt;tt&gt;FALSE&lt;/tt&gt; otherwise (default mode at the operator creation).
 */
  virtual void     SetPlanesDetection                     (CATBoolean                    iPlanesDetection          = CATBoolean(1)) = 0;

  /**
 * Sets the canonic surfaces detection mode (cones/cylinders/planes).
 * @param iCanonicSurfacesDetection
 * The canonic surface detection mode.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; for replacing nurbs surfaces by canonic surfaces,
 * &lt;tt&gt;FALSE&lt;/tt&gt; otherwise (default mode at the operator creation).
 */
  virtual void     SetCanonicSurfacesDetection            (CATBoolean                    iCanonicSurfacesDetection = CATBoolean(1)) = 0;

  //-----------------------------------------------------------------------
  //--------------- Methods for Unspec Sweep only -------------------------
  //-----------------------------------------------------------------------
  /** 
 * Definition of profile positioning type for a sweep with one or two guides (Sweep unspec and birail).
 * @param iPositionType
 * The type of profile positioning.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;
 * &lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;The profile is moved according to the transformation of its
 * axes system to the axes system of the beginning of the guide.
 * It is possible to redefine the profile axis system
 * by using the &lt;tt&gt;SetProfilePosition&lt;/tt&gt;. 
 * If not, the axis system of the beginning of the guide is used and
 * the sweep starts at the profile location (default mode).
 * &lt;dt&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;The sweep surface passes thru the profile: the profile axes system is
 * computed by intersecting the mean profile plane and the guide. 
 * This mean profile plane must be perpendicular to the guide.
 * &lt;dt&gt;&lt;tt&gt;3&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;The profile axes system is automatically computed as follows:
 * &lt;ul&gt;
 * &lt;li&gt;The origin is the start point of the profile.
 * &lt;li&gt;The third (Z) direction is normal to the profile medium plane.
 * &lt;li&gt;The first (X) direction joins the start and end points of the profile and is normalized.
 * &lt;li&gt;The second (Y) direction is completed by the vectorial product &lt;tt&gt;Y = Z^X&lt;/tt&gt;.
 * &lt;/ul&gt;
 *&lt;pre&gt;     ^Y
 *     ! ****
 *     !*    *
 *     *---&gt;X * &lt;/pre&gt;
 * &lt;dt&gt;&lt;tt&gt;4&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;The sweep surface passes thru the profile. This is the same
 * as &lt;tt&gt;iPositionType=2&lt;/tt&gt;, except that the mean profile plane need not 
 *                     intersect guide and be perpendicular to guide.
 * &lt;dt&gt;&lt;tt&gt;5&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; for two guides sweeps only: same as &lt;tt&gt;iPositionType=2&lt;/tt&gt;,
 * except that the extremities of the profile are not moved to the intersection with guides
 *&lt;pre&gt;
 *                     * guide points, - profile points, o profile extremities
 *                     initial profile:
 *                     o----*--...--*---o 
 *                     current profile with iPositionType=2:
 *                         *o---...---o*  (zoomed)
 *                     moving profile with iPositionType=5:
 *                     o----*--...--*---o   &lt;/pre&gt;
 * &lt;/dl&gt;
 */
  virtual void     SetProfilePositionType                 (CATLONG32                     iPositionType             )    = 0;

  /**
 * Defines the axes system of the profile.
 * &lt;br&gt;To use in case of profile position type &lt;tt&gt;iPositionType=1&lt;/tt&gt;.
 * @param iProfileAxis
 * The axes system of the profile.
 */
  virtual void     SetProfilePosition                     (CATMathAxis                *  iProfileAxis              )    = 0;

  /**
 * Retrieves the axes system of the profile (Sweep unspec.
 * @param oProfileAxis
 * The pointer to the input or computed axes system of the profile. 
 * The computed axes system belongs to
 * this operator and is deleted at the operator deletion.
 */
  virtual void     GetProfilePosition                     (CATMathAxis                *&amp; oProfileAxis              )    = 0;

  // Access to current frame
  // (default: final frame, using reference element, and angle law)
  // use SetBehaviourMode(CATFrFTopologicalSweepBehaviour_MovingFrameType)
  // to obtain moving frame
  /**
 * Retrieves the moving frame at a given ratio parameter.
 * @param iLambda
 * The parameter &lt;tt&gt;0 &lt;= iLambda &lt;=1 &lt;/tt&gt; indicating where the frame is retrieved.
 * @param oFrame
 * The moving frame, that may or may not have been allocated before call
 *  and must be deallocated after 
 */
  virtual void     GetFrame                               (double                        iLambda                   ,
                                                           CATMathAxis                *&amp; oFrame                    )    = 0;

  /**
 * Defines a variable viewing direction (sweep unspec).
 * @param iReferenceElement
 * The pointer to the geometry (CATSurface, skin CATBody). The current point
 * is projected onto the reference element. The viewing direction is the normal
 * to the reference element at the projected point. 
 * &lt;ul&gt;&lt;li&gt;In case of a plane, the
 * viewing direction is constant.
 * &lt;li&gt;In case of a skin body, the guide must lay on the reference element.
 * &lt;/ul&gt;
 */
  virtual void     SetReferenceElement                    (CATGeometry                 * iReferenceElement         )    = 0;

  /**
 * Defines an angular law to rotate the moving frame around its &lt;tt&gt;Z&lt;/tt&gt; axis.
 * @param iAngularLaw
 * The pointer to the angular law.
 * (historical behaviour: Angles must be given in radian for circular sweep, in degree for other types of sweep;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: Angles always given in degree)
 * 
 */
  virtual void     SetAngularLaw                          (CATCompositeLaw            *  iAngularLaw               )    = 0;

  /**
 * Defines an angular law to rotate the moving frame around its &lt;tt&gt;Z&lt;/tt&gt; axis.
 * @param iAngularLaw
 * The pointer to the angular law.
 * (historical behaviour: Angles must be given in radian for circular sweep, in degree for other types of sweep;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: Angles always given in degree)
 */
  virtual void     SetAngularLaw                          (CATLaw                     *  iAngularLaw               )    = 0;

  //-----------------------------------------------------------------------
  //--------------- Methods for BiRail Sweep only -------------------------
  //-----------------------------------------------------------------------
  /** 
 * Defines the anchor points for profile positionning.
 * &lt;br&gt;Moving the anchor points
 * from their initial position to intersection points between the sweeping plane 
 * and the guides, defines the 3D transformation to apply to the initial profile.
 * Anchor points should be in the profile plane for correct behaviour of
 * profile positionning software.
 * @param iPoint1
 * The point to anchor on first guide.
 * @param iPoint2
 * The point to anchor on second guide.
 */
  virtual void     SetAnchorPoints                  (const CATMathPoint                &amp; iPoint1                   ,
                                                     const CATMathPoint                &amp; iPoint2                   )    = 0;

  /**
 * Defines the scaling mode to apply to the profile.
 * @param iScalingOption
 * The scaling option
 * &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;
 * &lt;dl&gt;&lt;dt&gt;0&lt;/dt&gt;&lt;dd&gt; Inactive scaling
 * &lt;dt&gt;1&lt;/dt&gt;&lt;dd&gt; Active scaling (default mode).
 * &lt;/dl&gt;
 */
  virtual void     SetProfileScalingOption                (CATLONG32                     iScalingOption            )    = 0;

  //-----------------------------------------------------------------------
  //--------------- Methods for Canonic profile sweep only:    ------------
  //--------------- Segment, Circle and Conic                  ------------
  //-----------------------------------------------------------------------
  /**
 * Defines the limiting guides of a segment or circle sweep.
 * According to the number of guides, an appropriate build method is chosen.
 * This choice can also be explicitely given for a circle sweep
 * by the &lt;tt&gt;SetSolutionChoice&lt;/tt&gt; method.
 * @param iLimitGuides
 * The pointer to the list of pointers to the (wire body or curve) guides. 
 */
  virtual void     SetLimitGuides                         (CATLISTP(CATGeometry)      *  iLimitGuides              )    = 0 ;

  /**
 * Defines the references for the (start and end) angles measurement for a segment or circle sweep.
 *&lt;br&gt;To use according of the chosen sweep case.The sweep may not pass thru the functional guides.
 * @param iFunctionalGuides
 * The list of pointers to the one or two reference guides.
 */
  virtual void     SetFunctionalGuides                    (CATLISTP(CATGeometry)      *  iFunctionalGuides         )    = 0 ;

  /**
 * Defines the guide defining the center of the circle for a segment or circle sweep.
 * &lt;br&gt;To use according of the chosen sweep case.
 * @param iMiddleGuides
 * The list of pointers to the one middle guide.
 */
  virtual void     SetMiddleGuides                        (CATLISTP(CATGeometry)       * iMiddleGuides             )    = 0 ;

  /**
 * Defines the angular laws for defining limiting guides.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaws
 * The array of the pointers to the laws. 
 * @param iNbLaws
 * The number of laws. 
 * (historical behaviour: Angles must be given in radian for circular sweep, in degree for other types of sweep;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: Angles always given in degree)
 */
  virtual void     SetAngularLaws                         (CATCompositeLaw            ** iLaws                     ,
                                                           int                           iNbLaws                   )    = 0 ;

  /**
 * Defines the angular laws for defining limiting guides.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaws
 * The array of the pointers to the laws.
 * @param iNbLaws
 * The number of laws.
 * (historical behaviour: Angles must be given in radian for circular sweep, in degree for other types of sweep;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: Angles always given in degree)
 */
  virtual void     SetAngularLaws                         (CATLaw                     ** iLaws                     ,
                                                           int                           iNbLaws                   ) = 0 ;

  /**
 * Defines the angular laws for defining limiting guides.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaws
 * The array of the pointers to the laws.
 * @param iNbLaws
 * The number of laws.
 * (Angles must be given in degree, including in circular sweep case)
 */
  virtual void     SetAngularLawsInDegree                 (CATLaw                    **  iLaws                     ,
                                                           int                           iNbLaws                   )    = 0 ;

  /**
 * Defines the length laws for a segment sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaws
 * The array of the pointers to the laws.
 * @param iNbLaws
 * The number of laws.
 */
  virtual void     SetLengthLaws                          (CATCompositeLaw           **  iLaws                     ,
                                                           int                           iNbLaws                   )    = 0 ;

  /**
 * Defines the length laws for a segment sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaws
 * The array of the pointers to the laws.
 * @param iNbLaws
 * The number of laws.
 */
  virtual void     SetLengthLaws                          (CATLaw                     ** iLaws                     ,
                                                           int                           iNbLaws                   )    = 0 ;

  /**
 * Defines the radius law of a circle sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaw
 * The pointer to the radius law.
 */
  virtual void     SetRadiusLaw                           (CATCompositeLaw            *  iLaw                      )    = 0 ;

  /**
 * Defines the radius law of a circle sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaw
 * The pointer to the radius law.
 */
  virtual void     SetRadiusLaw                           (CATLaw                     *  iLaw                      )    = 0 ;

  /**
 * Defines the rho law of a conic sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaw
 * The pointer to the rho law, defining the conic type.
 */
  virtual void     SetRhoLaw                              (CATCompositeLaw            *  iLaw                      )    = 0 ;

  /**
 * Defines the rho law of a conic sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iLaw
 * The pointer to the rho law, defining the conic type.
 */
  virtual void     SetRhoLaw                              (CATLaw                     *  iLaw                      )    = 0 ;

  /**
 * Defines a slope condition for a conic or a circle sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iGuideRank
 * The rank of the guide on which the slope condition applies
 * (first or last guide).
 * @param iReferenceElement
 * The pointer to the reference element (CATPlane or skin CATBody or wire CATBody)
 * defining the angular reference. For a null angle, conic will be tangent
 * to the plane or skin reference element, or to the line joining guide 
 * and a wire reference element. 
 * @param iAngleLaw
 * The pointer to the angle law.
 */
  virtual void     SetLimitGuideSlopeCondition            (int                           iLimitGuideRank           ,
                                                           CATGeometry                 * iReferenceElement         ,
                                                           CATCompositeLaw             * iAngularLaw               )    = 0 ;

  /**
 * Defines a slope condition for a conic or a circle sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iGuideRank
 * The rank of the guide on which the slope condition applies
 * (first or last guide).
 * @param iReferenceElement
 * The pointer to the reference element (CATPlane or skin CATBody or wire CATBody)
 * defining the angular reference. For a null angle, conic will be tangent
 * to the plane or skin reference element, or to the line joining guide 
 * and a wire reference element.
 * @param iAngleLaw
 * The pointer to the angle law.
 */
  virtual void     SetLimitGuideSlopeCondition            (int                           iLimitGuideRank           ,
                                                           CATGeometry*                  iReferenceElement         ,
                                                           CATLaw*                       iAngularLaw               )    = 0 ;

  /**
 * Defines the conic, circle or segment to keep if case of ambiguous case.
 * @param iSolutionChoice
 * The chosen part. Refer to the encyclopedia documentation.
 */
  virtual void     SetSolutionChoice                      (CATLONG32                     iSolutionChoice           )    = 0 ;

  /**
 * Defines limiting elements to be used instead of one or two length laws in a segment sweep.
 *&lt;br&gt;To use according of the chosen sweep case.
 * @param iNbElements
 * The number of limiting elements
 * &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;
 * &lt;dl&gt;&lt;dt&gt;0&lt;/dt&gt;&lt;dd&gt; If no limiting element
 * &lt;dt&gt;1&lt;/dt&gt;&lt;dd&gt; If only one limiting element instead of first length law.
 * &lt;dt&gt;2&lt;/dt&gt;&lt;dd&gt; If two limiting elements (first one may be null).
 * &lt;/dl&gt;
 * @param iLimitingElements
 * The array of pointers to the limiting elements (CATPlane).
 * Null elements may be given.
 */
  virtual void     SetLimitingElements                    (int                           iNbElements               ,
                                                           CATGeometry**                 iLimitingElements         )    = 0 ;

  /**
 * Defines cone option for segment sweep computation with reference element
 * (behaves like a draft computation).
 */
  virtual void     SetConeOption                          ()                                                            = 0 ;

  //-----------------------------------------------------------------------
  //--------------- Methods for Multiprofile Sweep only -------------------
  //-----------------------------------------------------------------------
  /**
 * Sets the continuity constraints on start and end profiles (for multi profiles sweep).
 * &lt;br&gt;The start and end profiles are not necessarily the first and last
 * profile of the list given at the operator creation.
 * @param iProfileRank
 * The rank (beginning at 1) of the profile to constraint.
 * @param iReferenceElement
 * The pointer to the reference element (CATPlane or skin CATBody) on which the profile
 * must lay. The sweep is tangent to a skin CATBody reference element and normal to 
 * a CATPlane reference element.
 * @param iContinuityCondition
 * The type of continuity constraint.
 */
  virtual void     SetProfileContinuityCondition          (int                            iProfileRank,
                                                           CATGeometry                  * iReferenceElement,
                                                           CATFrFTopologicalSweepContinuity_Type
                                                                                          iContinuityCondition     = CATFrFTopologicalSweepContinuity_G1
                                                                                                                      ) = 0 ;

  /**
 * Defines the profile automatic coupling mode.
 * @param iCouplingType
 * The coupling type.
 * @param iForceErrorOnImpossibleCoupling
 * The error management.
 * &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;
 * &lt;dl&gt;&lt;dt&gt;FALSE&lt;/dt&gt;&lt;dd&gt; If the required coupling mode is not possible, the operator tries to couple
 * in a lower mode (the lowest mode is the coupling by curvilinear length).
 * &lt;dt&gt;TRUE&lt;/dt&gt;&lt;dd&gt; An error is thrown if the required coupling is not possible.
 * &lt;/dl&gt;
 * @param iCoupleFirstVerticesOnImpossibleCoupling
 * The coupling strategy when coupling is impossible.
 * &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;
 * &lt;dl&gt;&lt;dt&gt;FALSE&lt;/dt&gt;&lt;dd&gt; If the required coupling mode is not possible, the operator tries to couple
 * in a lower mode or raises an error (according to &lt;tt&gt;iForceErrorOnImpossibleCoupling&lt;/tt&gt; param)
 * &lt;dt&gt;TRUE&lt;/dt&gt;&lt;dd&gt; The first vertices with same continuity of the corresponding domains are coupled, 
 * even if some vertices counts are different in these domains: vertices may be left in some domains.
 * &lt;/dl&gt;
 */
  virtual void     SetProfileAutomaticCouplingMode        (CATFrFTopologicalSweepAutomaticCoupling_Type
                                                                                         iCouplingType,
                                                           CATBoolean                    iForceErrorOnImpossibleCoupling          = FALSE,
                                                           CATBoolean                    iCoupleFirstVerticesOnImpossibleCoupling = FALSE
                                                                                                                      ) = 0 ;

  /**
 * Sets the continuity constraints (for multi profiles sweep) for a guide.
 * @param iRankGuide
 * The rank (beginning at 1) of the guide to constraint.
 * @param iReferenceElement
 * The pointer to the reference element (CATPlane or skin CATBody) on which the guide
 * must lay. Each sweep moving section is tangent to a skin CATBody reference element and normal to 
 * a CATPlane reference element.
 * @param iContinuityCondition
 * The type of continuity constraint.
 */
  virtual void     SetGuideContinuityCondition            (int                           iRankGuide                ,
                                                           CATGeometry                 * iReferenceElement         ,
                                                           CATFrFTopologicalSweepContinuity_Type
                                                                                         iContinuityCondition      = CATFrFTopologicalSweepContinuity_G1
                                                                                                                   )    = 0 ;

  /**
 * Sets the profiles orientation (for multi profiles sweep).
 * @param iRankProfile
 * The rank (beginning at 1) of the profile.
 * @param iOrientation
 * The orientation of the profile: 
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;CATFrFTopologicalSweepOrientation_Positive&lt;/tt&gt;
 * to take the natural orientation of the profile,  
 * &lt;tt&gt;CATFrFTopologicalSweepOrientation_Negative&lt;/tt&gt; for the opposite orientation.
 */
  virtual void     SetProfileOrientation                  (int                           iRankProfile,
                                                           CATFrFTopologicalSweepOrientation_Type
                                                                                         iOrientation              = CATFrFTopologicalSweepOrientation_Positive
                                                                                                                   )    = 0 ;

  /**
 * Sets the relimitation mode by the extremity profiles.
 * @param iRelimitationMode
 * The relimitation mode.
 */
  virtual void     SetRelimitationMode                    (CATFrFTopologicalSweepRelimitation_Type
                                                                                         iRelimitationMode         = CATFrFTopologicalSweepRelimitation_Off
                                                                                                                   )    = 0 ;

  /**
 * Defines additional guides to be used only for profile sections coupling.
 * @param iCouplingGuides
 * The list of pointers to the coupling guides (wire bodies).
 */
  virtual void     SetCouplingGuides                      (CATLISTP(CATGeometry)       * iCouplingGuides           )    = 0 ;

  /**
 * Gets vertices non coupled by automatic section vertices coupling.
 * @param oVertices
 * The list of non coupled section vertices.
 * @param oSectionNumbers
 * The list of section numbers for non coupled vertices.
 * @param oEdgeNumbers
 * The list of edge numbers for non coupled vertices (the vertex oVertices[i] is
 * between edge oEdgeNumbers[i] and edge 1+oEdgeNumbers[i])
 * @param oLevels
 * The list of discontinuity levels for non coupled vertices
 * (1 for C0 non C1 vertices, 2 for C1 non C2 vertices) 
 * @param oDomains
 * The list of domain numbers for non coupled vertices
 * (internal numerotation within current level management; same domain number
 * may be given during non C1 vertices management and during non C2 vertices 
 * management)
 */
  virtual void     GetNonCoupledSectionVertices           (CATLISTP(CATVertex)         * oVertices                 = 0,
                                                           CATListOfInt                * oSectionNumbers           = 0,
                                                           CATListOfInt                * oEdgeNumbers              = 0,
                                                           CATListOfInt                * oLevels                   = 0,
                                                           CATListOfInt                * oDomains                  = 0) = 0 ;

  /**
 * Internal use.
 * Defines the guide to be used for positionning the moving axis origin.
 * @param iChosenGuide
 * The guide chosen (that must belong to the set of limit or functional guides). 
 * @param iReferenceElement
 * The reference element chosen for normal computation. 
 */
  virtual void     ChooseOriginGuide                      (CATGeometry                 * iChosenGuide              ,
                                                           CATGeometry                 * iReferenceElement         = NULL) = 0 ;

  /**
 * Gets the initial area for the profile evaluated in a given parameter,
 * and the final area after application of the area law (if any).
 * @param iParam
 * The parameter value in which the area is to be computed.
 * @param iInitialArea
 * The profile area before deformation with area law.
 * @param iFinalArea
 * The profile area after deformation with area law.
 */
  virtual void     GetProfileArea                         (double                        iParam                    ,
                                                           double                      &amp; oInitialArea              ,
                                                           double                      &amp; oFinalArea                )    = 0 ;

  /**
 * Defines the area law for section deformation.
 * This option is available only with 0, 1 or 2 guides.
 * If the input sections do not fit with the area law, the surface will not
 * fit to these sections.
 */
  virtual void     SetAreaLaw                             (CATCompositeLaw            *  iAreaLaw                  ) = 0 ;

  /**
 * Defines the area law for section deformation.
 * This option is available only with 0, 1 or 2 guides.
 * If the input sections do not fit with the area law, the surface will not
 * fit to theses sections.
 */
  virtual void     SetAreaLaw                             (CATLaw                     *  iAreaLaw                  )    = 0 ;

#ifdef CATIACGMR421CAA
  //-----------------------------------------------------------------------
  //--------------- Other methods not available for all kinds of sweeps ---
  //-----------------------------------------------------------------------
  /**
 * Retrieves the moving frame parameter where profile is positionned
 * (Unspec sweep, Multi profile sweep).
 * @param iProfileRank
 * The rank (beginning at 1) of the profile.
 * @return
 * parameter value between 0. and 1.
 */
  virtual double   GetProfileParameter                    (int                           iProfileRank              = 1) = 0 ;

#endif
  //-----------------------------------------------------------------------
  //--------------- General methods               -------------------------
  //-----------------------------------------------------------------------
  // Get All Profiles : computes and gives list of profiles
  // for a parameter value between 0. and 1. along guide
  // WARNING: calling software must delete result pointer
  // and every curve belonging to result list
  /**
 * Returns the computed curves at a given section of the sweep.
 * &lt;br&gt;The number of the curves depends on the number of edges
 * of the initial profiles and the number of guides.
 * @param iLambda
 * The parameter &lt;tt&gt;0 &lt;= iLambda &lt;=1 &lt;/tt&gt; indicating where the curves are computed.
 * @return
 * The list of the pointers to the created curves. If you do not want to keep
 * the curves, use the @href CATICGMContainer#Remove method. &lt;tt&gt;Delete&lt;/tt&gt; the
 * list after use.
 */
  virtual CATFrFTopologicalSweep_ListPOfCATCurve* GetAllProfiles(double                  iLambda                   )    = 0;

#ifndef CATIACGMR421CAA
  //-----------------------------------------------------------------------
  //--------------- Other methods not available for all kinds of sweeps ---
  //-----------------------------------------------------------------------
  /**
 * Retrieves the moving frame parameter where profile is positionned
 * (Unspec sweep, Multi profile sweep).
 * @param iProfileRank
 * The rank (beginning at 1) of the profile.
 * @return
 * parameter value between 0. and 1.
 */
  virtual double   GetProfileParameter                    (int                           iProfileRank              = 1) = 0 ;

  //-----------------------------------------------------------------------
  //--------------- General methods               -------------------------
  //-----------------------------------------------------------------------

#endif

  /**
 * Asks for the body closure. 
 *&lt;br&gt; To use in cases the closed and planar profiles for example.
 */
  virtual void     SetClosureMode                         ()                                                            = 0 ;

  /**
 * Checks the input data according to the sweep case.
 * @param iExpectedCase
 * The expected sweep case to test. If &lt;tt&gt;0&lt;/tt&gt;, the method tries to determine
 * the appropriate case in function of the input arguments.
 * &lt;br&gt;Refer to the encyclopedia for the detailed options of the different sweep cases.
 * @return
 * The case number if it is relevant, &lt;tt&gt;0&lt;/tt&gt; if the the case number is 
 * irrelevant, or if the inputs do not correspond to the specified case.
 */
  virtual CATLONG32 ValidateCaseNumber                    (CATLONG32                     iExpectedCase             = 0) = 0 ;

  /**
 * Defines the vertices limiting areas to eliminate from final sweep.
 * @param iStartVertices
 * The starting vertices for each areas to eliminate.
 * @param iEndVertices
 * The ending vertices for each area to eliminate.
 * The same number of vertices must be defined for start and end. The vertices must be located
 * on the first guide, but not necessarily logically related to it.
 */
 virtual void     SetAreasToEliminate                     (CATLISTP(CATVertex)          &amp; iStartVertices           ,
                                                           CATLISTP(CATVertex)          &amp; iEndVertices             ) = 0;

  /**
 * Defines the untwist mode, in which every twisted area will be computed.
 * @param iUntwistMode
 * The untwist mode. If &lt;tt&gt;0&lt;/tt&gt;, no twisted areas computation.
 * If &lt;tt&gt;1&lt;/tt&gt;, twisted areas will be computed and available.
 * If &lt;tt&gt;2&lt;/tt&gt;, twisted areas will be computed and suppressed from the resulting body.
 * @param iRecoilDistance
 * The recoil curvilinear distance on master guide to be used
 * before and after each twisted area in suppress mode.
 */
 virtual void     SetUntwistMode                          (int                            iUntwistMode             ,
                                                           double                         iRecoilDistance          = 0.0) = 0 ;

  /**
 * Retrieves the limiting parameters of the twisted areas ot the wrap areas.
 * @param oTwistBegin
 * the beginning parameters of the twisted areas.
 * @param oTwistEnd
 * the ending parameters of the twisted areas.
 */
 virtual void     GetTwistedAreas                         (CATListOfDouble               &amp; oTwistBegin             ,
                                                           CATListOfDouble               &amp; oTwistEnd               ) = 0;

  /**
 * Defines the wrap detection mode.
 * @param iWrapDetection
 * The wrap detection mode. If &lt;tt&gt;0&lt;/tt&gt;, no wrap computation.
 * If &lt;tt&gt;1&lt;/tt&gt;, wrap areas will be computed.
 * (historical behaviour: must be called if wrap detection to be done;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: wrap detection is implicitly done)
 */
 virtual void     SetWrapDetection                        (int                             iWrapDetection          ) = 0 ;

  /**
 * Defines the twist detection mode.
 * @param iTwistDetection
 * The twist detection mode. If &lt;tt&gt;0&lt;/tt&gt;, no twist detection.
 * If &lt;tt&gt;1&lt;/tt&gt;, twists will be detected.
 * (historical behaviour: must be called if twist detection to be done;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: twist detection is implicitly done)
 */
 virtual void     SetTwistDetection                       (int                             iTwistDetection         ) = 0 ;

  /**
 * Asks for managing C0 vertices in topological computation error as pseudo-twisted areas centers.
 * (untwist and fill twist tools available).
 */
 virtual void     SetPseudoUntwistModeForC0VerticesInError()                                                         = 0;

  /**
 * Defines the twisted or removed areas filling mode
 * @param iFillTwistMode
 * The filling mode. If &lt;tt&gt;0&lt;/tt&gt;, no fill.
 * If &lt;tt&gt;1&lt;/tt&gt;, areas will be filled.
 * @param iFillTwistDefaultOption
 * The filling default option for all areas.
 */
 virtual void     SetFillTwist                            (int                             iFillTwistMode          = 0,
                                                           CATFrFTopologicalSweepFill_Type iFillTwistDefaultOption = CATFrFTopologicalSweepFill_NoFill_0
                                                          )                                                          = 0;

  /**
 * Defines a smooth option for moving frame and comb extraction.
 * @param iSmoothOption
 * The smoothing option
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; no smoothing will be done
 * (default mode at operator creation),
 * &lt;tt&gt;1&lt;/tt&gt; smoothing will be done.
 */
 virtual void     SetSmoothOption                         (int                             iSmoothOption           = 0)    = 0 ;

  /**
 * Defines the smooth angle threshold. 
 * @param iSmoothAngleThreshold
 * The threshold for smooth (in radian); any angle below this value will be smoothed
 * if smooth option has been activated by SetSmoothOption method.
 * The default value, when method is not called, is the standard geometric modeler tangency continuity tolerance
 * (the equivalent in radian of 0.5 degree).
 */
  virtual void     SetSmoothAngleThreshold                (double                           iAngleThreshold        )       = 0 ;

  /**
 * Defines clean guides option, and clean parameter values. Pointers
 * to parameter values are to be given only when corresponding parameter
 * is redefined, otherwise, standard parameter value will be used. Pointers
 * may contain addresses of local variables that will be lost after call: 
 * parameter values will be copied by this method.
 * @param iCleanOption
 * The cleaning option
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; no cleaning will be done
 * (default mode at operator creation),
 * &lt;tt&gt;1&lt;/tt&gt; cleaning will be done.
 * @param iCleanMaxDeformation
 * The pointer to max deformation authorized.
 * @param iCleanSmallCurvesMaxLength
 * The pointer to maximum length of curves to be kept.
 * @param iCleanCurvatureThreshold
 * The pointer to the curvature threshold.
 */
 virtual void     SetCleanGuidesOption                    (int                             iCleanOption            = 0,
                                                           double                        * iCleanMaxDeformation    = NULL,
                                                           double                        * iCleanSmallCurvesMaxLength = NULL,
                                                           double                        * iCleanCurvatureThreshold   = NULL) = 0;

  /**
 * Defines clean profiles option, and clean parameter values. 
 * Same as for guides
 */
 virtual void     SetCleanProfilesOption                  (int                             iCleanOption               = 0,
                                                           double                        * iCleanMaxDeformation       = NULL,
                                                           double                        * iCleanSmallCurvesMaxLength = NULL,
                                                           double                        * iCleanCurvatureThreshold   = NULL) = 0;

  /**
 * Asks for topological lay down to be done internally for all guides and profiles with support
 * surfaces.
 * @param iLayDownTolerance
 * The pointer to the lay down tolerance (maximum distance between wire to be laid down
 * and its support surface).
 * (historical behaviour: must be called if internal lay down to be done;
 * upgraded behaviour if SetUpgradedDefaultSettings() has been called: internal lay down is implicitly done)
 */
 virtual void     SetLayDownRequest                       (double                        * iLayDownTolerance       = NULL) = 0 ;

protected:
  /**
   * Destructor
   */
  virtual        ~CATICGMFrFTopologicalSweep              (); // -&gt; delete can&#x27;t be called
};

#endif /* CATICGMFrFTopologicalSweep_h_ */
</div>
    
    <div class="navigation">
        <div><a href="CATICGMFrFSmoothingOper.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATICGMFrFSmoothingOper.h</a></div>
        <div><a href="CATICGMGeoToTopOperator.html">‰∏ã‰∏ÄÈ°µ: CATICGMGeoToTopOperator.h ‚Üí</a></div>
    </div>
</body>
</html>