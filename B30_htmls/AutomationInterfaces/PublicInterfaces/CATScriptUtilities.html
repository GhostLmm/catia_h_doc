<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AutomationInterfaces/PublicInterfaces/CATScriptUtilities.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>AutomationInterfaces/PublicInterfaces/CATScriptUtilities.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATListOfITypeLib.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATListOfITypeLib.h</a></div>
        <div><a href="../../BSFBuildtimeData/PublicInterfaces/CATIAV5Level.html">‰∏ã‰∏ÄÈ°µ: CATIAV5Level.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATScriptUtilities_h
#define CATScriptUtilities_h


// COPYRIGHT DASSAULT SYSTEMES 2000

// System framework
#include &quot;CATString.h&quot;
#include &quot;CATUnicodeString.h&quot;
#include &quot;CATScriptLanguage.h&quot;
#include &quot;CATListOfCATString.h&quot;
#include &quot;CATListOfCATUnicodeString.h&quot;
#ifndef _WINDOWS_SOURCE
#include &quot;CATMainwin.h&quot;
#else // _WINDOWS_SOURCE
#include &lt;oaidl.h&gt;
#endif // _WINDOWS_SOURCE
class CATError;
#include &quot;CATVariant.h&quot;
#include &quot;CatScriptLibraryType.h&quot;

// AutomationInterfaces framework
#include &quot;AutomationItf.h&quot;
#include &quot;CATListOfITypeLib.h&quot;
#include &quot;CATListOfCATIScriptFunction.h&quot;

// Flags
/** @nodoc */
#define CAT_EXECUTESCRIPT_AUTOMATIC_REPLAY_ENABLE               0x01
/** @nodoc */
#define CAT_EXECUTESCRIPT_MACRO_UNDOABILITY_FORCE_DISABLE       0x02
/** @nodoc */
#define CAT_EXECUTESCRIPT_MACRO_UNDOABILITY_FORCE_ENABLE        0x04

class CATScriptRef;
class CATIScriptProgram;
class CATIScriptFunction;

// Dialog framework
class CATDialog;

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */

/**
 * Class to provide utility functions which simplify the use
 * of the scripting interfaces.
 */
class ExportedByCATAutoItf CATScriptUtilities {
	public:

		/**
		 * @nodoc
		 * Converts a script language code to a script language name.
		 */
		static HRESULT __stdcall LanguageCodeToLanguageName(
			CATScriptLanguage iLanguage, 
			CATUnicodeString&amp; oLanguage);

		/**
		 * @nodoc
		 * Converts a script language name to the standard file
		 * extension for script files written in that language.
		 */
		static HRESULT LanguageNameToLanguageExtension(
			const CATUnicodeString&amp; iLanguage, 
			CATString&amp; oExtension);

		/**
		 * @nodoc
		 * A utility function to split a V5 path concatenation into 
		 * an array of paths.
		 */
		static HRESULT SplitConcatenation(
			const CATUnicodeString&amp; iPath, 
			CATListOfCATUnicodeString&amp; oDirs);

		/**
		 * @nodoc
		 * A utilitity function which returns all the files with a give extension 
		 * in the current directory.
		 */
		static HRESULT GetFilesOfTypeInDirectory(
			const CATUnicodeString&amp; iPath, 
			const CATUnicodeString&amp; iExt, 
			CATListOfCATUnicodeString&amp; oFiles);


		/**
		 * @nodoc
		 * Calls release on all the items of a ITypeLib list.
		 */
		static void Release(
			CATListOfITypeLib &amp;iList);

		/**
		 * @nodoc
		 * Copies a list of typelibs into another list of typelibs.
		 */
		static void Copy(
			CATListOfITypeLib&amp; iFrom, 
			CATListOfITypeLib&amp; oTo);

		/**
		 * @nodoc
		 * Appends a list of typelibs to another list of typelibs.
		 */
		static void Append(
			CATListOfITypeLib&amp; iFrom, 
			CATListOfITypeLib&amp; oTo);

		/**
		 * @nodoc
		 * Calls release on all the items of a CATIScriptFunction list
		 * and removes all the items.
		 */
		static void Release(
			CATListOfCATIScriptFunction &amp;iList);

		/**
		 * @nodoc
		 * Loads a list of typelibs specified by their path.
		 * The function returns two lists: the list of typelibs which
		 * have actually been loaded and their paths.
		 */
		static HRESULT LoadTypeLibs(
			CATListOfCATUnicodeString&amp; iLibPaths, 
			CATListOfCATUnicodeString&amp; oLoadedPaths, 
			CATListOfITypeLib&amp; oLoadedLibs);

		/**
		 * @nodoc
		 * Register a list of typelibs with the Windows registry.
		 */
		static HRESULT RegisterTypeLibs(
			CATListOfCATUnicodeString&amp; iLibPaths, 
			CATListOfITypeLib&amp; iLibs);

		/**
		 * @nodoc
		 * Unregister a list of typelibs from the Windows registry.
		 */
		static HRESULT UnregisterTypeLibs(
			CATListOfITypeLib&amp; iLibs,
			int iVersionMajor,
			int iVersionMinor);

		/**
		 * @nodoc
		 * Returns TRUE if the typelib has been generated by
		 * the V5 IDL compiler, false otherwise
		 */
		static HRESULT IsV5TypeLib(
			ITypeLib* iTypelib,
			CATBoolean&amp; oBoolean);

		/**
		 * @nodoc
		 * Short cut to invoke CATIScriptUIServices::RunErrorPanel.
		 */
		static HRESULT RunErrorPanel(
			HRESULT iErrorCode,
			CATDialog* iParentDialog);

		/**
		 * @nodoc
		 * Extracts the extension part of a file name.
		 */
		static HRESULT GetExtension(
			const CATUnicodeString&amp; iFilePath,
			CATUnicodeString&amp; oExtension);

		/**
		 * @nodoc
		 * Reads the contents of a file as UTF8 text.
		 */
		static HRESULT __stdcall ReadFile(
			const CATUnicodeString&amp; iFilePath, 
			CATUnicodeString&amp; oContents);

		/**
		 * @nodoc
		 * Writes the contents of a file as UTF8 text.
		 */
		static HRESULT __stdcall WriteFile(
			const CATUnicodeString&amp; iFilePath, 
			CATUnicodeString&amp; iContents);

		/**
		 * @nodoc
		 * A short-cut method which runs a program reference
		 * asynchronously. The method retrieves the CATMain
		 * entry point. It automatically registers the
		 * CATIAApplication instance under the &quot;CATIA&quot; name.
		 * If iDisplaysErrorMessages is TRUE, it also registers
		 * a error handler which will trigger an error panel
		 * when the function fails.
		 * iAutomaticReplay specifies whether the replay is automatic or 
		 * if it is explicitly done from a user interaction.
		 */
		static HRESULT __stdcall ExecuteReference(
			CATScriptRef* iReference,
			CATBoolean iDisplaysErrorMessages,
			CATBoolean iAutomaticReplay = TRUE);
 
		/**
		 * A short-cut method which runs, from an interactive program or a macro, a function written in a scripting language
		 * synchronously. ExecuteScript will return only once the scripted function
		 * has finished running. This method works only in a CATIA V5 interactive program or a macro.
		 * &lt;br&gt;
		 * &lt;b&gt;CAUTION&lt;/b&gt;: This method must be called on time-out, using @href CATApplication#AddTimeOut . The sample 
   * below illustrates how to call it on time-out. If you would not call it on time-out, a script which calls one of
   * the following method will not work:
		 * &lt;ul&gt;
		 * &lt;li&gt;Selection.SelectElement2&lt;/li&gt;
		 * &lt;li&gt;Selection.SelectElement3&lt;/li&gt; 
		 * &lt;li&gt;Selection.IndicateOrSelectElement2D&lt;/li&gt;
		 * &lt;li&gt;Selection.IndicateOrSelectElement3D&lt;/li&gt;
		 * &lt;li&gt;Document.Indicate2D&lt;/li&gt;
		 * &lt;li&gt;Document.Indicate3D&lt;/li&gt;
   * &lt;li&gt;Application.StartCommand&lt;/li&gt;
		 * &lt;/ul&gt;
   * The method illustrated in the sample below is the only method to run any script.
		 * @param iLibraryName
		 * The library in which the script is contained
		 * @param iLibraryType
		 * The type of the library
		 * @param iProgramName
		 * The name of the program in the library
		 * @param oResult
		 * The value returned by the function (if any)
		 * @param iFunctionName
		 * The name of the function to invoke
		 * @param iParameters
		 * An C++ array of parameters for the function
		 * @param iParamCount
		 * The size of the parameter array.
		 * @param iAutomaticReplay
		 * Specifies whether the replay is automatic or if it is explicitly done
		 * from a user interaction.
		 * &lt;! @sample &gt;
		 * &lt;/dl&gt;
		 * &lt;dt&gt;&lt;b&gt;Example:&lt;/b&gt;
		 * &lt;dd&gt;
		 * This example illustrates how to call this method on time-out. It describes how to migrate from a CATStateCommand,
   * named CAAMyStateCommand, which would run ExecuteScript synchronously, to a CATStateCommand which would run
   * ExecuteScript on time-out.&lt;/br&gt;
   * Instead of:
   * &lt;ul&gt;
   * &lt;li&gt;a transition, and its associated action, which:
   * &lt;ul&gt;
   * &lt;li&gt;run the script synchronously&lt;/li&gt;
   * &lt;li&gt;do the actions which must be ran after the script execution&lt;/li&gt;
   * &lt;/ul&gt;&lt;/li&gt;
   * &lt;li&gt;the transition triggering during execution making pass from a CATDialogState named SourceState to a
   * CATDialogState named DestinationState&lt;/li&gt;
   * &lt;/ul&gt;
   * we will have:
   * &lt;ul&gt;
   * &lt;li&gt;a transition executing the first part of the preceeding solution: it adds a call-back on time out, the call-back
   * running the script&lt;/li&gt;
   * &lt;li&gt;this transition makes pass from a CATDialogState named SourceState to a CATDialogState named
   * IntermediaryState&lt;/li&gt;
   * &lt;li&gt;during execution, when the current state will be IntermediaryState, the preceeding call-back will be
   * executed. This call-back runs the script, and triggers the other transition&lt;/li&gt;
   * &lt;li&gt;another transition executing the second part of the preceeding solution: do the actions which must be ran after
   * the script execution&lt;/li&gt;
   * &lt;li&gt;this transition makes pass from IntermediaryState to a CATDialogState named 
   * DestinationState&lt;/li&gt;
   * &lt;/ul&gt;
   * Your code will be the following:
   * &lt;ul&gt;
   * &lt;li&gt;CAAMyStateCommandInteractionNotifier.h:&lt;pre&gt;
   *#ifndef CAAMyStateCommandInteractionNotifier_H
   *#define CAAMyStateCommandInteractionNotifier_H
   *#include &quot;CATCommand.h&quot;
   *class CATNotification;   
   *class CAAMyStateCommandInteractionNotifier: public CATCommand
   *{ public:
   *  CAAMyStateCommandInteractionNotifier();
   *  virtual ~CAAMyStateCommandInteractionNotifier();
   *  void Advise(CATCommand* ToClient, CATNotification* Notif);
   *};
   *#endif&lt;/pre&gt;&lt;/li&gt;
   * &lt;li&gt;CAAMyStateCommandInteractionNotifier.cpp:&lt;pre&gt;
   *#include &quot;CAAMyStateCommandInteractionNotifier.h&quot;
   *#include &quot;CATCommand.h&quot;
   *#include &quot;CATNotification.h&quot;
   *CAAMyStateCommandInteractionNotifier::CAAMyStateCommandInteractionNotifier() 
   *{}
   *CAAMyStateCommandInteractionNotifier::~CAAMyStateCommandInteractionNotifier()
   *{}
   *void CAAMyStateCommandInteractionNotifier::Advise(CATCommand* ToClient, CATNotification* Notif)
   *{ SendNotification(ToClient,Notif); }&lt;/pre&gt;&lt;/li&gt;
   * &lt;li&gt;CAAMyStateCommandNotification.h:&lt;pre&gt;
   *#ifndef CAAMyStateCommandNotification_H
   *#define CAAMyStateCommandNotification_H
   *#include &quot;CATNotification.h&quot;
   *class CAASourceStateToIntermediaryStateNotif : public CATNotification
   *{ CATDeclareClass;
   *  public:
   *    CAASourceStateToIntermediaryStateNotif();
   *    virtual ~CAASourceStateToIntermediaryStateNotif();
   *};
   *class CAAIntermediaryStateToDestinationStateNotif : public CATNotification
   *{ CATDeclareClass;
   *  public:
   *    CAAIntermediaryStateToDestinationStateNotif();
   *    virtual ~CAAIntermediaryStateToDestinationStateNotif();
   *};
   *class CAADestinationStateToNULLStateNotif : public CATNotification
   *{ CATDeclareClass;
   *  public:
   *    CAADestinationStateToNULLStateNotif();
   *    virtual ~CAADestinationStateToNULLStateNotif();
   *};
   *#endif&lt;/pre&gt;&lt;/li&gt;
   * &lt;li&gt;CAAMyStateCommandNotification.cpp:&lt;pre&gt;
   *#include &quot;CAAMyStateCommandNotification.h&quot;
   *CATImplementClass(CAASourceStateToIntermediaryStateNotif,Implementation,CATNotification,CATNull);
   *CAASourceStateToIntermediaryStateNotif::CAASourceStateToIntermediaryStateNotif() {}
   *CAASourceStateToIntermediaryStateNotif::~CAASourceStateToIntermediaryStateNotif() {}
   *CATImplementClass(CAAIntermediaryStateToDestinationStateNotif,Implementation,CATNotification,CATNull);
   *CAAIntermediaryStateToDestinationStateNotif::CAAIntermediaryStateToDestinationStateNotif() {}
   *CAAIntermediaryStateToDestinationStateNotif::~CAAIntermediaryStateToDestinationStateNotif() {}
   *CATImplementClass(CAADestinationStateToNULLStateNotif,Implementation,CATNotification,CATNull);
   *CAADestinationStateToNULLStateNotif::CAADestinationStateToNULLStateNotif() {}
   *CAADestinationStateToNULLStateNotif::~CAADestinationStateToNULLStateNotif() {}&lt;/pre&gt;&lt;/li&gt;
   *&lt;li&gt;CAAMyStateCommand.h:&lt;pre&gt;
   *#ifndef CAAMyStateCommand_h
   *#define CAAMyStateCommand_h
   *#include &quot;CATStateCommand.h&quot;
   *#include &quot;CATPanelAcquisition.h&quot;
   *#include &quot;CAAMyStateCommandNotification.h&quot;
   *#include &quot;CAAMyStateCommandInteractionNotifier.h&quot;
   *#include &quot;CATPathElement.h&quot;
   *#include &quot;CATNotifier.h&quot;
   *class CATDialogAgent;
   *class CAAMyStateCommand: public CATStateCommand
   *{ CmdDeclareResource(CAAMyStateCommand,CATStateCommand);
   *  public:
   *  CAAMyStateCommand( );
   *  virtual ~CAAMyStateCommand();
   *  virtual CATStatusChangeRC Activate(CATCommand*	iFromClient,CATNotification*	iNotification);
   *  virtual CATStatusChangeRC Desactivate(CATCommand*	iCmd,CATNotification*	iNotification);
   *  virtual CATStatusChangeRC Cancel(CATCommand*	iCmd,CATNotification*	iNotification);
   *  virtual void BuildGraph();
   *  static void sRunScriptAndTriggerSecondPartTransition(CATCommand* iCAAMyStateCommand,int iSubscribedType,
   *                                                       CATString* iScriptName);
   *  static int sOccurenceCount; // The purpose of this variable is to avoid instances of the current
   *                              // CATStateCommand which do not exist any more to be used.
   *                              // In the following scenario:
   *                              //  - the CAA developer uses a CATStateCommand
   *                              //  - the CATStateCommand runs a script on time-out
   *                              //  - the script calls the automation method Documents.Open, giving it a Part
   *                              //    as parameter
   *                              //  - during execution, only a Product is open, and CAAMyStateCommand is ran 
   *                              // we have:
   *                              //  - the CAAMyStateCommand::sRunScriptAndTriggerSecondPartTransition
   *                              //    call-back is executed
   *                              //  - Documents.Open is executed
   *                              //  - we enter the &quot;Part Design&quot; workbench
   *                              //  - The &quot;Select&quot; command ask to become active
   *                              //  - we go through the CAAMyStateCommand destructor
   *                              //  - we go out of the script
   *                              //    - - -&gt; From now, 
   *                              //           CAAMyStateCommand::sRunScriptAndTriggerSecondPartTransition must
   *                              //           not use anymore the CAAMyStateCommand instance
   *  CAASourceStateToIntermediaryStateNotif* _CAASourceStateToIntermediaryStateNotif;
   *  CAAIntermediaryStateToDestinationStateNotif* _CAAIntermediaryStateToDestinationStateNotif;
   *  CAADestinationStateToNULLStateNotif* _CAADestinationStateToNULLStateNotif;
   *  CATBoolean FirstPartTransitionAction(void *data);
   *  CATBoolean SecondPartTransitionAction(void *data);      
   *  CATBoolean EndCommandTransitionAction(void *data);
   *  static CAAMyStateCommandInteractionNotifier* sInteractionNotifier;        
   *  CATDialogAgent* _FirstPartDialogAgent;
   *  CATDialogAgent* _SecondPartDialogAgent;
   *  CATDialogAgent* _EndCommandDialogAgent;
   *  CATString _ScriptName;
   *};
   *#endif&lt;/pre&gt;&lt;/li&gt;
   * &lt;li&gt;CAAMyStateCommand.cpp:&lt;pre&gt;
   *#include &quot;CAAMyStateCommand.h&quot;
   *#include &quot;CAAMyStateCommandNotification.h&quot;
   *#include &quot;CATApplication.h&quot;
   *#include &quot;CATScriptUtilities.h&quot;
   *#include &quot;CATAutoConversions.h&quot;
   *#include &quot;CATDialogAgent.h&quot;
   *#include &quot;CATGetEnvValue.h&quot;
   *CAAMyStateCommandInteractionNotifier*  CAAMyStateCommand::sInteractionNotifier  = NULL;
   *int CAAMyStateCommand::sOccurenceCount = 0;
   *void CAAMyStateCommand::sRunScriptAndTriggerSecondPartTransition(
   *                        CATCommand* iCAAMyStateCommand,int iSubscribedType,
   *                        CATString* iScriptName)
   *{ CATLibStatus LibOK;
   *  CATUnicodeString FolderName;
   *  CAAIntermediaryStateToDestinationStateNotif* CAAIntermediaryStateToDestinationStateNotif = NULL;
   *  CAAMyStateCommand* MyStateCommand;
   *  CATDialogAgent* SecondPartDialogAgent = NULL;
   *  CATApplication* Application = NULL;
   *  char* CATTempValue = NULL;
   *  CATVariant VariantReturnValue;
   *  long ReturnValue;
   *  HRESULT hr;
   * 	Application = CATApplication::MainApplication();
   *  MyStateCommand = (CAAMyStateCommand*)iCAAMyStateCommand;
   *  CAAIntermediaryStateToDestinationStateNotif = 
   *    MyStateCommand-&gt;_CAAIntermediaryStateToDestinationStateNotif;
   *  SecondPartDialogAgent = MyStateCommand-&gt;_SecondPartDialogAgent;
   * 	// We run the &quot;CATMain&quot; sub of the &quot;MyScript.catvbs&quot; script located in the place specified by
   *  // the CATTemp environment variable 
   *  LibOK = CATGetEnvValue(&quot;CATTemp&quot;,&amp;CATTempValue);
   *  if (LibOK == CATLibSuccess) 
   *    { FolderName = CATTempValue; ReturnValue = 0;
   *      hr = BuildVariant((const long)ReturnValue,VariantReturnValue);
   *     	hr = CATScriptUtilities::ExecuteScript(FolderName,catScriptLibraryTypeDirectory, 
   *		                                           iScriptName-&gt;CastToCharPtr(),VariantReturnValue,
   *		                                           &quot;CATMain&quot;);
   *    }
   *  if (sOccurenceCount!=0)
   *    { // we trigger the second part transition
   *      sInteractionNotifier-&gt;Advise(SecondPartDialogAgent-&gt;GetFather(),
   *                                   MyStateCommand-&gt;_CAAIntermediaryStateToDestinationStateNotif);
   *    }
   *}
   *CAAMyStateCommand::CAAMyStateCommand():
   *  CATStateCommand (&quot;CAAMyStateCommand&quot;,CATCommandModeExclusive) 
   *  ,_FirstPartDialogAgent(NULL),_SecondPartDialogAgent(NULL)
   *{ _CAASourceStateToIntermediaryStateNotif = new CAASourceStateToIntermediaryStateNotif();
   *  _CAAIntermediaryStateToDestinationStateNotif = new CAAIntermediaryStateToDestinationStateNotif();
   *  _CAADestinationStateToNULLStateNotif = new CAADestinationStateToNULLStateNotif();
   *  sInteractionNotifier = new CAAMyStateCommandInteractionNotifier();
   *  sOccurenceCount++;
   *}
   *CAAMyStateCommand::~CAAMyStateCommand()
   *{ if (_CAASourceStateToIntermediaryStateNotif!=NULL) 
   *    { _CAASourceStateToIntermediaryStateNotif-&gt;Release(); _CAASourceStateToIntermediaryStateNotif = NULL; }
   *  if (_CAAIntermediaryStateToDestinationStateNotif!=NULL) 
   *    { _CAAIntermediaryStateToDestinationStateNotif-&gt;Release(); _CAAIntermediaryStateToDestinationStateNotif = NULL; }
   *  if (_CAADestinationStateToNULLStateNotif!=NULL) 
   *    { _CAADestinationStateToNULLStateNotif-&gt;Release(); _CAADestinationStateToNULLStateNotif = NULL; }
   *  if (_FirstPartDialogAgent!=NULL)  
   *    { _FirstPartDialogAgent-&gt;RequestDelayedDestruction(); _FirstPartDialogAgent = NULL; }
   *  if (_SecondPartDialogAgent!=NULL)  
   *    { _SecondPartDialogAgent-&gt;RequestDelayedDestruction(); _SecondPartDialogAgent = NULL; }
   *  if (_EndCommandDialogAgent!=NULL)  
   *    { _EndCommandDialogAgent-&gt;RequestDelayedDestruction(); _EndCommandDialogAgent = NULL; }
   *  if (sInteractionNotifier!=NULL) 
   *    { sInteractionNotifier-&gt;RequestDelayedDestruction(); sInteractionNotifier = NULL; }
   *  sOccurenceCount--;
   *}
   *CATStatusChangeRC CAAMyStateCommand::Activate (CATCommand* FromClient,CATNotification* EvtDat )
   *{ return (CATStatusChangeRCCompleted); }
   *CATStatusChangeRC CAAMyStateCommand::Desactivate (CATCommand* iCmd,CATNotification* iNotification)
   *{ return (CATStatusChangeRCCompleted); }
   *CATStatusChangeRC CAAMyStateCommand::Cancel (CATCommand* iCmd,CATNotification* iNotification)
   *{ return (CATStatusChangeRCCompleted); }
   *void CAAMyStateCommand::BuildGraph()
   *{ CATDialogState* SourceState = NULL;
   *  CATDialogState* IntermediaryState = NULL;
   *  CATDialogState* DestinationState = NULL;
   *  // we fill the dialog agents
   *  _FirstPartDialogAgent = new CATDialogAgent(&quot;CAASourceStateToIntermediaryStateNotif&quot;);
   *  _FirstPartDialogAgent-&gt;AcceptOnNotify(sInteractionNotifier,_CAASourceStateToIntermediaryStateNotif);
   *  _SecondPartDialogAgent = new CATDialogAgent(&quot;CAAIntermediaryStateToDestinationStateNotif&quot;);
   *  _SecondPartDialogAgent-&gt;AcceptOnNotify(sInteractionNotifier,_CAAIntermediaryStateToDestinationStateNotif);
   *  _EndCommandDialogAgent = new CATDialogAgent(&quot;CAADestinationStateToNULLStateNotif&quot;);
   *  _EndCommandDialogAgent-&gt;AcceptOnNotify(sInteractionNotifier,_CAADestinationStateToNULLStateNotif);
   *  // we fill the states
   *  SourceState = GetInitialState(&quot;CAAMyStateCommandSourceState&quot;);
   *  SourceState-&gt;AddDialogAgent(_FirstPartDialogAgent);
   *  IntermediaryState = AddDialogState(&quot;CAAMyStateCommandIntermediaryState&quot;);
   *  IntermediaryState-&gt;AddDialogAgent(_SecondPartDialogAgent);
   *  DestinationState = AddDialogState(&quot;CAAMyStateCommandDestinationState&quot;);
   *  DestinationState-&gt;AddDialogAgent(_EndCommandDialogAgent);
   *  // we fill the transitions
   *  AddTransition(SourceState,IntermediaryState,
   *                IsOutputSetCondition(_FirstPartDialogAgent),
   *    			         Action((ActionMethod) &amp;CAAMyStateCommand::FirstPartTransitionAction));
   *  AddTransition(IntermediaryState,DestinationState,
   *                IsOutputSetCondition(_SecondPartDialogAgent),
   *    			         Action((ActionMethod) &amp;CAAMyStateCommand::SecondPartTransitionAction));
   *  AddTransition(DestinationState,NULL,
   *                IsOutputSetCondition(_EndCommandDialogAgent),
   *    			         Action((ActionMethod) &amp;CAAMyStateCommand::EndCommandTransitionAction));
   *  // we trigger the first part transition
   *  sInteractionNotifier-&gt;Advise((CATDialogAgent*)_FirstPartDialogAgent-&gt;GetFather(),
   *                               _CAASourceStateToIntermediaryStateNotif);
   *}
   *CATBoolean CAAMyStateCommand::FirstPartTransitionAction(void *data)
   *{ CATApplication* Application = NULL;
   *  // insert here the actions which must be ran before the script execution
   *
   *  // we set the sRunScriptAndTriggerSecondPartTransition call-back on time-out
   * 	Application = CATApplication::MainApplication();
   *  _ScriptName = &quot;MyScript.catvbs&quot;;
   *  Application-&gt;AddTimeOut(1,this,&amp;_ScriptName,
   *                          (void(*)())sRunScriptAndTriggerSecondPartTransition);	
   *  // we prevent _FirstPartDialogAgent to be valued any more through the notification
   *  _FirstPartDialogAgent-&gt;IgnoreOnNotify(sInteractionNotifier,_CAASourceStateToIntermediaryStateNotif);
   *
   *  return TRUE;
   *}
   *
   *CATBoolean CAAMyStateCommand::SecondPartTransitionAction(void *data)
   *{ // insert here the actions which must be ran after the script execution
   *
   *  // we prevent _SecondPartDialogAgent to be valued any more through the notification
   *  _SecondPartDialogAgent-&gt;IgnoreOnNotify(sInteractionNotifier,_CAAIntermediaryStateToDestinationStateNotif);
   *  // we trigger the end command transition
   *  sInteractionNotifier-&gt;Advise(_EndCommandDialogAgent-&gt;GetFather(),_CAADestinationStateToNULLStateNotif);
   *
   *  return TRUE;
   *}
   *CATBoolean CAAMyStateCommand::EndCommandTransitionAction(void *data)
   *{ // we prevent _EndCommandDialogAgent to be valued any more through the notification
   *  _EndCommandDialogAgent-&gt;IgnoreOnNotify(sInteractionNotifier,_CAADestinationStateToNULLStateNotif);
   *  return TRUE; 
   *}&lt;/pre&gt;&lt;/li&gt;
   * &lt;/ul&gt; 
		 */
		static HRESULT __stdcall ExecuteScript(
			const CATUnicodeString&amp; iLibraryName, 
			CatScriptLibraryType iType, 
			const CATUnicodeString&amp; iProgramName, 
			CATVariant &amp; oResult,
			const CATUnicodeString&amp; iFunctionName = &quot;CATMain&quot;, 
			CATVariant* iParams = NULL, 
			unsigned int iParamCount = 0,
			unsigned int iFlags = CAT_EXECUTESCRIPT_AUTOMATIC_REPLAY_ENABLE);

		/**
		 * Returns true if a macro is currently being recorded.
		 */
		static CATBoolean __stdcall IsMacroRecorderOn();

		/**
		 * Returns true if a macro is currently being replayed.
		 */
		static CATBoolean __stdcall IsMacroPlayerOn();

		/**
		 * Returns the name of the event notification sent whenever a script begins its execution.
		 */
		static char* __stdcall GetScriptStartNotification();

		/**
		 * Returns the name of the event event notification sent whenever a script stops its execution.
		 */
		static char* __stdcall GetScriptStopNotification();

		/**
		 * Returns the name of the event event notification sent whenever a script raises an error.
		 */
		static char* __stdcall GetScriptErrorNotification();

		/**
		 * Returns the name of the event event notification sent whenever a script is interrupted.
		 */
		static char* __stdcall GetScriptInterruptNotification();

	    /**
		 * @nodoc
		 * Locks the screen to prevent user interactions while the script is running.
		 */
		static HRESULT LockScreen();

	    /**
		 * @nodoc
		 * Unlocks the screen after a LockScreen call has been made.
		 */
		static HRESULT UnlockScreen(CATBoolean iImmediateUnlock = FALSE);

	    /**
		 * @nodoc
		 * Returns TRUE if the screen is locked, FALSE otherwise.
		 */
		static HRESULT IsScreenLocked(
			CATBoolean&amp; oIsLocked);

		/**
		 * @nodoc
		 * This method transforms a CATUnicodeString into an encoded
		 * CATString (this is usefull for commands which only accept
		 * CATStrings as parameters).
		 */
		static void CATUnicodeStringToCATString(
			const CATUnicodeString&amp; iString,
			CATString&amp; oString);

		/**
		 * @nodoc
		 * This method transforms an encoded
		 * CATString encoded by CATUnicodeStringToCATString
		 * into a CATUnicodeString.
		 */
		static void CATStringToCATUnicodeString(
			const CATString&amp; iString,
			CATUnicodeString&amp; oString);

		/**
		 * @nodoc
		 * Raises an error.
		 */
		static HRESULT RaiseError(
			CATError* iError);

		/**
		 * @nodoc
		 * Returns the loaded ITypeLib and its full path name from a given typelib name.
		 */
		static HRESULT GetTypeLibPath(
			const CATUnicodeString&amp; iName,
			ITypeLib*&amp; oTypelib,
			CATUnicodeString&amp; oPathName);

		/**
		 * @nodoc
		 * Returns the directory path of the
		 * specified runtime view file. If the runtime view is
		 * a concatenation, the path returned is the leftmost
		 * choice in the concatenation.
		 * @param iFileName
		 * The file name to look for.
		 * @param iSubDirs
		 * The runtime view subdirs to look into (for instance: {code, bin})
		 * @param oDirectoryPath
		 * The runtime view directory containing the path (including code/bin).
		 */
		static HRESULT GetRuntimeViewDirectory(
			const CATUnicodeString&amp; iFileName,
			CATListOfCATUnicodeString&amp; iSubDirs,
			CATUnicodeString&amp; oDirectoryPath);

		/**
		 * @nodoc
		 * Retrieves the function with the specified name in
		 * the program.
		 */
		static HRESULT FindFunction(
			CATIScriptProgram* iProgram,
			const CATUnicodeString&amp; iFunctionName,
			CATIScriptFunction*&amp; oFunction);

		/**
		 * Sets a custom error message which will be caught by
		 * the script engines and displayed in the UI as a
		 * replacement of the default error message (&quot;The method XXX has failed&quot;).
		 * @param iMessage
		 * The error message to display
		 */
		static HRESULT SetAutomationErrorMessage(
			const CATUnicodeString&amp; iMessage);

		/**
		 * @nodoc
		 * Retrieves the IID of the V5 Automation interface
		 * given the associated VB object type.
		 * (Returns IID_CATIABase given the string &quot;AnyObject&quot;)
		 */
		static HRESULT GetAutomationUUIDFromVBName(
			const CATUnicodeString&amp; iVbInterfaceName,
			GUID&amp; oGUID);

	private:
		static CATBoolean _initialized;
		static CATListOfCATUnicodeString _languages;
		static CATListOfCATString _extensions;
#ifdef _WINDOWS_SOURCE	// Take into account that windows is case insensitive.
		static CATListOfCATString _lowercaseExtensions;
#endif

	private:
		/**
		 * Reads the languages names and extension from a resource file.
		 */
		static HRESULT _Initialize();
};

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATListOfITypeLib.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATListOfITypeLib.h</a></div>
        <div><a href="../../BSFBuildtimeData/PublicInterfaces/CATIAV5Level.html">‰∏ã‰∏ÄÈ°µ: CATIAV5Level.h ‚Üí</a></div>
    </div>
</body>
</html>