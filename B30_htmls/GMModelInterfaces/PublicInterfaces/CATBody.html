<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GMModelInterfaces/PublicInterfaces/CATBody.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GMModelInterfaces/PublicInterfaces/CATBody.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CAATopCheckForPartType.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAATopCheckForPartType.h</a></div>
        <div><a href="CATBodyFreezeMode.html">‰∏ã‰∏ÄÈ°µ: CATBodyFreezeMode.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATBody_H
#define CATBody_H

// COPYRIGHT DASSAULT SYSTEMES  1999

/**
 * @CAA2Level L1
 * @CAA2Usage U3
 */

#include &quot;CATTopObject.h&quot;
#include &quot;CATDomain.h&quot;
#include &quot;CATCellHashTable.h&quot;

#include &quot;ListPOfCATCell.h&quot;
#include &quot;ListPOfCATFace.h&quot;
#include &quot;ListPOfCATEdge.h&quot;
#include &quot;ListVOfLong.h&quot;
#include &quot;CATMathDef.h&quot;
#include &quot;ListPOfCATConnectedCellsIterator.h&quot;
#include &quot;CATTopData.h&quot;
#include &quot;CATIAV5Level.h&quot;

class CATMathVector;
class CATSurface;

class CATGeoFactory;
class CATCell;
class CATVolume;
class CATFace;
class CATEdge;
class CATVertex;
class CATDomain;
class CATLump;
class CATShell;
class CATWire;
class CATVertexInVolume;
class CATLoop;
class CATVertexInFace;

class CATSmartBodyDuplicator;
class CATICGMSmartBodyDuplicator;
class CATCGMJournalList;

#include &quot;CATGMModelInterfaces.h&quot;
#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATGMModelInterfaces IID IID_CATBody ;
#else
extern &quot;C&quot; const IID IID_CATBody ;
#endif

/**
 * Interface representing a topological body.
 *&lt;br&gt;
 * A body is a set of cells with the following conditions:
 *&lt;ul&gt;&lt;li&gt;If one of the cells belongs to the body, all the bounding cells also
 *        belong to this body.
 *    &lt;li&gt;If two cells of a same body are intersecting together, their
 *        intersection is a set of cells belonging to this body.
 *     &lt;li&gt; Cells can be shared between several bodies.
 *&lt;/ul&gt;
 *This interface is dedicated to represent all kind of cell-complexes including
 * non-manifold, non connected complexes, mixing dimensions of topological cells.
 * The boundaries of a body are grouped into
 * domains (CATDomain), connected sets of cells (CATCell) of same
 * dimension. This definition is unique.
 *&lt;ul&gt;&lt;li&gt;a vertex can border:
 *         &lt;ul&gt;&lt;li&gt;an egde (the vertex is one of the edge extremities)
 *             &lt;li&gt;a face ( the vertex is immersed inside the face:
 * non manifold case -&gt; &lt;tt&gt;CATVertexInFace&lt;/tt&gt; domain )
 *             &lt;li&gt;a volume or a body ( the vertex is immersed into the volume:
 * non manifold case -&gt; &lt;tt&gt;CATVertexInVolume&lt;/tt&gt; domain) &lt;/ul&gt;
 *    &lt;li&gt;an edge may border:
 *         &lt;ul&gt;&lt;li&gt;a face ( the edge is one of the face borders
 * -&gt; &lt;tt&gt;CATLoop&lt;/tt&gt; domain)
 *             &lt;li&gt;a face ( the edge is immersed inside the face:
 * non manifold case -&gt; &lt;tt&gt;CATLoop&lt;/tt&gt; domain)
 *             &lt;li&gt;a volume or a body( the edge is immersed inside the volume:
 * non manifold case -&gt; &lt;tt&gt;CATWire&lt;/tt&gt; domain) &lt;/ul&gt;
 *    &lt;li&gt;an face may border (-&gt; &lt;tt&gt;CATShell&lt;/tt&gt; domain ):
 *         &lt;ul&gt;&lt;li&gt;a volume ( the face is one of the volume borders)
 *             &lt;li&gt;a volume ( the face is immersed into the volume:
 * non manifold case) &lt;/ul&gt;
 *    &lt;li&gt;a &lt;tt&gt;CATLump&lt;/tt&gt; is a domain of dimension 3.
 *&lt;/ul&gt;
 * Note that a vertex can not be immersed inside an egde, because it would cut
 * the edge in two pieces. As the same manner, an edge (/face) or a set
 * of edges (/faces) may be immersed inside a face (/volume) only if it does
 * not go right through it.
 * A CATCell is composed of CATDomains of lower dimension.
 * The CATBody interface is the factory of all domains and cells that it owns.
 * A CATBody is created with the
 *  @href CATGeoFactory#CreateBody method and deleted with the @href CATICGMContainer#Remove method.
 */
class ExportedByCATGMModelInterfaces CATBody : public CATTopObject
{
  CATDeclareInterface;

public:
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //            C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;


  //----------------------------------------------------------------------
  // CATBody As Cell&#x27;s Factory
  //----------------------------------------------------------------------

/**
 * Creates a topological cell of a given dimension.
 * @param iDimension
 * &lt;dl&gt;&lt;dt&gt;0&lt;/dt&gt;&lt;dd&gt; Creates a CATVertex
 *    &lt;dt&gt;1&lt;/dt&gt;&lt;dd&gt; Creates a CATEdge
 *    &lt;dt&gt;2&lt;/dt&gt;&lt;dd&gt; Creates a CATFace
 *    &lt;dt&gt;3&lt;/dt&gt;&lt;dd&gt; Creates a CATVolume &lt;/dl&gt;
 */
  virtual CATCell     * CreateCell( short iDimension )=0;

/**
 * Creates a volume.
 * @return
 * The pointer to the created volume (cell of dimension 3)
 */
  virtual CATVolume   * CreateVolume()=0;

/**
 * Creates a face.
 * @return
 * The pointer to the created face (cell of dimension 2)
 */
  virtual CATFace     * CreateFace()=0;

/**
 * Creates an edge.
 * @return
 * The pointer to the created edge (cell of dimension 1)
 */
  virtual CATEdge     * CreateEdge()=0;

/**
 * Creates a vertex.
 * @return
 * The pointer to the created vertex (cell of dimension 0)
 */
  virtual CATVertex   * CreateVertex()=0;


  //----------------------------------------------------------------------
  // CATBody As Domains&#x27;s Factory
  //----------------------------------------------------------------------

/**
 * Creates a topological domain.
 *&lt;br&gt;A CATDomain is composed of connected cells
 * of same dimension. It represents a cell boundary.
 * @param iContainedCellsDimension
 * The dimension of the cells contained into the domain to create.
 * @param iContainingCellDimension
 * The dimension of the unique cell containing the domain to create.
 *&lt;br&gt; Note that &lt;tt&gt;iContainedCellDimension &lt;= iContainingCellDimension&lt;/tt&gt;.
 * For a CATDomain contained into a CATBody, this dimension is 3.
 * @param iLocation
 * The location of the contained cells relative to the containing cell.
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (holes
 * into a faces or cavities into a volumes).
 *     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
 *     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
 * create are immersed into the containing cell (non-manifold topology).
 *     &lt;dt&gt;&lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For creation into a body.
 *&lt;/dl&gt;
 */
  virtual CATDomain   * CreateDomain( short iContainedCellsDimension,
    short iContainingCellDimension=3,
    CATLocation iLocation=CATLocationIn3DSpace)=0;

/**
 * Creates a topological domain (called lump) which contained cells are CATVolumes.
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 3,
 * iContainingCellDimension = 3&lt;/tt&gt;.
 * @return
 * The pointer to the created lump.
 */
  virtual CATLump           * CreateLump()=0;

/**
 * Creates a topological domain (called shell) which contained connected cells are CATFaces.
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 2,
 * iContainingCellDimension = 3&lt;/tt&gt;.
 * @param iLocation
 * The location of the contained cells relative to the containing cell.
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (
 * cavities into volumes).
 *     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
 *     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
 * create are immersed into the containing cell (non-manifold topology).
 *     &lt;dt&gt;&lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For creation into a body.
 *&lt;/dl&gt;
 * @return
 * The pointer to the created shell.
 */
  virtual CATShell          * CreateShell( CATLocation iLocation)=0;

/**
 * Creates a topological domain representing a set of connected edges (called wire) of a
 * body or a volume.
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 1,
 * iContainingCellDimension = 3&lt;/tt&gt;.
 * @return
 * The pointer to the created wire.
 */
  virtual CATWire           * CreateWire()=0;

/**
 * Creates a topological domain representing a vertex immersed inside a volume.
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 0,
 * iContainingCellDimension = 3&lt;/tt&gt;.
 * @return
 * The pointer to the created VertexInVolume domain.
 */
  virtual CATVertexInVolume * CreateVertexInVolume()=0;

/**
 * Creates a topological domain (called loop) representing a set of connected egdes bounding
 * a face .
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 1,
 * iContainingCellDimension = 2&lt;/tt&gt;. The loop may be closed or not.
 * @param iLocation
 * The location of the contained cells relative to the containing cell.
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (holes
 * into a faces).
 *     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
 *     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
 * create are immersed into the containing cell (non-manifold topology).
 *&lt;/dl&gt;
 * @return
 * The pointer to the created loop.
 */
  virtual CATLoop           * CreateLoop( CATLocation iLocation)=0;

/**
 * Creates a topological domain representing a vertex immersed inside a face.
 * &lt;br&gt;It corresponds to &lt;tt&gt;iContainedCellsDimension = 0,
 * iContainingCellDimension = 2&lt;/tt&gt;.
 * @return
 * The pointer to the created VertexInFace domain.
 */
  virtual CATVertexInFace   * CreateVertexInFace()=0;


  //----------------------------------------------------------------------
  // CATBody Constuction Management
  //----------------------------------------------------------------------
 /**
 * Adds a CATDomain to &lt;tt&gt;this&lt;/tt&gt; CATBody.
 * @param iDomainToAdd
 * The pointer to the domain to add, which location must be set to
 * &lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;.
 * @param iLocation
 * The location of the domain to bound &lt;tt&gt;this&lt;/tt&gt;.
 */
  virtual void AddDomain( CATDomain * iDomainToAdd, CATLocation iLocation=CATLocationIn3DSpace  )=0;


/**
 * Creates a smart duplicator.
 *&lt;br&gt;This is used in the context of the &quot;smart mechanism&quot;.
 *   When a body is frozen, the cells and domains that it contains cannot be modified anymore.
 * To allow an operator to operate on cells of a frozen body,
 *   the smart duplicator only duplicates the touched cells and
 *   domains. Hence:
 *&lt;ul&gt;
 *    &lt;li&gt; This is used to duplicate or share cells and domains from &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; into &lt;tt&gt;this&lt;/tt&gt;.
 *    &lt;li&gt; a cell or domain will be duplicated if it is non-modifiable and touched,
 *      otherwise, it will be shared
 *    &lt;li&gt; &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; and &lt;tt&gt;this&lt;/tt&gt; can be the same body.
 *&lt;/ul&gt;
 * @param iBodyToRecopy
 * The frozen body where cells are touched.
 * @param iTopData
 * The object defining the CATSoftwareConfiguration and the CATCGMJournalList.
 * @return
 * The pointer to the created duplicator. After use, you
 * have to &lt;tt&gt;delete&lt;/tt&gt; it.
 * @see CATSmartBodyDuplicator
 */
  virtual CATSmartBodyDuplicator*  CreateSmartDuplicator(CATBody* iBodyToRecopy, CATTopData &amp;iTopData)=0;

/**
 * Creates a smart duplicator.
 *&lt;br&gt;This is used in the context of the &quot;smart mechanism&quot;.
 *   When a body is frozen, the cells and domains that it contains cannot be modified anymore.
 * To allow an operator to operate on cells of a frozen body,
 *   the smart duplicator only duplicates the touched cells and
 *   domains. Hence:
 *&lt;ul&gt;
 *    &lt;li&gt; This is used to duplicate or share cells and domains from &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; into &lt;tt&gt;this&lt;/tt&gt;.
 *    &lt;li&gt; a cell or domain will be duplicated if it is non-modifiable and touched,
 *      otherwise, it will be shared
 *    &lt;li&gt; &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; and &lt;tt&gt;this&lt;/tt&gt; can be the same body.
 *&lt;/ul&gt;
 * @param iBodyToRecopy
 * The frozen body where cells are touched.
 * @param iTopData
 * The object defining the CATSoftwareConfiguration and the CATCGMJournalList.
 * @return [out, IUnknown#Release]
 * The pointer to the created duplicator. After use, you
 * have to &lt;tt&gt;Release&lt;/tt&gt; it.
 * @see CATICGMSmartBodyDuplicator
 */
  virtual CATICGMSmartBodyDuplicator*  CreateISmartDuplicator(CATBody* iBodyToRecopy, CATTopData &amp;iTopData)=0;

  //----------------------------------------------------------------------
  // CATBody Specialized Analysis Services
  //----------------------------------------------------------------------

  /**
  *  Gets information on the dimensions in &lt;tt&gt;this&lt;/tt&gt; body.
  *  @param ioCellsMaxDim
  * The maximum dimension of the cells.
  *  @param ioIsHomogeneous
  * The homogeneity in dimension.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;Every domain at the higest level has the same dimension &lt;tt&gt;ioCellsMaxDim&lt;/tt&gt;.
  *      &lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt; &lt;dd&gt;otherwise.&lt;/dl&gt;
  *  @param IsLocallyManifold
  * If not &lt;tt&gt;NULL&lt;/tt&gt;, it will be filled by :
  *  &lt;dl&gt;&lt;dt&gt; &lt;tt&gt;TRUE&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;if &lt;tt&gt;ioIsHomogeneous&lt;/tt&gt; is &lt;tt&gt;TRUE&lt;/tt&gt;
  * and the body is locally &lt;tt&gt;ioCellsMaxDim&lt;/tt&gt;-Manifold
  *  &lt;dt&gt; &lt;tt&gt;FALSE&lt;/tt&gt;&lt;/dt&gt; &lt;dd&gt;otherwise&lt;/dl&gt;
  *  @param oNonManifoldCells
  * The optional pointer to a list containing the cells that lead to a non manifold context.
  */
  virtual void GetCellsHighestDimension(CATLONG32&amp; ioCellsMaxDim,CATBoolean&amp; ioIsHomogeneous,
    CATBoolean* ioIsLocallyManifold = NULL, ListPOfCATCell * oNonManifoldCells = NULL) = 0;

/**
 * Retrieves the number of manifold domains inside a list of cells.
 * @param iCellList
 * The pointer to the list of cells to handle.
 * @param oNbOfCellsByDomain
 * The number of manifold groups.
 */
  virtual CATLISTP(CATCell) GroupCells(const CATLISTP(CATCell) * iCellList,
    CATListOfLong          &amp; ioNbOfCellsByDomain ) = 0;


/**
 * Tests whether &lt;tt&gt;this&lt;/tt&gt; CATBody is lying on another one.
 * @param iDomain
 * The body on which &lt;tt&gt;this&lt;/tt&gt; may lay.
 * @return
 * The diagnosis of the test.
 */
  virtual CATTopLyingOnDiagnostic IsLyingOn(CATBody* iDomain) = 0;


/**
 * @nodoc
 * @deprecated V5R14 Completed.
 * &lt;br&gt;Use now @href CATICGMObject#Completed with the &lt;tt&gt;TRUE&lt;/tt&gt; value.
 * Freezes the contents of &lt;tt&gt;this&lt;/tt&gt; body.&lt;br&gt; Further modifications of this
 * body will imply that all modified elements will be copied first,
 * thus keeping the current body state unmodified.
 */
  virtual void Freeze() = 0;



  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //               N O N - C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;


/**
 * @nodoc
 * Returns the implicit factory associated with &lt;tt&gt;this&lt;/tt&gt; CATBody.
 */
  virtual CATGeoFactory * GetFactory() = 0;

  /**
   * @nodoc
	 * Clean touched topology inside &lt;tt&gt;this&lt;/tt&gt;.
	 * @see CATSmartBodyDuplicator
	 */
  virtual void CleanTouch() = 0;


/**
 * @nodoc
 * Creates a smart duplicator.
 *&lt;br&gt;This is used in the context of the &quot;smart mechanism&quot;.
 *   When a body is frozen, the cells and domains that it contains cannot be modified anymore.
 * To allow an operator to operate on cells of a frozen body,
 *   the smart duplicator only duplicates the touched cells and
 *   domains. Hence:
 *&lt;ul&gt;
 *    &lt;li&gt; This is used to duplicate or share cells and domains from &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; into &lt;tt&gt;this&lt;/tt&gt;.
 *    &lt;li&gt; a cell or domain will be duplicated if it is non-modifiable and touched,
 *      otherwise, it will be shared
 *    &lt;li&gt; &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; and &lt;tt&gt;this&lt;/tt&gt; can be the same body.
 *&lt;/ul&gt;
 * @param iBodyToRecopy
 * The frozen body where cells are touched.
 * @param iReport
 * The pointer to a journal that logs the duplication. If &lt;tt&gt;NULL&lt;/tt&gt;, nothing is written.
 * @return
 * The pointer to the created duplicator. After use, you
 * have to &lt;tt&gt;delete&lt;/tt&gt; it.
 * @see CATSmartBodyDuplicator
 */
  virtual CATSmartBodyDuplicator*  CreateSmartDuplicator(CATBody* iBodyToRecopy, CATCGMJournalList* iReport=NULL)=0;

/**
 * @nodoc
 * Creates a smart duplicator.
 *&lt;br&gt;This is used in the context of the &quot;smart mechanism&quot;.
 *   When a body is frozen, the cells and domains that it contains cannot be modified anymore.
 * To allow an operator to operate on cells of a frozen body,
 *   the smart duplicator only duplicates the touched cells and
 *   domains. Hence:
 *&lt;ul&gt;
 *    &lt;li&gt; This is used to duplicate or share cells and domains from &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; into &lt;tt&gt;this&lt;/tt&gt;.
 *    &lt;li&gt; a cell or domain will be duplicated if it is non-modifiable and touched,
 *      otherwise, it will be shared
 *    &lt;li&gt; &lt;tt&gt;iBodyToRecopy&lt;/tt&gt; and &lt;tt&gt;this&lt;/tt&gt; can be the same body.
 *&lt;/ul&gt;
 * @param iBodyToRecopy
 * The frozen body where cells are touched.
 * @param iReport
 * The pointer to a journal that logs the duplication. If &lt;tt&gt;NULL&lt;/tt&gt;, nothing is written.
 * @return [out, IUnknown#Release]
 * The pointer to the created duplicator. After use, you
 * have to &lt;tt&gt;Release&lt;/tt&gt; it.
 * @see CATSmartBodyDuplicator
 */
  virtual CATICGMSmartBodyDuplicator*  CreateISmartDuplicator(CATBody* iBodyToRecopy, CATCGMJournalList* iReport=NULL)=0;

  //-----------------------------------------------------------------------------------
  // Propagation types  describe the way edges or faces are selected by propagation.
  //------------------------------------------------------------------------------------
/** @nodoc */
  enum CATPropagationTypePr3 {CATEdgePropagManual=0, CATEdgePropagAuto=1, CATEdgePropagStopOnCorner=2, CATEdgePropagUnknown=666};
/** @nodoc */
  enum CATReflectPropagationType {CATStandard, CATKeepEdge, CATKeepFace};

/**
 * @nodoc
 *  Tangency Propagation on &lt;tt&gt;this&lt;/tt&gt; body
 */
  virtual CATLISTP(CATCell) CATEdgePropagate(CATLISTP(CATCell) * iInitialEdges,
    CATPropagationTypePr3 iPropagationType,
	CATLISTP(CATEdge) * iRollingEdges = NULL) = 0;
 /** @nodoc */
  virtual CATLISTP(CATFace) CATFacePropagate(CATLISTP(CATFace) * iInitialFaces) = 0;


/**
 * @nodoc
 * Groups the list of cells in connex and manifold groups (cells of dimension N connected by
 * cells of dimension N-1).
 * @param iCellList
 * The pointer to the list of cells to handle.
 * @param ioCellsIterator
 * The pointer to the iterator on the manifold groups.
 */
  virtual void GroupCells(const CATLISTP(CATCell) * iCellList,
    CATLISTP(CATConnectedCellsIterator) &amp; ioCellsIterator ) = 0;


/**
 * @nodoc
 * Returns the list of edges bounding at least one face in each specified list of faces
 */
  virtual CATLISTP(CATCell) CommonEdges(const CATLISTP(CATCell) * iFaceList_1,
    const CATLISTP(CATCell) * iFaceList_2,
    CATListOfLong          &amp; oListOrientation,
    CATListOfLong          &amp; oNbOfEdgesByDomain ) = 0;


/**
 * @nodoc
 * Returns the immediate neighbour cells of same dimension of the specified cells&#x27; list
 */
  virtual CATLISTP(CATCell) CellNeighbours(const CATLISTP(CATCell) * iCellList,
    const CATListOfLong     * iListOrientation,
    CATListOfLong           &amp; oNbOfCellsByDomain,
    const short iVersionGenericNaming = 0 ) = 0;

/**
 * @nodoc
 * Returns the edges frontier of the specified cells&#x27; list.
 */
  virtual CATLISTP(CATCell) SelectEdgesFromFaces(const CATLISTP(CATFace) * iFaceList) = 0;


/**
 * @nodoc
 * Special method for Reflect Line Propagation
 */
  virtual CATLISTP(CATFace) FacePropagateReflectLine(CATReflectPropagationType  Propagation,
    const CATMathVector        &amp;PullingDirection,
    const CATAngle            &amp;Angle,
    const CATLISTP(CATFace)   *iInitialFaces) = 0;

/**
 * @nodoc
 * Checks the intersections between the wires of &lt;tt&gt;this&lt;/tt&gt; body.
 * @param iSurface
 * The pointer to the surface on which the wire is laying on (if it is).
 */
  virtual CATBoolean CheckWiresIntersection(CATSurface *iSurface = NULL) = 0;

};


CATDeclareHandler(CATBody,CATTopology);

#endif
</div>
    
    <div class="navigation">
        <div><a href="CAATopCheckForPartType.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAATopCheckForPartType.h</a></div>
        <div><a href="CATBodyFreezeMode.html">‰∏ã‰∏ÄÈ°µ: CATBodyFreezeMode.h ‚Üí</a></div>
    </div>
</body>
</html>