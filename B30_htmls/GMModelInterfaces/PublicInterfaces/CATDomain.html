<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GMModelInterfaces/PublicInterfaces/CATDomain.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GMModelInterfaces/PublicInterfaces/CATDomain.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATDistanceType.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATDistanceType.h</a></div>
        <div><a href="CATDynExtrapolationToolsDef.html">‰∏ã‰∏ÄÈ°µ: CATDynExtrapolationToolsDef.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATDomain_H
#define CATDomain_H

// COPYRIGHT DASSAULT SYSTEMES  1999

/**
* @CAA2Level L1
* @CAA2Usage U3
*/ 

#include &quot;CATGMModelInterfaces.h&quot;
#include &quot;CATTopology.h&quot;  
//#include &quot;CATTopDef.h&quot;
#include &quot;CATTopDefine.h&quot;
#include &quot;CATCellHashTable.h&quot;
class CATMathBox;
class CATCell;
class CATBody;

//-----------------------------------------------------------------------------
#include &quot;CATGMModelInterfaces.h&quot;
#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATGMModelInterfaces IID IID_CATDomain ;
#else
extern &quot;C&quot; const IID IID_CATDomain ;
#endif

/**
* Interface representing a topological domain.
* &lt;br&gt;A 
* domain (CATDomain) is a connected set of cells (CATCell) of same
* dimension. Hence, a domain defines a boundary of a cell:
*&lt;ul&gt;&lt;li&gt;a vertex can border:
*         &lt;ul&gt;&lt;li&gt;an egde (the vertex is one of the edge extremities)
*             &lt;li&gt;a face ( the vertex is immersed into the face:
* non manifold case -&gt; &lt;tt&gt;CATVertexInFace&lt;/tt&gt; domain )
*             &lt;li&gt;a volume or a body ( the vertex is immersed into the volume: 
* non manifold case -&gt; &lt;tt&gt;CATVertexInVolume&lt;/tt&gt; domain) &lt;/ul&gt;
*    &lt;li&gt;an edge can border:
*         &lt;ul&gt;&lt;li&gt;a face ( the edge is one of the face borders
* -&gt; &lt;tt&gt;CATLoop&lt;/tt&gt; domain)
*             &lt;li&gt;a face ( the edge is immersed into the face:
* non manifold case -&gt; &lt;tt&gt;CATLoop&lt;/tt&gt; domain)
*             &lt;li&gt;a volume or a body( the edge is immersed into the volume: 
* non manifold case -&gt; &lt;tt&gt;CATWire&lt;/tt&gt; domain) &lt;/ul&gt;
*    &lt;li&gt;an face can border (-&gt; &lt;tt&gt;CATShell&lt;/tt&gt; domain ):
*         &lt;ul&gt;&lt;li&gt;a volume ( the face is one of the volume borders)
*             &lt;li&gt;a volume ( the face is immersed into the volume: 
* non manifold case) &lt;/ul&gt;
*    &lt;li&gt;a &lt;tt&gt;CATLump&lt;/tt&gt; is a domain of dimension 3.
*&lt;/ul&gt;
* Note that a vertex can not be immersed into an egde, because it would cut
* the edge in two pieces. As the same manner, an edge (/face) or a set
* of edges (/faces) may be immersed into a face (/volume) only if it does
* not go right through it.&lt;br&gt;
* A CATDomain is contained into an unique CATCell of higher dimension and is
* located with regards to this cell in the following manner:
* &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (holes 
* into a faces or cavities into a volumes).
*     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
*     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
* create are immersed into the containing cell (non-manifold topology).
*     &lt;dt&gt;&lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For creation into a body.&lt;/dl&gt;
* &lt;br&gt;A CATDomain is created with the @href CATBody#CreateDomain method and
* deleted with the @href CATICGMContainer#Remove method.
*/ 
class ExportedByCATGMModelInterfaces CATDomain : public CATTopology
{
  
  CATDeclareInterface;
  
public:
  
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //            C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  
/**
* Returns the dimension of the CATCells contained into &lt;tt&gt;this&lt;/tt&gt; CATDomain.
* @return
* The dimension.
  */
  virtual short GetLowDimension()=0;
  
  
  /**
  * Returns the dimension of the unique CATCell containing &lt;tt&gt;this&lt;/tt&gt; CATDomain. 
  * @return
  * The dimension. If the domain is directly referred by a CATBody, it returns 3.
  */
  virtual short GetHighDimension()=0;
  
  /**
  * Returns the location of &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @param iBodyOrCell
  * The pointer to the Body or Cell, &lt;tt&gt;this&lt;/tt&gt; CATDomain belongs to.
  * @return
  * The location.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (holes 
  * into a faces or cavities into a volumes).
  *     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
  *     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
  * create are immersed into the containing cell (non-manifold topology).
  *     &lt;dt&gt;&lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For creation into a body.
  *&lt;/dl&gt;
  */
  virtual CATLocation GetLocation(CATTopology* iBodyOrCell = NULL)=0;
  
  /**
  * Sets the default location of &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @param iLocation
  * The location.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATLocationInner&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For internal boundaries (holes 
  * into a faces or cavities into a volumes).
  *     &lt;dt&gt;&lt;tt&gt;CATLocationOuter&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For external boundaries.
  *     &lt;dt&gt;&lt;tt&gt;CATLocationFull&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; All cells of the domain to
  * create are immersed into the containing cell (non-manifold topology).
  *     &lt;dt&gt;&lt;tt&gt;CATLocationIn3DSpace&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; For creation into a body.
  *&lt;/dl&gt;
  */
  virtual void SetLocation( CATLocation iLocation )=0;
  
  /**
  * Returns the unique CATCell that owns &lt;tt&gt;this&lt;/tt&gt; CATDomain in the context of a CATBody.
  * @param iInBody
  * The pointer to the body in which the bounded cells are searched. Recall
  * that a same CATCell can be used by several bodies.
  * @return
  * The pointer to the found CATCell.
  */
  virtual CATCell   * GetOwningCell(CATBody *iInBody) const=0;
  
  /**
  * Adds a CATCell into &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @param iCellToAdd
  * The pointer to the cell to add.
  * @param iOrientation
  * The cell orientation, with regards to the domain orientation.
  */
  virtual void      AddCell(CATCell * iCellToAdd, CATOrientation iOrientation=CATOrientationPositive )=0;
  
  /**
  * Removes a CATCell from &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @param iCellToDetach
  * The pointer to the cell to detach from &lt;tt&gt;this&lt;/tt&gt;domain. 
  * However, the cell still remains in the CATGeoFactory in default mode.
  * @param iRemoveFromFactory
  * The action on the detached cell &lt;tt&gt;iDomainToDetach&lt;/tt&gt;.
  * Dedicated to the case where no more CATDomain refers to &lt;tt&gt;iCellToDetach&lt;/tt&gt;.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; the &lt;tt&gt;iCellToDetach&lt;/tt&gt; remains in the factory
  *     &lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; the &lt;tt&gt;iCellToDetach&lt;/tt&gt; is removed from the factory with RemoveDependancies management&lt;/dl&gt;
  */
  virtual void      RemoveCell( CATCell * iCellToDetach, CATBoolean iRemoveFromFactory = FALSE  )=0;
  
  /**
  * Returns the number of CATCells used by &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @return
  * The number of used cells. If one cell is 
  * used more than once within the domain, it is counted twice. The scan is
  * not recursive.
  */
  virtual CATLONG32      GetNbCellUses()=0;
  
  /**
  * Returns the given CATCell of &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  *&lt;br&gt;The scan is not recursive.
  * @param iNumCell
  * The cell rank (starting at 1).
  * @param ioOrientation
  * A pointer to the cell orientation. If &lt;tt&gt;NULL&lt;/tt&gt;,
  * this argument is not filled out.
  * @return
  * The pointer to the corresponding cell.
  */
  virtual CATCell * GetCell( CATLONG32 iNumCell, CATOrientation * oOrientation=NULL )=0;
  
  /**
  * Returns the rank (starting at 1) of the CATCell in &lt;tt&gt;this&lt;/tt&gt; CATomain. .
  * @param iCell
  * The pointer to cell.
  * @param ioOrientation
  * A pointer to the cell orientation. If &lt;tt&gt;NULL&lt;/tt&gt;,
  * this argument is not filled out.
  * @return 
  * The result of the search.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 1 if found, 0 if not found.
  */
  virtual CATLONG32      GetCellRank(CATCell* iCell, CATOrientation * ioOrientation=NULL )=0;
  
  
  /**
  * Tests whether a CATCell belongs to &lt;tt&gt;this&lt;/tt&gt; CATDomain.
  * @param iCellToTest
  * The pointer to the cell to test.
  * @param ioSide
  * The pointer to the matter side at the boundary.
  * If &lt;tt&gt;NULL&lt;/tt&gt;, this argument is not filled out.
  * @return
  * How many times &lt;tt&gt;iCell&lt;/tt&gt; bounds &lt;tt&gt;this&lt;/tt&gt;.
  */
  virtual int Owns(CATCell* iCellToTest,CATSide* ioSide=NULL)=0;
  
  
  /**
  * Tests whether &lt;tt&gt;this&lt;/tt&gt; CATDomain is lying on another one.
  * @param iDomain
  * The pointer to the other domain.
  * @return
  * The result of the test.
  */
  virtual CATTopLyingOnDiagnostic IsLyingOn(CATDomain* iDomain) = 0;
  
  /**
  * Reverses the order or the orientation in &lt;tt&gt;this&lt;/tt&gt; domain where the cells are defined.
  *&lt;table&gt;
  *      &lt;tr&gt;&lt;td&gt;Wire, Loop : &lt;/td&gt; &lt;td&gt;the edge order is reversed&lt;/td&gt;&lt;/tr&gt;
  *      &lt;tr&gt;&lt;td&gt;Shell      : &lt;/td&gt; &lt;td&gt;the face orientations in the shell are reversed&lt;/td&gt;&lt;/tr&gt;
  *      &lt;tr&gt;&lt;td&gt;otherwise : &lt;/td&gt; &lt;td&gt; nothing happens&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
  * &lt;br&gt; To define a valid loop, the edges must be set counter-
  * clockwise for an outer loop and clockwise for an inner loop.
  */
  virtual void Invert() = 0;
  
};

CATDeclareHandler(CATDomain,CATTopology);

#endif // CATDomain_H
</div>
    
    <div class="navigation">
        <div><a href="CATDistanceType.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATDistanceType.h</a></div>
        <div><a href="CATDynExtrapolationToolsDef.html">‰∏ã‰∏ÄÈ°µ: CATDynExtrapolationToolsDef.h ‚Üí</a></div>
    </div>
</body>
</html>