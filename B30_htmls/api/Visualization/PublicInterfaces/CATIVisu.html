<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualization/PublicInterfaces/CATIVisu.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Visualization/PublicInterfaces/CATIVisu.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIVisVrmlSettingAtt.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIVisVrmlSettingAtt.h</a></div>
        <div><a href="CATIVisuFilter.html">‰∏ã‰∏ÄÈ°µ: CATIVisuFilter.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATIVISU_H
#define CATIVISU_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U6
 */

#include &quot;CATVisualization.h&quot;
#include &quot;CATBaseUnknown.h&quot;


class CATRep;
class CATPickPath;
class CATNotification;
class CATPathElement;
class CATRepPath;
class CATVisRepContext;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATVisualization IID IID_CATIVisu;
#else
extern &quot;C&quot; const IID IID_CATIVisu;
#endif
/** 
 * Basic class of any visualization interface used to make objects visualized.
 * &lt;b&gt;Role&lt;/b&gt;: This is the basic class that any visualization interface has to C++ 
 * derive from. 
 * &lt;br&gt;Components that implement any specialized &lt;tt&gt;CATIVisu&lt;/tt&gt; interface 
 * are able to be visualized and  highlighted. 
 * &lt;br&gt;&lt;br&gt;All visualization mecanisms are controlled by the @href CATVisManager. 
 * &lt;br&gt;&lt;br&gt;&lt;b&gt;How to create the specialized interface:&lt;/b&gt;
 * &lt;br&gt; The new interface is named IMyNewVisu. 
 * &lt;ul&gt;
 * &lt;li&gt;The new interface must C++ derives from &lt;tt&gt;CATIVisu&lt;/tt&gt; &lt;/li&gt;
 * &lt;br&gt;Extract from IMyNewVisu.h
 * &lt;pre&gt;
 *    .....
 *    class  IMyNewVisu : public &lt;b&gt;CATIVisu&lt;/b&gt;
 *    {
 *      CATDeclareInterface;
 *      public: 
 *         ....
 *    } ; 
 *
 * &lt;/pre&gt;
 * &lt;li&gt;The new interface must OM-derives from @href CATBaseUnknown &lt;/li&gt;
 * &lt;br&gt;Extract from IMyNewVisu.cpp
 * &lt;pre&gt;
 *    CATImplementInterface(IMyNewVisu, &lt;b&gt;CATBaseUnknown&lt;/b&gt;);
 * &lt;/pre&gt;
 * &lt;/ul&gt;
 * This allows you to make a given component implement several visualization 
 * interfaces.
 * &lt;br&gt;&lt;br&gt;&lt;b&gt;Caution:&lt;/b&gt;A specialized interface must never derive from an another one. The  interface must always 
 * derive from &lt;tt&gt;CATIVisu&lt;/tt&gt;. In particular, do not derive from @href CATI3DGeoVisu or 
 * @href CATI2DGeoVisu to create a 3D ou 2D visualization interface.
 * &lt;br&gt;&lt;br&gt;To implement the specialized interface used the @href CATExtIVisu adapter.
 */
class ExportedByCATVisualization CATIVisu : public CATBaseUnknown
{
  CATDeclareInterface;

  public :
 
  /**
   * Builds the graphical representation.
   * @return 
   * A pointer to the graphical representation of one extension of any visualization interface.
   */
  virtual CATRep * BuildRep () = 0 ;

 /**
  * Returns the pointer of the graphical representation.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: With this method you get the graphic representation for this interface. But in most
  * case to get it you must use the @href CATVisManager#GenerateRepPathFromPathElement. 
  */
  virtual CATRep * GiveRep () = 0 ;

  /**
   * @nodoc
   */
  virtual HRESULT GiveContextualRep( CATVisRepContext &amp; iContext, CATRep *&amp; oRep ) = 0;

  /**
   * Processes visualization notifications.
   * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: 
   * It is the usual method called by the @href CATVisManager for processing 
   * all types of visu notifications concerning 
   * any graphical change of one component. Such visu notifications have to derive from @href CATModify. 
   * For instance
   * when the color of one component is changed, a visualization event @href CATModifyVisProperties is 
   * sent, then received by the 
   * @href CATVisManager and finally processed by any visualization extension of the component through 
   * the &lt;tt&gt;ModifyRep&lt;/tt&gt; method. 
   *
   * @param iInfo
   * the input visu event deriving from @href CATModify
   * 
   * @return
   * status of processing:
   * &lt;ul&gt;
   * &lt;li&gt; 0 when the input visu event has not been processed &lt;/li&gt;
   * &lt;li&gt; 1 when the input visu event has been procesed &lt;/li&gt;
   * &lt;/ul&gt;
   */
  virtual int ModifyRep ( const CATNotification &amp; iInfo ) = 0 ;

 /**
  * Makes visualization extension not point to their graphical representation anymore and conversely.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;:
  * When one graphical representation is deleted, the @href CATVisManager provides a mechanism which ensures to find
  * the component and the visualization interface to which the deleting graphical representation is linked. This operation
  * can be done thanks to the model identifier enclosed into the graphical representation.
  * Then it is possible to update the corresponding visualization extension: this is typically where   
  * the @href #UnreferenceRep method is useful.
  *
  */
   virtual void UnreferenceRep () = 0 ;

   /**
    * Adds the graphical representation of one visualization extension into the output path of graphical representations.
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;:
    * This method is part of the usual mechanism of generating a path of graphical representations from a path of
    * components. And this mechanism is managed by the @href CATVisManager. 
    * @param iPathElt
    * path of components from which the current component is extracted.
    * @param ioPathRep
    * output path of graphical representations to fill in.
    * @return 
    * an HRESULT value.
    * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
    * &lt;ul&gt;
    * &lt;li&gt;S_OK if the operation succeeds &lt;/li&gt;
    * &lt;li&gt;E_FAIL otherwise &lt;/li&gt;
    * &lt;/ul&gt;
    */
  virtual HRESULT BuildRepPath(const CATPathElement &amp; iPathElt, CATRepPath &amp; ioPathRep ) = 0;

  /**
    * Adds the graphical representation of one visualization extension into the output path of graphical representations.
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;:
    * The same as @href #BuildRepPath but it is for (pre)highlight purposes only.
    * @param iPathElt
    *  path of components from which the current component is extracted.
    * @param ioPathRep
    * output path of graphical representations to fill in.
    * @return 
    * an HRESULT value.
    * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
    * &lt;ul&gt;
    * &lt;li&gt;S_OK if the operation succeeds &lt;/li&gt;
    * &lt;li&gt;E_FAIL otherwise &lt;/li&gt;.
    * &lt;/ul&gt;
    */
  virtual HRESULT BuildHighlightLook(const CATPathElement &amp; iPathElt, CATRepPath &amp; ioPathRep ) = 0;

  /**
   * Adds the component of the current visualization extension into the output path of components.
   * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;:
    * This method is part of the usual mechanism of generating a path of components from a path of graphical
    * representations. And this mechanism is managed by the @href CATVisManager. 
    * @param iPickPath
    * input path of graphical representations from which the graphical representation of the current extension is extracted.
    * @param ioPathElt
    * output path of components to fill in.
    * @return 
    * an HRESULT value.
    * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
    * &lt;ul&gt;
    * &lt;li&gt;S_OK if the operation succeeds &lt;/li&gt;
    * &lt;li&gt;E_FAIL otherwise &lt;/li&gt;.
    * &lt;/ul&gt;
   */
  virtual HRESULT DecodeGraphic(const CATPickPath &amp;iPickPath, CATPathElement &amp;ioPathElt ) = 0;

  /**
  * @nodoc
  * Builds the graphical representation and sets a model identifier onto it.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;:
  * &lt;br&gt;&lt;b&gt;Deprecated&lt;/b&gt;
  * &lt;br&gt;If no graphical representation exists, this method asks for its building
  * through the @href #BuildRep() method.
  * This method also sets a &lt;tt&gt;model identifier&lt;/tt&gt; onto  the graphical representation so as to keep a link
  * to its object.
  * This method should not be overriden if you implement a visualization interface with the @href CATExtIVisu 
  * adapter.
  * @return 
  * a pointer to the graphical representation of one extension of any visualization interface.
  */
  virtual CATRep * GetRep () = 0 ;

  /**
   * Tests if the elements of a CATPathElement are valid for highlight.
   * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: in the default implementation, calls recursively the method IsHighlightValid
   * on the elements of the CATPathElement that implement CATIVisu.
   * @param iPathElt
   * input path of components from which the current component is extracted.
   * @return 
   * an HRESULT value.
   * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   * &lt;ul&gt;
   * &lt;li&gt;S_OK if the component is to be highlighted &lt;/li&gt;
   * &lt;li&gt;E_FAIL otherwise &lt;/li&gt;.
   * &lt;/ul&gt;
   */
  virtual HRESULT IsHighlightValid(CATPathElement &amp; iPathElt) = 0;

 
  /**
   * @nodoc
   */
  virtual HRESULT SetVisuRep(CATRep * iRep) = 0;

  /**
   * Sets the graphical representation of this component to an not uptodate state.
   *
   */
   virtual void SetRepNotUpToDate() = 0;

  /**
   * Tests whether or not the graphical representation of the current component is uptodate.
   * @return 
   * &lt;ol&gt;
   * &lt;li&gt;1 if the graphical representation of the component is uptodate&lt;/li&gt;
   * &lt;li&gt;0 if the graphical representation of the component is not uptodate&lt;/li&gt;
   * &lt;/ol&gt;
   *
   */
  virtual int IsRepUpToDate() = 0;

}; 

/** @nodoc */
CATDeclareHandler(CATIVisu,CATBaseUnknown);

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATIVisVrmlSettingAtt.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIVisVrmlSettingAtt.h</a></div>
        <div><a href="CATIVisuFilter.html">‰∏ã‰∏ÄÈ°µ: CATIVisuFilter.h ‚Üí</a></div>
    </div>
</body>
</html>