<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATSchPlatformInterfaces/PublicInterfaces/CATISchCompatible.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CATSchPlatformInterfaces/PublicInterfaces/CATISchCompatible.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATISchCompLocation.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATISchCompLocation.h</a></div>
        <div><a href="CATISchComponent.html">‰∏ã‰∏ÄÈ°µ: CATISchComponent.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATISchCompatible_H
#define CATISchCompatible_H

//	COPYRIGHT DASSAULT SYSTEMES 2000

/**
 * @CAA2Level L1
 * @CAA2Usage U3
 */

// System
#include &quot;IUnknown.h&quot;
#include &quot;CATBooleanDef.h&quot;

class CATIUnknownList;
class CATISchAppConnector;
class CATISchGRR;
class CATISchGRRComp;

extern &quot;C&quot; const IID IID_CATISchCompatible ;

/**
 * Interface to query for compatible object to connect to. 
 * &lt;b&gt;Role&lt;/b&gt;: Defines connection rules for Schematic basic set of objects.
 */
class CATISchCompatible : public IUnknown
{
  public: 
  
  /**
  * Query whether an object is compatible to be connected to a route.
  * This method is used when routing a route.
  * @param iRouteCntrClassType
  *   Class type of a schematic route connector.
  * @param iGRRTarget
  *   Pointer to the graphical image of a target component or 
  *   to the primitive of a target route   
  * @param oLOKCntrs
  *   A list of compatible and available connectors on the component or route 
  *   (members are CATISchAppConnector interface pointers)
  *   This is used as an &lt;b&gt;input&lt;/b&gt; to GetBestCntrForRoute
  *   @see #GetBestCntrForRoute
  * @param oBYes
  *   If TRUE, the component is OK to be connected to a route.
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT IsTargetOKForRoute (const char *iRouteCntrClassType,
    CATISchGRR *iGRRTarget, CATIUnknownList **oLOKCntrs, CATBoolean *oBYes) = 0;

  /**
  * Query whether an object is compatible to be connected to another component.
  * This method is used when placing a component.
  * @param iGRRTarget
  *   Pointer to the graphical image of the component in question (the
  *   target component to be connected to)
  * @param iCompInfo
  *   Pointer to an internal class which contains structured information
  *   of &quot;this&quot; component for placement. This is an &lt;b&gt;output&lt;/b&gt; of  
  *   CATISchComponent::QueryPlaceAbility
  *   @see CATISchComponent#QueryPlaceAbility
  * @param oPlaceCompatInfo
  *   Pointer to an internal class which contains structured information
  *   for &quot;this&quot; component &lt;b&gt;and&lt;/b&gt; target component (the one in question) 
  *   This is used as an &lt;b&gt;input&lt;/b&gt; to GetBestFitPlaceInfo
  *   @see #GetBestFitPlaceInfo
  * @param oBYes
  *   If TRUE, the component is OK to be connected to a route.
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT IsTargetOKForPlace (CATISchGRRComp *iGRRTarget,
    const IUnknown *iCompInfo, IUnknown **oPlaceCompatInfo,
    CATBoolean *oBYes) = 0; 

  /**
  * Query whether an object is compatible to be inserted into a route.
  * This method is used when placing a component.
  * @param iCompInfo
  *   Pointer to an internal class which contains structured information
  *   of &quot;this&quot; component for placement. This is an &lt;b&gt;output&lt;/b&gt; of  
  *   CATISchComponent::QueryPlaceAbility
  *   @see CATISchComponent#QueryPlaceAbility
  * @param oInsertCompatInfo
  *   Pointer to an internal class which contains structured information
  *   for &quot;this&quot; component &lt;b&gt;and&lt;/b&gt; target route (the one in question)
  *   This is used as an &lt;b&gt;input&lt;/b&gt; to GetBestFitInsertInfo
  *   @see #GetBestFitInsertInfo
  * @param oBYes
  *   If TRUE, the component is OK to be connected to a route.
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT IsTargetOKForInsert (const IUnknown *iCompInfo, 
    IUnknown **oInsertCompatInfo, CATBoolean *oBYes) = 0; 

  /**
  * Find the best-fit connector(s) to be used for placing a component
  * and connecting it to another.
  * @param iDb2PlacementPt
  *   X-Y coordinates of the target component
  *   graphical selection point.
  * @param iPlaceCompatInfo
  *   Pointer to an internal class which contains structured information
  *   This is an &lt;b&gt;output&lt;/b&gt; of IsTargetOKForPlace 
  *   @see #IsTargetOKForPlace.
  * @param ioPlaceInfo
  *   Pointer to an internal class which contains structured information
  *   for how to place a component.   
  *   Caller must initialize this pointer to NULL when calling this
  *   code the &lt;b&gt;first&lt;/b&gt; time. 
  *   This is used as an &lt;b&gt;input&lt;/b&gt;
  *   to CATISchComponent::PlaceOnComponentWithInfo   
  *   @see CATISchComponent#PlaceOnComponentWithInfo.
  * @param iBYesCycleAllSolns
  *   default is FALSE, and ioPlaceInfo is an output for the best fit 
  *   solution. This solution will connect the compatible Target
  *   connector closest to the iDb2PlacementPt (call this CntrTgt)
  *   and the source connector that is closest to the origin
  *   (in position relative to ditto axis).
  *   If iBYesCycleAllSolns =TRUE, then the implementation 
  *   will calculate all possible solutions
  *   and allow the caller to recall this code with the
  *   same ioPlaceInfo, 
  *   &lt;b&gt; if and only if the compatible Target connector
  *   closest to the iDb2PlacementPt is the same as the previous 
  *   one &lt;/b&gt;. 
  *   By doing this, this code will set the 
  *   internal data ioPlaceInfo accordingly, so that when used in
  *   PlaceOnComponentWithInfo, the next solution will be used.
  *   For example, say there are 3 possible solutions and we call them
  *   solution1, solution2 and solution3. Call this code the first
  *   time and PlaceOnComponentWithInfo will use solution1. Call this
  *   code the second time (provided that CntrTgt remains the same)
  *   and solution2 will be used. The third time, solution3. The 
  *   fourth time, solution1 and so one. 
  *
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT GetBestFitPlaceInfo (const double iDb2PlacementPt[2],
    IUnknown *iPlaceCompatInfo,
    IUnknown **ioPlaceInfo, CATBoolean iBYesCycleAllSolns = FALSE) = 0; 

  /**
  * Find the best-fit connector(s) to be used for inserting a component
  * into a route.
  * @param iDb2PlacementPt
  *   X-Y coordinates of the target component
  *   graphical selection point.
  * @param iInsertCompatInfo
  *   Pointer to an internal class which contains structured information
  *   This is an &lt;b&gt;output&lt;/b&gt; of IsTargetOKForInsert
  *   @see #IsTargetOKForInsert.
  * @param ioInsertInfo
  *   Pointer to an internal class which contains structured information
  *   for how to inesrt a component into a route. 
  *   Caller must initialize this pointer to NULL when calling this
  *   code the &lt;b&gt;first&lt;/b&gt; time. 
  *   This is used as an &lt;b&gt;input&lt;/b&gt;
  *   to CATISchComponent::InsertIntoRouteWithInfo   
  *   @see CATISchComponent#InsertIntoRouteWithInfo.
  * @param iBYesCycleAllSolns
  *   default is FALSE, and ioInsertInfo is an output for the best fit 
  *   solution. When there are more than one internal flows that can
  *   be used for insertion, this routine will choose the best solution in
  *   the following order:
  *   &lt;dl&gt;
  *     &lt;dd&gt; linear internal flow parallel to x-axis &lt;/dd&gt;
  *     &lt;dd&gt; linear internal flow parallel to y-axis &lt;/dd&gt;
  *     &lt;dd&gt; corner internal flow &lt;/dd&gt;
  *     &lt;dd&gt; others &lt;/dd&gt;
  *   &lt;/dl&gt;
  *   If iBYesCycleAllSolns =TRUE, then the implementation 
  *   will calculate all possible solutions
  *   and allow the caller to recall this code with the
  *   same ioInsertInfo.
  *   &lt;b&gt; if and only if current input iDB2PlacementPt is the
  *   the same as the previous one &lt;/b&gt;. Otherwise, the insertion position
  *   of the component on the route is different and the previously
  *   calculated solutions are all invalid for the current call.
  *      
  *   If the iDB2PlacementPt is the same as the previous one
  *   and iBYesCycleAllSolns is TRUE, this code will set the 
  *   internal data ioInsertInfo accordingly, so that when used in
  *   InsertIntoRouteWithInfo, the next solution will be used.
  *   For example, say there are 3 possible solutions and we call them
  *   solution1, solution2 and solution3. Call this code the first
  *   time and InsertIntoComponentWithInfo will use solution1. Call this
  *   code the second time (provided that CntrTgt remains the same)
  *   and solution2 will be used. The third time, solution3. The 
  *   fourth time, solution1 and so one. 
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT GetBestFitInsertInfo (const double iDb2PlacementPt[2],
    IUnknown *iInsertCompatInfo,
    IUnknown **ioInsertInfo, CATBoolean iBYesCycleAllSolns = FALSE) = 0;     

  /**
  * Find the best-fit connector to be used to connect a route to.
  * @param iDb2PlacementPt
  *   X-Y coordinates of the target (component or route) graphic selection point.
  * @param iGRR
  *   Pointer to the graphical image of a component or 
  *   to the primitive of a route   
  * @param iLOKCntrs
  *   A list of compatible and available connectors on the component. 
  *   Members are CATISchAppConnector interface pointers. 
  *   This is an &lt;b&gt;Output&lt;/b&gt; of IsTargetOKForRoute
  *   @see #IsTargetOKForRoute
  * @param oDb2CntrPt
  *   X-Y coordinates of the best-fit connector point.
  * @param oBestCntr
  *   Best-fit connector
  * @return
  *   An HRESULT value.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;dl&gt;
  *     &lt;dt&gt;S_OK&lt;/dt&gt;
  *     &lt;dd&gt;operation is successful&lt;/dd&gt;
  *     &lt;dt&gt;E_FAIL&lt;/dt&gt;
  *     &lt;dd&gt;operation failed&lt;/dd&gt;
  *   &lt;/dl&gt;
  */
  virtual HRESULT GetBestCntrForRoute (const double iDb2PlacementPt[2],
    CATISchGRR *iGRR, CATIUnknownList *iLOKCntrs, double *oDb2CntrPt,
     CATISchAppConnector **oBestCntr) = 0; 

};
#endif
</div>
    
    <div class="navigation">
        <div><a href="CATISchCompLocation.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATISchCompLocation.h</a></div>
        <div><a href="CATISchComponent.html">‰∏ã‰∏ÄÈ°µ: CATISchComponent.h ‚Üí</a></div>
    </div>
</body>
</html>