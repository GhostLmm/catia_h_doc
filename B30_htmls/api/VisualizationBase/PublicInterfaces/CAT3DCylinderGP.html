<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisualizationBase/PublicInterfaces/CAT3DCylinderGP.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>VisualizationBase/PublicInterfaces/CAT3DCylinderGP.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CAT3DCustomRep.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DCustomRep.h</a></div>
        <div><a href="CAT3DEdgeGP.html">‰∏ã‰∏ÄÈ°µ: CAT3DEdgeGP.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CAT3DCylinderGP_H
#define CAT3DCylinderGP_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */

//******************************************************************************
//  Inheritance:
//  ------------
//                CAT3DCylinderGP
//                  CAT3DBoundingGP
//                    CATGraphicPrimitive
//                      CATBaseUnknown (SYSTEM framework) 
//
//******************************************************************************

#include &quot;CATViz.h&quot;
#include &quot;CAT3DBoundingGP.h&quot;

class CATCylinderNormalCollector;
class CATStreamer;



/**
 * Class to create the graphic primitive of a 3D cylinder.
 * &lt;b&gt;Role&lt;/b&gt;:
 * Tesselation is stored the simplest way: 2 fans for extremal sections, 1 strip for the
 * body of the cylinder. We only store vertices for the base section, and we
 * dynamically generate tesselation during the draw.
 */
class ExportedByCATViz CAT3DCylinderGP : public CAT3DBoundingGP
{
 
  friend class CATMarshallable3DCylinderGP;
  CATDeclareClass;
  
  
  public:

  /**
   * Default constructor.
   */
    CAT3DCylinderGP (void);

  /**
   * Constructs a 3D cylinder from its bottom face center coordinates, its extusion 
   * vector, its radius and the sag used for tesselation.
   * @param iCenter
   *   Array made with the three coordinates of the cylinder bottom extremal face center.
   * @param iExtrusion
   *   Array made with the extrusion vector coordinates. Indeed, a cylinder is the extrusion
   *   of a circle along a vector. The length of the &lt;tt&gt;iExtrusion&lt;/tt&gt; vector is the
   *   length of the cylinder. this array size is equal to three.
   * @param iRadius
   *   The radius of the cylinder.
   * @param iSag
   *   This parameter defines the number of vertices along the cylinder,
   *   and means the chordal deviation along the base circle.
   */
    CAT3DCylinderGP (float *iCenter,      
                     float *iExtrusion,   
	             float iRadius,       
                     float iSag);         
    
  /**
   * @nodoc
   */
  virtual void Stream(CATStreamer&amp; iStr,int iSaveType=0);

  /**
   * @nodoc
   */
  virtual void UnStream(CATStreamer&amp; iStr);
  
  /**
   * @nodoc
   *    Computing bounding box and bounding sphere. 
   */
  virtual void ComputeBox (void);
    
   /**
   * Draws the cylinder.
   * @param iRender
   *   The render through which the cylinder is drawn.
   */
    virtual void Draw (CATRender &amp;iRender);
    
    
  /**
   * Retrieves the tesselation information from the cylinder.&lt;br&gt;
   * &lt;b&gt;Role&lt;/b&gt;: As this method is designed to return values on its
   * parameters, it has to be called like this :&lt;br&gt;
   * &lt;tt&gt;&lt;pre&gt;
   * int allocate;
   * float * vertices;
   * ...
   * Get(&amp;allocate, &amp;vertices, ...);
   * &lt;/pre&gt;&lt;/tt&gt;&lt;br&gt;
   * @param oAllocate
   *    Flag specifying whether retrieved data is copied or not.
   *    &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *      &lt;dl&gt;
   *        &lt;dt&gt;1&lt;/dt&gt;
   *          &lt;dd&gt;retrieved data is copied.&lt;/dd&gt;
   *        &lt;dt&gt;0&lt;/dt&gt;
   *          &lt;dd&gt;retrieves references on data.&lt;/dd&gt;
   *      &lt;/dl&gt;
   *    oAllocate flag is always returned equal to 1: &lt;tt&gt;GetVertices&lt;/tt&gt; always
   *    allocates the returned arrays.
   * @param oVertices
   *    Retrieves an array made of cylinder vertices coordinates: XYZXYZXYZ...
   *    If we have NCirclePoints to describe the base cylinder circle, the size of this array
   *    is equal to 3 * 4 * NCirclePoints.
   *    This array is structured like this:
   *    Its first NCirclePoints*3 fields contain the bottom circle vertices coordinates.
   *    Then, are stored respectively, the bottom circle first vertex coordinates, the top circle
   *    corresponding vertex coordinates, the bottom circle second vertex coordinates, the top circle
   *    corresponding vertex coordinates ... Finally, the last NCirclePoints*3 coordinates correspond to
   *    the top circle vertices coordinates. This kind of organization allows the drawing of the cylinder
   *    body thanks to triangles strips, by taking the points
   *    in the order they are stored.
   *    For example, let&#x27;s assume that our bottom circle is tesselated thanks to 4 vertices. Let&#x27;s call
   *    the bottom circle BC and the top circle TC. If the notation BC.P1 designates the first vertex of the
   *    bottom circle, the oVertices array will look like this :
   *   &lt;pre&gt;
   *      
   *                               -----------
   *                              | oVertices |
   *                               -----------
   *                           {  |   BC.P1   |  
   *      bottom circle points {  |   BC.P2   |   
   *                           {  |   BC.P3   |   
   *                           {  |   BC.P4   |   
   *                              |   BC.P1   | }
   *                              |   TC.P1   | }
   *                              |   BC.P2   | }
   *                              |   TC.P2   | } 
   *                              |   BC.P3   | } intermediate cylinder body
   *                              |   TC.P3   | }
   *                              |   BC.P4   | }
   *                              |   TC.P4   | }
   *                            { |   TC.P1   |
   *          top circle points { |   TC.P2   |
   *                            { |   TC.P3   |
   *                            { |   TC.P4   |   
   *                               -----------
   *                
   *
   *   &lt;/pre&gt;
   * Of course, for each point we have in reality 3 fields in the array, corresponding to
   * this point&#x27;s coordinates.
   * @param oVerticesArraySize
   *   the oVertices array size. This size is equal to three times the number of vertices used
   *   to describe the bottom circle cross four.
   * @param oNormals
   *   Retrieves an array made of normals coordinates. It is organized as &lt;tt&gt;oVertices&lt;/tt&gt; : one vertex has exactly
   *   one normal at the same field entry.
   * @param oNormalsArraySize
   *   Retrieves The size, in floats, of the &lt;tt&gt;oNormal&lt;/tt&gt; array. Equal to three times the number
   *   of normals and equals to oVerticesArraySize.
   * @param oTriangleIndices
   *   Indices of cylinder single triangles vertices. 
   *    Always equal to NULL.
   * @param oNbTriangle
   *   Number of cylinder single triangles. 
   *   Always equal to 0.
   * @param oTriangleStripIndices
   *    Retrieves the array used to store the cylinder triangles strip. There is only one
   *    triangles strip, used to describe the cylinder body. Each field contains a
   *    vertex index, belonging to the strip, in the oVertices array.  As, we find, in the
   *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
   *    vertex, the indices used to designate the vertices are multiples of three.
   * @param oNbTriangleStrip
   *    Retrieves the number of triangles strips used to describe the cylinder body.
   *    Always equal to 1.
   * @param oNbVertexPerTriangleStrip
   *    Retrieves an array, which size is one, containing the number of vertices
   *    used in the strip. If NCirclePoints is the number of vertices used to describe the 
   *    cylinder bottom circle, the number of vertices belonging to the strip is equal to
   *    2*NCirclePoints*3 + 2.
   * @param oTriangleFanIndices
   *   Retrieves the array used to store the cylinder triangles fans vertices indices. There is only 2 triangles fans
   *   in a cylinder: one for each extremities circle.
   *   Each field contains a
   *   vertex index, belonging to one of the fans, in the &lt;tt&gt;oVertices&lt;/tt&gt; array.  As, we find, in the
   *   &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
   *   vertex, the indices used to designate the vertices are multiples of three.
   *   &lt;pre&gt;
   *
   *
   *                   ----------------------
   *                  | *oTriangleFanIndices  |
   *                   ----------------------
   *                  |          i00         |   }
   *                  |          i01         |   } first triangle fan defined
   *                  |           .          |   } by the first n0 indices
   *                  |           .          |   }
   *                  |          i0n0        |   }
   *                  |                      |
   *                  |          i10         |   }
   *                  |          i11         |   }
   *                  |           .          |   } second triangle fan 
   *                  |           .          |   } with n1 vertices
   *                  |          i1n1        |   }
   *                   ----------------------
   *
   *
   *   &lt;/pre&gt; 
   *   For example, index i10 allows to access the cylinder second fan first vertex
   *   wich coordinates are X = *oVertices[i10], Y = *oVertices[i10 + 1] and Z = *oVertices[i10 + 2], and
   *   which normal coordinates are Nx = *oNormals[i10], Ny = *oNormals[i10 + 1] and Nz = *oNormals[i10 + 2].
   * @param oNbTriangleFan
   *    Retrieves the number of cylinder triangles fans. Always equal to 2.
   * @param oNbVertexPerTriangleFan
   *    Retrieves the array containing the number of vertices for each cylinder triangles fan.
   *    The size of this array is equal to 2. For example, the first fan
   *    is made with &lt;tt&gt;*oNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
   *    &lt;pre&gt;
   *                --------------------------
   *               | *oNbVertexPerTriangleFan |
   *                --------------------------
   *               |             n0           |
   *               |             n1           |   n1 = number of vertices of the second fan. (*oNbVertexPerTriangleFan[1]
   *                --------------------------    
   *
   *   &lt;/pre&gt;
   */
    void Get (int    * oAllocate,
	      float ** oVertices,
	      int    * oVerticesArraySize,
	      float ** oNormals,
	      int    * oNormalsArraySize,
	      int   ** oTriangleIndices,
	      int    * oNbTriangle,
	      int   ** oTriangleStripIndices,
	      int    * oNbTriangleStrip,
	      int   ** oNbVertexPerTriangleStrip,
	      int   ** oTriangleFanIndices,
	      int    * oNbTriangleFan,
	      int   ** oNbVertexPerTriangleFan); 

  /**
   * Retrieves the cylinder vertices coordinates.&lt;br&gt;
   * &lt;b&gt;Role&lt;/b&gt;: As this method is designed to return values on its
   * parameters, it has to be called like this :&lt;br&gt;
   * &lt;tt&gt;&lt;pre&gt;
   * int allocate;
   * float * vertices;
   * ...
   * GetVertices(&amp;allocate, &amp;vertices, ...);
   * &lt;/pre&gt;&lt;/tt&gt;&lt;br&gt;
   * @param oAllocate
   *    Flag specifiying whether retrieved data is copied or not.
   *    &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *      &lt;dl&gt;
   *        &lt;dt&gt;1&lt;/dt&gt;
   *          &lt;dd&gt;retrieved data is copied.&lt;/dd&gt;
   *        &lt;dt&gt;0&lt;/dt&gt;
   *          &lt;dd&gt;retrieves references on data.&lt;/dd&gt;
   *      &lt;/dl&gt;
   *    oAllocate flag is always returned equal to 1: &lt;tt&gt;GetVertices&lt;/tt&gt; always
   *    allocates the returned arrays.
   * @param oVertices
   *    Retrieves an array made of cylinder vertices coordinates: XYZXYZXYZ...
   *    If we have NCirclePoints to describe the base cylinder circle, the size of this arrsy
   *    is equal to 3 * 4 * NCirclePoints.
   *    This array is structured like this:
   *    Its first NCirclePoints*3 fields contain the bottom circle vertices coordinates.
   *    Then, are stored respectively, the bottom circle first vertex coordinates, the top circle
   *    corresponding vertex coordinates, the bottom circle second vertex coordinates, the top circle
   *    corresponding vertex coordinates ... Finally, the last NCirclePoints*3 coordinates correspond to
   *    the top circle vertices coordinates. This kind of organization allows the drawing of the cylinder
   *    body thanks to triangles strips, by taking the points
   *    in the order they are stored.
   *    For example, let&#x27;s assume that our bottom circle is tesselated thanks to 4 vertices. Let&#x27;s call
   *    the bottom circle BC and the top circle TC. If the notation BC.P1 designates the first vertex of the
   *    bottom circle, the oVertices array will look like this :
   *   &lt;pre&gt;
   *      
   *                               -----------
   *                              | oVertices |
   *                               -----------
   *                           {  |   BC.P1   |  
   *      bottom circle points {  |   BC.P2   |   
   *                           {  |   BC.P3   |   
   *                           {  |   BC.P4   |   
   *                              |   BC.P1   | }
   *                              |   TC.P1   | }
   *                              |   BC.P2   | }
   *                              |   TC.P2   | } 
   *                              |   BC.P3   | } intermediate cylinder body
   *                              |   TC.P3   | }
   *                              |   BC.P4   | }
   *                              |   TC.P4   | }
   *                            { |   TC.P1   |
   *          top circle points { |   TC.P2   |
   *                            { |   TC.P3   |
   *                            { |   TC.P4   |   
   *                               -----------
   *                
   *
   *   &lt;/pre&gt;
   * Of course, for each point we have in reality 3 fields in the array, corresponding to
   * this point&#x27;s coordinates.
   * @param oVerticesArraySize
   *   the oVertices array size. This size is equal to three times the number of vertices used
   *   to describe the bottom circle cross four.
   */
    void GetVertices (int    * oAllocate,
		      float ** oVertices,
		      int    * oVerticesArraySize);
    

  /**
   * @nodoc
   * Retrieves the cylinder bottom face vertices coordinates,
   * the normals to the cylinder and the extrusion parameters.
   * @param oBottomFaceVertices
   *    Retrieves an array made of cylinder bottom face coordinates: XYZXYZXYZ...
   *    This array size is equal to three times oNbVertices.
   * @param oNbVertices
   *    Retrieves the number of vertices used to describe the bottom circle.
   * @param oBodyNormals
   *    Retrieves an array containing the cylinder normals. 
   * @param oExtrusion
   *    Retrieves the extrusion vector coordinates. This vector norm is equal to the cylinder
   *    length. &lt;tt&gt;oExtrusion&lt;/tt&gt; vector is equal to norm(oExtrusion)*oDirection. This array size is
   *    equal to three.
   * @param oDirection
   *    Retrieves the normalized cylinder extrusion direction.
   */
    void Get (float ** oBottomFaceVertices,
              int    * oNbVertices,
              float ** oBodyNormals,
              float  * oExtrusion,
	      float  * oDirection);

  /**
   * @nodoc
   * Retrieves the extrusion vector, the base vectors of the plan
   * containing the cylinder bottom circle, the cylinder length and
   * the bottom circle center coordinates.
   * @param oExtrusionVector
   *    Retrieves the extrusion vector coordinates. This vector norm is equal to the cylinder
   *    length. This array size is equal to three.
   * @param oAxis_x
   *    Retrieves one of the two vectors constituing a base for
   *    the plan containing the cylinder bottom circle.
   * @param oAxis_y
   *    Retrieves the second vector constituing a base for
   *    the plan containing the cylinder bottom circle.
   * @param oLength
   *    Retrieves the cylinder length. 
   * @param oCenter
   *    Retrieves the array made of the cylinder bottom circle center coordinates.
   */
    void Get (float *oExtrusionVector,
	      float *oAxis_x,
	      float *oAxis_y,
              float *oLength,
	      float *oCenter);
    
    

  /**
   * @nodoc
   * In favor of GetTextureCoordinates (float ** oTextureCoord, int * oDimension).
   * Retrieves the texture coordinates.
   * This method must be used like this:
   * &lt;br&gt;&lt;tt&gt;&lt;pre&gt;
   * float * textureCoord;
   * GetTextureCoord(&amp;textureCoord);
   * &lt;br&gt;&lt;/pre&gt;&lt;/tt&gt;
   * @param oTextureCoord
   *    Retrieves the array of texture coordinates.
   *    Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   */
    inline void GetTextureCoordinates     (float **oTextureCoord);

  /**
   * Retrieves the texture coordinates.
   * This method must be used like this:
   * &lt;br&gt;&lt;tt&gt;&lt;pre&gt;
   * float * textureCoord;
   * GetTextureCoord(&amp;textureCoord);
   * &lt;br&gt;&lt;/pre&gt;&lt;/tt&gt;
   * @param oTextureCoord
   *    Retrieves the array of texture coordinates.
   *    Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   * @param oDimension
   *    Retrieve the number of coordinates per vertex.
   */
    inline void GetTextureCoordinates     (float ** oTextureCoord, int * oDimension);

  /**
   * Sets the texture coordinates.
   * @param iTextureCoord
   *    Array of texture coordinates. Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   * @param iTextureFormat
   *    iTextureFormat is the number of fields associated to one vertex in the &lt;tt&gt;iTextureCoord&lt;/tt&gt; array.
   *    It is also the number of texture coordinates associated to each vertex.
   *    Indeed, each vertex has associated coordinates in the texture map. The
   *    number of coordinates depends on the map dimension: the texture map
   *    may be in 1D, 2D or 3D. 
   * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *   &lt;dl&gt;
   *      &lt;dt&gt;1&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a one dimension map. Each vertex has a single associated texture coordinate&lt;/dd&gt;
   *      &lt;dt&gt;2&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a two-dimension map. Each vertex has two associated texture coordinates&lt;/dd&gt;
   *      &lt;dt&gt;3&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a three-dimension map. Each vertex has three associated texture coordinates&lt;/dd&gt;
   *   &lt;/dl&gt;
   */
    void SetTextureCoordinates     (float *iTextureCoord,int iTextureFormat);

  /**
   * @nodoc
   */
    void ComputeTextureCoordinates (const CATMappingOperator &amp;iOper);
    
  /**
   * @nodoc
   */
  virtual int DetailCulling(CATRender *render);
    
    
  protected:
    
    // Destruction:
    // ------------
    
    virtual ~CAT3DCylinderGP (void);
    
    
    // Reduced tesselation information:
    // --------------------------------
    
    int     _NbVertices;         // Number of vertices around the circle.
    float   _Longueur;           // 1/long extrusion memorized only to optimize.
    float   _Extrusion[3];       // Direction and length defining the cylinder.
    int     _IndexNormalRef;     // Reference to a common normal array.
    float  *_BottomFaceVertices; // Vertices used as bottom face tesselation.
    float  *_TextureCoordinates; // Texture coordonnates.
    int     _NumberOfTC;         // Number of texture coordonnates.
    
    static CATCylinderNormalCollector *_cylnor;        // Body normals database.
    static int _nbcyl;
};




//******************************************************************************
//*** INLINED METHODS: *********************************************************
//******************************************************************************


inline void CAT3DCylinderGP::GetTextureCoordinates (float **texture_coord)
{
  *texture_coord=_TextureCoordinates;  
}

inline void CAT3DCylinderGP::GetTextureCoordinates (float ** oTextureCoord, int * oDimension)
{
  *oTextureCoord=_TextureCoordinates;
  *oDimension = 3;
}

#endif
</div>
    
    <div class="navigation">
        <div><a href="CAT3DCustomRep.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DCustomRep.h</a></div>
        <div><a href="CAT3DEdgeGP.html">‰∏ã‰∏ÄÈ°µ: CAT3DEdgeGP.h ‚Üí</a></div>
    </div>
</body>
</html>