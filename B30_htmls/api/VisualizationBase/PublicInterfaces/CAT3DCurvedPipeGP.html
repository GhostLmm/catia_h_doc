<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VisualizationBase/PublicInterfaces/CAT3DCurvedPipeGP.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>VisualizationBase/PublicInterfaces/CAT3DCurvedPipeGP.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CAT3DCurveRep.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DCurveRep.h</a></div>
        <div><a href="CAT3DCustomRep.html">‰∏ã‰∏ÄÈ°µ: CAT3DCustomRep.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CAT3DCurvedPipeGP_H
#define CAT3DCurvedPipeGP_H

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */


//******************************************************************************
//  Inheritance:
//  ------------
//                CAT3DCurvedPipeGP
//                  CAT3DBoundingGP
//                    CATGraphicPrimitive
//                      CATBaseUnknown (SYSTEM framework) 
//
//******************************************************************************

#include &quot;CATViz.h&quot;
#include &quot;CAT3DBoundingGP.h&quot;
class CATStreamer;

#define INVALID_STORAGEID      0x7fffffff  //max value for a 31 bits unsigned int 
/**
 * Class to create the graphic primitive of a 3D curved pipe.
 * &lt;b&gt;Role&lt;/b&gt;: A 3D curved pipe can be assimilated to the extrusion
 * of a circle along a main 3D curve.
 */
class ExportedByCATViz CAT3DCurvedPipeGP : public CAT3DBoundingGP
{
  
  friend class CATMarshallable3DCurvedPipeGP;
  CATDeclareClass;
  
  
  public:
    
    // Construction method (locked destruction method):
    // ------------------------------------------------

  /**
   * Default constructor.
   */
    CAT3DCurvedPipeGP (void);

  /**
   * Constructs a 3D curved pipe from tesselation informations
   * on the main curve and on circles belonging to the curved pipe.
   * @param iCurveVertices
   *   Array made of main curve vertices coordinates: XYZXYZXYZ...
   *   Its size is equal to three times the number of vertices
   *   used to describe the main curve.
   * @param iNbCurveVertices
   *   The number of vertices used to describe the main curve.
   * @param iCirclesVertices
   *   Array made of curved pipe&#x27;s circles coordinates. There is
   *   one circle per curve vertex, and a constant number of vertices
   *   to describe each of these circles.So, this array size is equal to
   *   &lt;tt&gt;iNbCurveVertices * iNbVerticesPerCircle * 3&lt;/tt&gt;.
   *   For example, if we choose to describe each circle of the pipe with
   *   20 points, the pipe second circle first point coordinates are :
   *   &lt;tt&gt;x = iCirclesVertices[3*iNbVerticesPerCircle], y = iCirclesVertices[3*iNbVerticesPerCircle+1] and
   *   z = iCirclesVertices[3*iNbVerticesPerCircle+2].
   * @param iNbVerticesPerCircle
   *   The number of vertices used to describe every circles of the pipe.
   * @param iBaseNormal
   *   Array of curved pipe base circle normal coordinates. Its size is three
   * @param iEndNormal
   *   Array of curved pipe end circle normal coordinates. Its size is three
   * @param iPipeRadius
   *   The global pipe radius. 
   */
    CAT3DCurvedPipeGP (float *iCurveVertices,         
		       int iNbCurveVertices,         
		       float *iCirclesVertices,        
		       int iNbVerticesPerCircle,       
		       float *iBaseNormal,         
		       float *iEndNormal,          
		       float iPipeRadius);              
    
  //Streaming
  /**
   * @nodoc
   */
    virtual void Stream(CATStreamer&amp; iStr,int iSaveType=0);
  /**
   * @nodoc
   */
    virtual void UnStream(CATStreamer&amp; iStr);

  /**
   * @nodoc
   *    Computing bounding box and bounding sphere. 
   */
    virtual void ComputeBox (void);
        
  /**
   * Draws the curved pipe.
   * @param iRender
   *   The render through which the curved pipe is drawn.
   */
    virtual void Draw (CATRender &amp;iRender);
    
    
  /**
   * Retrieves the tesselation information from the curved pipe.&lt;br&gt;
   * &lt;b&gt;Role&lt;/b&gt;: As this method is designed to return values on its
   * parameters, it has to be called like this :&lt;br&gt;
   * &lt;tt&gt;&lt;pre&gt;
   * int allocate;
   * float * vertices;
   * ...
   * Get(&amp;allocate, &amp;vertices, ...);
   * &lt;/pre&gt;&lt;/tt&gt;&lt;br&gt;
   * @param oAllocate
   *    Flag specifiying whether retrieved data is copied or not.
   *    &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *      &lt;dl&gt;
   *        &lt;dt&gt;1&lt;/dt&gt;
   *          &lt;dd&gt;retrieved data is copied.&lt;/dd&gt;
   *        &lt;dt&gt;0&lt;/dt&gt;
   *          &lt;dd&gt;retrieves references on data.&lt;/dd&gt;
   *      &lt;/dl&gt;
   *    oAllocate flag is always returned equal to 1: &lt;tt&gt;GetVertices&lt;/tt&gt; always
   *    allocates the returned arrays.
   * @param oVertices
   *   Retrieves an array made of curved pipe vertices coordinates: XYZXYZXYZ...
   *   If we have a pipe made
   *   with NCircles circles and that each circle is described with NCirclePoints points,
   *   &lt;tt&gt;oVertices&lt;/tt&gt; array size is equal to NCircles * NCirclePoints * 3 * 2.
   *   The array is structured like this:
   *   the first NCirclePoints*3 coordinates stored correspond to the NCirclePoints points of
   *   the first circle of the pipe. Then, are stored, respectively, the first point of the first circle,
   *   its corresponding point on the next circle, the second point of the first circle, its corresponding
   *   point on the next circle, ... Finally, the last NCirclePoints*3 coordinates correspond to the last circle.
   *   This kind of organization allows the drawing of the curved pipe body thanks to triangles strips, by taking the points
   *   in the order they are stored.
   *   For example, let&#x27;s assume that we have a curved pipe made with a 3 vertices curve and 4 vertices circles.
   *   We have 3 circles called C1, C2 and C3. If we use the notation C1.P1 to designate the first point of the first
   *   circle, the array will look like this :
   *   &lt;pre&gt;
   *      
   *                               -----------
   *                              | oVertices |
   *                               -----------
   *                           {  |   C1.P1   |  
   *       first circle points {  |   C1.P2   |   
   *                           {  |   C1.P3   |   
   *                           {  |   C1.P4   |   
   *                              |   C1.P1   | }
   *                              |   C2.P1   | }
   *                              |   C1.P2   | }
   *                              |   C2.P2   | } 
   *                              |   C1.P3   | }
   *                              |   C2.P3   | }
   *                              |   C1.P4   | }
   *                              |   C2.P4   | }
   *                              |   C2.P1   | } intermediate pipe body
   *                              |   C3.P1   | }
   *                              |   C2.P2   | }
   *                              |   C3.P2   | }
   *                              |   C2.P3   | }
   *                              |   C3.P3   | }
   *                              |   C2.P4   | }
   *                              |   C3.P4   | }
   *                            { |   C3.P1   |
   *         last circle points { |   C3.P2   |
   *                            { |   C3.P3   |
   *                            { |   C3.P4   |   
   *                               -----------
   *                
   *
   *   &lt;/pre&gt;
   * Of course, for each point we have in reality 3 fields in the array, corresponding to
   * this point&#x27;s coordinates. 
   * @param oVerticesArraySize
   *   the oVertices array size. This size is equal to three times the number of vertices
   *   used to describe the main curve, cross the number of vertices used to describe each circle,
   *   cross two.
   * @param oNormals
   *   Retrieves an array made of normals coordinates. It is organized as &lt;tt&gt;oVertices&lt;/tt&gt; : one vertex has exactly
   *   one normal at the same field entry.
   * @param oNormalsArraySize
   *   Retrieves The size, in floats, of the &lt;tt&gt;oNormal&lt;/tt&gt; array. Equal to three times the number
   *   of normals.
   * @param oTriangleIndices
   *   Indices of pipe single triangles vertices. 
   *    Always equal to NULL.
   * @param oNbTriangle
   *   Number of pipe single triangles. 
   *   Always equal to 0.
   * @param oTriangleStripIndices
   *    Retrieves the array used to store the pipe triangles strips vertices. The pipe body is made
   *    with triangles strips. Each field contains a
   *    vertex index, belonging to one of the strips, in the oVertices array.  As, we find, in the
   *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
   *    vertex, the indices used to designate the vertices are multiples of three.
   *    &lt;pre&gt;
   *
   *
   *                   ----------------------
   *                  | oTriangleStripIndices |
   *                   ----------------------
   *                  |          i00         |   }
   *                  |          i01         |   } first triangle strip defined
   *                  |           .          |   } by the first n1 indices
   *                  |           .          |   }
   *                  |          i0n1        |   }
   *                  |           .          |
   *                  |           .          |
   *                  |           .          |   
   *                  |          ij0         |   }
   *                  |          ij1         |   }
   *                  |           .          |   } triangle strip j
   *                  |           .          |   } with nj vertices
   *                  |          ijnj        |   }
   *                   ----------------------
   *
   *
   *    &lt;/pre&gt; 
   *    For example, index ij0 allows to access to the pipe j-th strip first vertex 
   *    wich coordinates are X = *oVertices[ij0], Y = *oVertices[ij0 + 1] and Z = *oVertices[ij0 + 2], and
   *    which normal coordinates are Nx = *oNormals[ij0], Ny = *oNormals[ij0 + 1] and Nz = *oNormals[ij0 + 2].   
   * @param oNbTriangleStrip
   *    Retrieves the number of triangles strips used to describe the pipe body.
   * @param oNbVertexPerTriangleStrip
   *    Retrieves an array containing the number of vertices for each pipe triangles strip.
   *    The size of this array is equal to &lt;tt&gt;*oNbTriangleStrip&lt;/tt&gt;. For example, the first strip
   *    is made with &lt;tt&gt;*oNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
   *    &lt;pre&gt;
   *                --------------------------
   *               |*oNbVertexPerTriangleStrip|
   *                --------------------------
   *               |             n1           |
   *               |             .            |
   *               |             .            |   m = Number of triangle strips(*oNbTriangleStrip)
   *               |             nm           |   nm = number of vertices of the m-th strip. (*oNbVertexPerTriangleStrip[m]
   *                --------------------------    
   *
   *   &lt;/pre&gt;   
   * @param oTriangleFanIndices
   *   Retrieves the array used to store the pipe triangles fans vertices indices. There is only 2 triangles fans
   *   in a curved pipe: one for each extremities circle.
   *   Each field contains a
   *   vertex index, belonging to one of the fans, in the &lt;tt&gt;oVertices&lt;/tt&gt; array.  As, we find, in the
   *   &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
   *   vertex, the indices used to designate the vertices are multiples of three.
   *   &lt;pre&gt;
   *
   *
   *                   ----------------------
   *                  | *oTriangleFanIndices  |
   *                   ----------------------
   *                  |          i00         |   }
   *                  |          i01         |   } first triangle fan defined
   *                  |           .          |   } by the first n0 indices
   *                  |           .          |   }
   *                  |          i0n0        |   }
   *                  |                      |
   *                  |          i10         |   }
   *                  |          i11         |   }
   *                  |           .          |   } second triangle fan 
   *                  |           .          |   } with n1 vertices
   *                  |          i1n1        |   }
   *                   ----------------------
   *
   *
   *   &lt;/pre&gt; 
   *   For example, index i10 allows to access the pipe second fan first vertex
   *   wich coordinates are X = *oVertices[i10], Y = *oVertices[i10 + 1] and Z = *oVertices[i10 + 2], and
   *   which normal coordinates are Nx = *oNormals[i10], Ny = *oNormals[i10 + 1] and Nz = *oNormals[i10 + 2].
   * @param oNbTriangleFan
   *    Retrieves the number of pipe triangles fans. Always equal to 2.
   * @param oNbVertexPerTriangleFan
   *    Retrieves the array containing the number of vertices for each pipe triangles fan.
   *    The size of this array is equal to 2. For example, the first fan
   *    is made with &lt;tt&gt;*oNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
   *    &lt;pre&gt;
   *                --------------------------
   *               | *oNbVertexPerTriangleFan |
   *                --------------------------
   *               |             n0           |
   *               |             n1           |   n1 = number of vertices of the second fan. (*oNbVertexPerTriangleFan[1]
   *                --------------------------    
   *
   *   &lt;/pre&gt;
   */
    void Get (int    * oAllocate,
	      float ** oVertices,
	      int    * oVerticesArraySize,
	      float ** oNormals,
	      int    * oNormalsArraySize,
	      int   ** oTriangleIndices,
	      int    * oNbTriangle,
	      int   ** oTriangleStripIndices,
	      int    * oNbTriangleStrip,
	      int   ** oNbVertexPerTriangleStrip,
	      int   ** oTriangleFanIndices,
	      int    * oNbTriangleFan,
	      int   ** oNbVertexPerTriangleFan); 

  /**
   * Retrieves curved pipe vertices coordinates.&lt;br&gt;
   * &lt;b&gt;Role&lt;/b&gt;: As this method is designed to return values on its
   * parameters, it has to be called like this :&lt;br&gt;
   * &lt;tt&gt;&lt;pre&gt;
   * int allocate;
   * float * vertices;
   * ...
   * GetVertices(&amp;allocate, &amp;vertices, ...);
   * &lt;/pre&gt;&lt;/tt&gt;&lt;br&gt;
   * @param oAllocate
   *    Flag specifiying whether retrieved data is copied or not.
   *    &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *      &lt;dl&gt;
   *        &lt;dt&gt;1&lt;/dt&gt;
   *          &lt;dd&gt;retrieved data is copied.&lt;/dd&gt;
   *        &lt;dt&gt;0&lt;/dt&gt;
   *          &lt;dd&gt;retrieves references on data.&lt;/dd&gt;
   *      &lt;/dl&gt;
   *    oAllocate flag is always returned equal to 1: &lt;tt&gt;GetVertices&lt;/tt&gt; always
   *    allocates the returned arrays.
   * @param oVertices
   *   Retrieves an array made of curved pipe vertices coordinates: XYZXYZXYZ...
   *   If we have a pipe made
   *   with NCircles circles and that each circle is described with NCirclePoints points,
   *   &lt;tt&gt;oVertices&lt;/tt&gt; array size is equal to NCircles * NCirclePoints * 3 * 2.
   *   The array is structured like this:
   *   the first NCirclePoints*3 coordinates stored correspond to the NCirclePoints points of
   *   the first circle of the pipe. Then, are stored, respectively, the first point of the first circle,
   *   its corresponding point on the next circle, the second point of the first circle, its corresponding
   *   point on the next circle, ... Finally, the last NCirclePoints*3 coordinates correspond to the last circle.
   *   This kind of organization allows the drawing of curved pipe thanks to triangles strips, by taking the points
   *   in the order they are stored.
   *   For example, let&#x27;s assume that we have a curved pipe made with a 3 vertices curve and 4 vertices circles.
   *   We have 3 circles called C1, C2 and C3. If we use the notation C1.P1 to designate the first vertex of the first
   *   circle, the array will look like this :
   *   &lt;pre&gt;
   *      
   *                               -----------
   *                              | oVertices |
   *                               -----------
   *                           {  |   C1.P1   |  
   *       first circle points {  |   C1.P2   |   
   *                           {  |   C1.P3   |   
   *                           {  |   C1.P4   |   
   *                              |   C1.P1   | }
   *                              |   C2.P1   | }
   *                              |   C1.P2   | }
   *                              |   C2.P2   | } 
   *                              |   C1.P3   | }
   *                              |   C2.P3   | }
   *                              |   C1.P4   | }
   *                              |   C2.P4   | }
   *                              |   C2.P1   | } intermediate pipe body
   *                              |   C3.P1   | }
   *                              |   C2.P2   | }
   *                              |   C3.P2   | }
   *                              |   C2.P3   | }
   *                              |   C3.P3   | }
   *                              |   C2.P4   | }
   *                              |   C3.P4   | }
   *                            { |   C3.P1   |
   *         last circle points { |   C3.P2   |
   *                            { |   C3.P3   |
   *                            { |   C3.P4   |   
   *                               -----------
   *                
   *
   *   &lt;/pre&gt;
   * Of course, for each point we have in reality 3 fields in the array, corresponding to
   * this point&#x27;s coordinates.
   * @param oVerticesArraySize
   *   the oVertices array size. This size is equal to three times the number of vertices
   *   used to describe the main curve, cross the number of vertices used to describe each circle,
   *   cross two.
   */
    void GetVertices (int    * oAllocate,
		      float ** oVertices,
		      int    * oVerticesArraySize);
    
  /**
   * Retrieves the attributes of the class.&lt;br&gt;
   * &lt;b&gt;Role&lt;/b&gt;: As this method is designed to return values on its
   * parameters, it has to be called like this :&lt;br&gt;
   * &lt;tt&gt;&lt;pre&gt;
   * float * curveVertices;
   * int nCurveVertices;
   * ...
   * Get(&amp;curveVertices, &amp;nCurveVertices, ...);
   * &lt;/pre&gt;&lt;/tt&gt;&lt;br&gt;
   * @param oCurveVertices
   *   Retrieves an array made of main curve vertices coordinates: XYZXYZXYZ...
   *   Its size is equal to three times the number of vertices
   *   used to describe the main curve.
   * @param oNbCurveVertices
   *   Retrieves the number of vertices used to describe the main curve.
   * @param oCirclesVertices
   *   Retrieves an Array made of curved pipe&#x27;s circles coordinates. There is
   *   one circle per curve vertex, and a constant number of vertices
   *   to describe each of these circles. So, this array size is equal to
   *   &lt;tt&gt;oNbCurveVertices * oNbVerticesPerCircle * 3&lt;/tt&gt;.
   *   For example, if we choose to describe each circle of the pipe with
   *   20 points, the pipe second circle first point coordinates are :
   *   &lt;tt&gt;x = oCirclesVertices[3*oNbVerticesPerCircle], y = oCirclesVertices[3*oNbVerticesPerCircle+1] and
   *   z = oCirclesVertices[3*oNbVerticesPerCircle+2].
   * @param oNbVerticesPerCircle
   *   Retrieves the number of vertices used to describe every circles of the pipe.
   * @param oBaseNormal
   *   Retrieves the array made of curved pipe base circle normal coordinates. Its size is three.
   * @param oEndNormal
   *   Retrieves the array made of curved pipe end circle normal coordinates. Its size is three.
   * @param iPipeRadius
   *   Retrieves the global pipe radius. 
   */
    void Get (float ** oCurveVertices,
	      int    * oNbCurveVertices,
	      float ** oCirclesVertices,
	      int    * oNbVerticesPerCircle,
	      float ** oBaseNormal,
	      float ** oEndNormal,
	      float  * iPipeRadius);

  
   /**
   * @deprecated V5R14.
   * In favor of GetTextureCoordinates (float ** oTextureCoord, int * oDimension).
   * Retrieves the texture coordinates.
   * This method must be used like this:
   * &lt;br&gt;&lt;tt&gt;&lt;pre&gt;
   * float * textureCoord;
   * GetTextureCoord(&amp;textureCoord);
   * &lt;br&gt;&lt;/pre&gt;&lt;/tt&gt;
   * @param oTextureCoord
   *    Retrieves the array of texture coordinates.
   *    Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   */
    inline void GetTextureCoordinates     (float ** oTextureCoord);

  /**
   * Retrieves the texture coordinates.
   * This method must be used like this:
   * &lt;br&gt;&lt;tt&gt;&lt;pre&gt;
   * float * textureCoord;
   * GetTextureCoord(&amp;textureCoord);
   * &lt;br&gt;&lt;/pre&gt;&lt;/tt&gt;
   * @param oTextureCoord
   *    Retrieves the array of texture coordinates.
   *    Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   * @param oDimension
   *    Retrieve the number of coordinates per vertex.
   */
    inline void GetTextureCoordinates     (float ** oTextureCoord, int * oDimension);

  /**
   * Sets the texture coordinates.
   * @param iTextureCoord
   *    Array of texture coordinates. Each vertex has an associated position
   *    in the texture map. The number of texture coordinates groups is always equal to the number of
   *    vertices. 
   * @param iTextureFormat
   *    iTextureFormat is the number of fields associated to one vertex in the &lt;tt&gt;iTextureCoord&lt;/tt&gt; array.
   *    It is also the number of texture coordinates associated to each vertex.
   *    Indeed, each vertex has associated coordinates in the texture map. The
   *    number of coordinates depends on the map dimension: the texture map
   *    may be in 1D, 2D or 3D. 
   * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *   &lt;dl&gt;
   *      &lt;dt&gt;1&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a one dimension map. Each vertex has a single associated texture coordinate&lt;/dd&gt;
   *      &lt;dt&gt;2&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a two-dimension map. Each vertex has two associated texture coordinates&lt;/dd&gt;
   *      &lt;dt&gt;3&lt;/dt&gt;
   *        &lt;dd&gt;The texture map is a three-dimension map. Each vertex has three associated texture coordinates&lt;/dd&gt;
   *   &lt;/dl&gt;
   */
    void SetTextureCoordinates     (float *iTextureCoord,int iTextureFormat);

  /**
   * @nodoc
   */
    void ComputeTextureCoordinates (const CATMappingOperator &amp;iOper);
    
  /**
   * @nodoc
   */
  virtual int DetailCulling(CATRender *render);

	/**
   * @nodoc
   */
    inline void SetStorageID(unsigned int iStorageID);
  /**
   * @nodoc
   */
    inline unsigned int GetStorageID();

    /**
   * @nodoc
   */
    inline unsigned int StorageIDisValid();
    
    
  protected:
    
    // Destruction:
    // ------------
    
    virtual ~CAT3DCurvedPipeGP (void);
    
    
    // Reduced tesselation information:
    // --------------------------------
    
    float *_curve_vertex;
    int    _nb_curve_vertex;
    float *_circle_vertex;
    int    _nb_circle_vertex; //Number of vertices per circle
    float  _base_normal[3];
    float  _end_normal[3];
    float  _radius_inverse;
    float *_TextureCoordinates; // Texture coordonnates.
    int _NumberOfTC;		//Number of texture coordinate.
		unsigned int _StorageID;
};
//******************************************************************************
//*** INLINED METHODS: *********************************************************
//******************************************************************************


inline void CAT3DCurvedPipeGP::GetTextureCoordinates (float **texture_coord)
{
  *texture_coord=_TextureCoordinates;  
}

inline void CAT3DCurvedPipeGP::GetTextureCoordinates (float ** oTextureCoord, int * oDimension)
{
  *oTextureCoord=_TextureCoordinates;
  *oDimension = 3;
}

inline void CAT3DCurvedPipeGP::SetStorageID(unsigned int iStorageID)
{
  _StorageID = iStorageID;
}

inline unsigned int CAT3DCurvedPipeGP::GetStorageID()
{
  return _StorageID;
}

inline unsigned int CAT3DCurvedPipeGP::StorageIDisValid()
{
  if (_StorageID==0 || _StorageID==INVALID_STORAGEID)
    return 0;
  else
    return 1;
}
#endif
</div>
    
    <div class="navigation">
        <div><a href="CAT3DCurveRep.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CAT3DCurveRep.h</a></div>
        <div><a href="CAT3DCustomRep.html">‰∏ã‰∏ÄÈ°µ: CAT3DCustomRep.h ‚Üí</a></div>
    </div>
</body>
</html>