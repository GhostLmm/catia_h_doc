<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeometricOperators/PublicInterfaces/CATIntersectionSurSur.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GeometricOperators/PublicInterfaces/CATIntersectionSurSur.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIntersectionCrvSur.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIntersectionCrvSur.h</a></div>
        <div><a href="CATLocalAnalysis1D.html">‰∏ã‰∏ÄÈ°µ: CATLocalAnalysis1D.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATINTERSECTSURSUR_H
#define CATINTERSECTSURSUR_H

// COPYRIGHT DASSAULT SYSTEMES  1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */ 

#include &quot;CATCreateIntersection.h&quot;
#include &quot;CATMathDef.h&quot;
#include &quot;CATMathSetOfPointsNDTwoTangents.h&quot;
#include &quot;CATSetOfSurParams.h&quot;
#include &quot;CATListOfCATPCurves.h&quot;
#include &quot;CATListOfCATEdgeCurves.h&quot;
#include &quot;CATIntersectionSign.h&quot;
#include &quot;CATIntersectionOrientation.h&quot;
#include &quot;CATGeoOperator.h&quot;
#include &quot;Y30C3XGG.h&quot;
#include &quot;CATPointOnEdgeCurve.h&quot;

class CATGeometry;
class CATSurface;
class CATCurve;
class CATPCurve;
class CATEdgeCurve;
class CATPlane;
class CATSurParam;
class CATSurLimits;
class CATMathBox;
class CATCartesianPoint;
class CATPointOnSurface;
class CATSetOfCrvParams;
class CATCGMAttribute;

/**
 * Class defining the operator of the intersection of two surfaces.
 *&lt;br&gt;The operator outputs the isolated solutions (points, curves) and the
 * overlapping solutions (surfaces).
 *&lt;ul&gt;
 *&lt;li&gt;The CATIntersectionSurSur operator is created with the &lt;tt&gt;CreateIntersection&lt;/tt&gt; method and 
 * directly &lt;tt&gt;delete&lt;/tt&gt;d with the usual C++ delete operator.
 * It is is not streamable. 
 *&lt;li&gt;In case of &lt;tt&gt;BASIC&lt;/tt&gt;
 * mode, the operation is automatically performed at the operator creation. 
 * In case of &lt;tt&gt;ADVANCED&lt;/tt&gt;
 * mode, options can be precised with the &lt;tt&gt;SetXxx&lt;/tt&gt; methods, before
 * asking for the computation with the &lt;tt&gt;Run&lt;/tt&gt; method. 
 *&lt;li&gt;In both cases, the result is accessed with specific interators, one for the solution points,
 * another for the solution curves and a last one for the solution surfaces.
 *&lt;/ul&gt;
 */
class ExportedByY30C3XGG CATIntersectionSurSur : public CATGeoOperator
{
  CATCGMVirtualDeclareClass(CATIntersectionSurSur);
 public:
/**
 * @nodoc
 * Use the &lt;tt&gt;CreateIntersection&lt;/tt&gt; global method.
 */
   CATIntersectionSurSur(CATGeoFactory * factory) ;

/**
 * Destructor.
 */
   virtual ~CATIntersectionSurSur() ;

/**
 * Returns the number of solution points.
 * @return
 * The number of solutions.
 */
   virtual CATLONG32 GetNumberOfPoints() const = 0;

/**
 * Returns the number of solution curves.
 * @return
 * The number of solutions.
 */
   virtual CATLONG32 GetNumberOfCurves() const = 0;

  /** @nodoc 
  * Do not use.
  */
   virtual CATLONG32 GetNumberOfCurveSolutions() const = 0;

/**
 * Returns the number of solution surfaces.
 * @return
 * The number of solutions.
 */
   virtual CATLONG32 GetNumberOfSurfaces() const = 0;

/**
 * @nodoc
 * Retrieves the definition points of the resulting curve.
 * @param oSet
 * The set of points.
 */
   virtual void GetDefinitionPoints(CATMathSetOfPointsNDTwoTangents &amp;oSet)
                                                                  const = 0;
  /** @nodoc 
  * Retrieves singular points on resulting Curve (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
  * &lt;br&gt; Init points must have been set before running operator (with method SetStartingPoints).
  * &lt;br&gt; Result Curve must already be created (GetCurve, GetPCurve, GetEdgeCurve).
  * @param oSetOfSingParams
  * The set of Curve parameters of singular points.
  * &lt;br&gt; To be deleted after use.
  */
  virtual void GetSingularPoints(CATSetOfCrvParams *&amp;oSetOfSingParams)=0 ;

  /** @nodoc
  * Retrieves exit points on resulting Curve (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
  * &lt;br&gt; Init points must have been set before running operator (with method SetStartingPoints).
  * &lt;br&gt; Result Curve must already be created (GetCurve, GetPCurve, GetEdgeCurve).
  * @param SetOfExitParams
  * The set of Curve parameters of init and exit points.
  * &lt;br&gt; To be deleted after use.
  */
  virtual void GetExitPoints(CATSetOfCrvParams *&amp;SetOfExitParams) =0;


  /** @nodoc 
  * Retrieves exit points on resulting Curve by index (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
  * &lt;br&gt; Init points must have been set before running operator (with method SetStartingPoints).
  * &lt;br&gt; Result Curve must already be created (GetCurve, GetPCurve, GetEdgeCurve).
  * @param ExitNumero
  * The index of point to retrieve.
  * @param ExitParam
  * The Curve parameter of the point.
  */
  virtual void GetExitPoint(CATLONG32 ExitNumero, CATCrvParam &amp;ExitParam) = 0;

  /** @nodoc 
  * Retrieves the indexes of exit points on resulting Curve in order of parametrization (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
  * &lt;br&gt; Init points must have been set before running operator (with method SetStartingPoints).
  * @return
  * The set of indexes.
  */
  virtual CATMathSetOfLongs* GetExitNumero() = 0;

  /** @nodoc
  * Retrieves the Init points that were set.
  * (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
  * @return
  * The set of Init points.
  */
  virtual CATMathSetOfPointsND * GetInitPoints()=0 ;


  /** @nodoc
  * Returns a diagnostic for TangentDesign of Surface boundaries, in the case of
  * Surface solution.
  * @param oCheckGap
  * Maximum gap of Curve compared to tolerance.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; gap is lower than 0.1*tolerance.&lt;/dl&gt;
  *     &lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt; &lt;/dt&gt;&lt;dd&gt; gap is greater than tolerance(10e-3)
  *     &lt;dt&gt;&lt;tt&gt;2&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; gap is greater than 0.1*tolerance(10e-4).&lt;/dl&gt;
  * @return
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt; &lt;/dt&gt;&lt;dd&gt; is tangent.
  *     &lt;dt&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt; isn&#x27;t tangent.&lt;/dl&gt;
  */
	virtual int GetTangentDiagnostic (int * oCheckGap) =0;

/**
 * Initializes the iterator of the resulting points.
 *&lt;br&gt;By default, the initialization is performed once the operator runs,
 * and this is therefore only used to read the solutions again.
 */
   virtual void BeginningPoint() = 0;

/**
 * Skips to the next solution point of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 *&lt;br&gt;After &lt;tt&gt;BeginningPoint&lt;/tt&gt;, it skips to the first point. 
 * @return
 * The existence of the next solution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 *&lt;dl&gt;&lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt; &lt;dd&gt;if there is a solution point
 *    &lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt; &lt;dd&gt;no more solution point.&lt;/dl&gt;
 */
   virtual CATBoolean NextPoint() = 0;

/**
 * Retrieves the parameters on each surface of the next solution point of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 * @param ioSurParam1
 * The parameter on the first surface.
 * @param ioSurParam2
 * The parameter on the second surface.
 */
   virtual void GetSurParam( CATSurParam &amp;ioSurParam1,
                             CATSurParam &amp;ioSurParam2 ) = 0;
/**
 * Creates the next solution point on a surface of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 * @param iSurface
 * The pointer to one of the intersecting surface.
 * @return
 * The pointer to the created point on surface. A new point is created each time this method is called.
 * If you do not want to keep the created point, use the @href CATICGMContainer#Remove method.
 */
   virtual CATPointOnSurface * GetPointOnSurface(CATSurface *iSurface) = 0;

/**
 * Creates the next solution point of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 * @return
 * The pointer to the created point. A new point is created each time this method is called.
 * If you do not want to keep the created point, use the @href CATICGMContainer#Remove method.
 */
   virtual CATCartesianPoint * GetCartesianPoint() = 0;

/**
 * Initializes the iterator of the solution curves of &lt;tt&gt;this&lt;/tt&gt; 
 * CATIntersectionSurSur operator.
 *&lt;br&gt;By default, the initialization is performed once the operator runs, 
 * and this is therefore only used to read the solutions again.
 */
   virtual void BeginningCurve() = 0;

/**
 * Skips to the next solution curve of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 *&lt;br&gt;After &lt;tt&gt;BeginningCurve&lt;/tt&gt;, it skips to the first curve. 
 * @return
 * The existence of the next solution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 *&lt;dl&gt;&lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt; &lt;dd&gt;if there is a solution curve
 *    &lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt; &lt;dd&gt;no more solution curve.&lt;/dl&gt;
 */
   virtual CATBoolean NextCurve() = 0;

/**
 * Creates the next solution curve of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 * @param iSurface
 * The pointer to the surface on which the curve is created.
 * @return
 * The pointer to the created curve on surface. A new curve is created each time this method is called.
 * If you do not want to keep the created curve, use the @href CATICGMContainer#Remove method.
 */
   virtual CATPCurve * GetPCurve(CATSurface *iSurface) = 0;

/**
 * Creates the next solution curve 
 * as a CATPCurve pointer.
 *&lt;br&gt;Creates the object if necessary.
 * @param iIndexOperand
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;dd&gt; on the first surface operand
 *    &lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;dd&gt; on the second surface operand&lt;/dl&gt;
 */
   virtual CATPCurve * GetPCurve(CATLONG32 iIndexOperand) = 0;

/**
 * Creates the next solution curve of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 * @return
 * The pointer to the created curve. A new curve is created each time this method is called.
 * If you do not want to keep the created curve, use the @href CATICGMContainer#Remove method.
 */
   virtual CATCurve * GetCurve() = 0;

/**
 * Creates the next solution curve as an edge curve.
 * @return
 * The pointer to the created edge curve, composed of a part of the two curves lying on each surface. 
 * A new curve is created each time this method is called.
 * If you do not want to keep the created curve, use the @href CATICGMContainer#Remove method.
 */
   virtual CATEdgeCurve * GetEdgeCurve() = 0;

/**
 * Creates the next solution curve as an edge curve.
 * @param oP1
 * The pointer to the created point representing the first extremity of the solution curve.
 * A new point is created each time this method is called.
 * If you do not want to keep the created point, use the @href CATICGMContainer#Remove method.
 * @param oP2
 * The pointer to the created point representing the last extremity of the solution curve.
 * A new point is created each time this method is called.
 * If you do not want to keep the created point, use the @href CATICGMContainer#Remove method.
 * @return
 * The pointer to the created edge curve, composed of a part of the two curves lying on each surface. 
 * A new curve is created each time this method is called.
 * If you do not want to keep the created curve, use the @href CATICGMContainer#Remove method.
 */
   virtual CATEdgeCurve * GetEdgeCurve(CATPointOnEdgeCurve *&amp;oP1, 
				       CATPointOnEdgeCurve *&amp;oP2) = 0;

/**
 * Returns the signature of the intersection edge with regards to the surface normals.
 * @param iSurface
 * The pointer to the surface (first or second operand) for which the signature
 * is returned.
 * @return
 * The signature on &lt;tt&gt;iSurface&lt;/tt&gt; such that:
 * Let the natural way of the intersection edge at the starting point being
 * such that the tangent at this point has the same direction as the
 * vector product of the normals of each surface. 
 *&lt;br&gt;Consider that the surface normal represents the outside of the matter
 * delimited by a surface. A positive signature implies that the resulting 
 * matter of the intersection is on the edge left.
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionSignPositive&lt;/tt&gt;&lt;dd&gt;The resulting 
 * matter of the intersection is on the edge left.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignNegative&lt;/tt&gt;&lt;dd&gt;The resulting 
 * matter of the intersection is on the edge right.
 * &lt;/dl&gt; 
 */
   virtual CATIntersectionSign GetSignatureOn(CATSurface *iSurface) = 0;

/**
 * @nodoc
 * Returns the crossing of the intersection edge 
 * with regards to the surface normals.
 * &lt;br&gt;Especially designed when the 2 surfaces are tangents.
 * @param iSurface
 * The pointer to the surface (first or second operand) for which the crossing
 * is returned.
 * @return
 *&lt;br&gt;Consider that the surface normal represents the outside of the matter
 * delimited by a surface.
 * The crossing on &lt;tt&gt;iSurface&lt;/tt&gt; can be :
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionCrossingTrue&lt;/tt&gt;&lt;dd&gt;When the intersection is frank.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionCrossingFalsePositive&lt;/tt&gt;&lt;dd&gt;
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionCrossingFalseNegative&lt;/tt&gt;&lt;dd&gt;
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionCrossingUnknown&lt;/tt&gt;&lt;dd&gt;&lt;/dl&gt;
 */
   virtual CATIntersectionCrossing GetCrossingOn(CATSurface *iSurface) = 0;

/**
 * @nodoc
 * Retrieves the index of starting and ending points of the result curve.
 * The numerotation of the result curve extremities is done as follows:
 * The index of first result curve begins at &lt;tt&gt;0&lt;/tt&gt;.
 * &lt;br&gt;If the curves dont share any extremity, the value of indexes are incremented:
 * (0,1), (2,3), ... (2*NbCurves-2, 2*NbCurves-1).
 * &lt;br&gt; If an extremity is common, the same value is assigned:
 * (0,1), (1,2) : the last point of the first curve is identical to the first point of
 * the second curve.
 * &lt;br&gt; If the curve is closed , result is (0, 0).
 */
   virtual void GetStartingPointsIndex( CATLONG32 &amp;oBegin, CATLONG32 &amp;oEnd ) = 0;

/**
 * Initializes the iterator of the solution surfaces.
 *&lt;br&gt;By default, the initialization is performed once the operator runs,
 * and this is therefore only used to read the solutions again.
 */
   virtual void BeginningSurface() = 0;

/**
 * Skips to the next solution surface of &lt;tt&gt;this&lt;/tt&gt; CATIntersectionSurSur operator.
 *&lt;br&gt;After &lt;tt&gt;BeginningSurface&lt;/tt&gt;, it skips to the first surface. 
 * @return
 * The existence of the next solution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 *&lt;dl&gt;&lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt; &lt;dd&gt;if there is a solution surface
 *    &lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt; &lt;dd&gt;no more solution surface.&lt;/dl&gt;
 */
   virtual CATBoolean NextSurface() = 0;

/**
 * Returns the boundaries of the next solution surface.
 * &lt;br&gt;The boundaries are given on one input surface.
 * @param iSurface
 * The pointer to the surface on which the curves are defined.
 * @param oListOfPCurvesOrientation
 * The array of pointers to the relative orientation of each PCurve with respect to the loop.
 * If &lt;tt&gt;NULL&lt;/tt&gt;, this is not output. This array is allocated by the method, you
 * have to &lt;tt&gt;delete&lt;/tt&gt; it after use.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationOpposite&lt;/tt&gt;
 * &lt;dd&gt;The orientation of the curve and the loop are opposite.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationSame&lt;/tt&gt;&lt;dd&gt;The loop and the curve have the same orientation.&lt;/dl&gt; 
 * @param oContourOrientation
 * The relative orientation of the loop generated by the CATPCurves and &lt;tt&gt;iSurface&lt;/tt&gt;. 
 * If &lt;tt&gt;NULL&lt;/tt&gt;, this is not output.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationOpposite&lt;/tt&gt;
 * &lt;dd&gt;The orientation of &lt;tt&gt;iSurface&lt;/tt&gt; and the loop are opposite.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationSame&lt;/tt&gt;&lt;dd&gt;&lt;tt&gt;iSurface&lt;/tt&gt; and the loop have the same orientation.&lt;/dl&gt; 
 * @return 
 * The list of the curves defining the boundary on &lt;tt&gt;iSurface&lt;/tt&gt;.
 */
   virtual CATLISTP(CATPCurve) GetSurfaceBoundaries(CATSurface *iSurface, 
            CATIntersectionOrientation **oListOfPCurvesOrientation = NULL,
                   CATIntersectionOrientation *oContourOrientation = NULL ) = 0;

 /**
 * Returns the boundaries of the next solution surface.
 * &lt;br&gt;The boundaries are given on both input surfaces.
 * @param oListOfPCurvesOrientation
 * The array of pointers to the relative orientation of each PCurve (on the first input surface,
 * then on the second input surface) with respect to the loop. 
 * If &lt;tt&gt;NULL&lt;/tt&gt;, this is not output. This array is allocated by the method, you
 * have to &lt;tt&gt;delete&lt;/tt&gt; it after use.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationOpposite&lt;/tt&gt;
 * &lt;dd&gt;The orientation of the curve and the loop are opposite.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationSame&lt;/tt&gt;&lt;dd&gt;The loop and the curve have the same orientation.&lt;/dl&gt; 
 * @param oContourOrientation1
 * The relative orientation of the loop generated by the CATPCurves and the first input surface. 
 * If &lt;tt&gt;NULL&lt;/tt&gt;, this is not output.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationOpposite&lt;/tt&gt;
 * &lt;dd&gt;The orientation of the first input surface and the loop are opposite.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationSame&lt;/tt&gt;&lt;dd&gt;The first input surface and the loop have the same orientation.&lt;/dl&gt; 
 * @param oContourOrientation2
 * The relative orientation of the loop generated by the CATPCurves and the second input surface. 
 * If &lt;tt&gt;NULL&lt;/tt&gt;, this is not output.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationOpposite&lt;/tt&gt;
 * &lt;dd&gt;The orientation of the second input surface and the loop are opposite.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionOrientationSame&lt;/tt&gt;&lt;dd&gt;The second input surface and the loop have the same orientation.&lt;/dl&gt; 
 * @return 
 * The list of the edge curves defining the boundary, 
 * each edge curve representing the PCurves on each input surface. 
 */                                                                
   virtual CATLISTP(CATEdgeCurve) GetSurfaceBoundaries( 
                 CATIntersectionOrientation **oListOfPCurvesOrientation,
                 CATIntersectionOrientation *oContourOrientation1,
                 CATIntersectionOrientation *oContourOrientation2 ) = 0;
/**
 * @nodoc
 * Same as previous with Indexes of the curves of the loop.
 */
    virtual CATLISTP(CATEdgeCurve) GetSurfaceBoundaries( 
                 CATIntersectionOrientation **oListOfPCurvesOrientation,
                 CATIntersectionOrientation *oContourOrientation1,
                 CATIntersectionOrientation *oContourOrientation2,
                 CATLONG32 * &amp; oStartIndexes, CATLONG32 * &amp; oEndIndexes) = 0;
/**
 * @nodoc
 * Defines the intersection with another second surface (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
 * @param iNewSecondSurface
 * The pointer to the new second surface.
 */
   virtual void SetSurface( CATSurface *iNewSecondSurface ) = 0;

/**
 * @nodoc
 * Set a 3D Box in which the solutions have to be searched (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
 * One may calculate this box intersecting the 3D Boxes of the 2 limited surfaces.
 * @param i3DBox
 * The 3D box in which to search.
 */
   virtual void SearchInBox(const CATMathBox&amp; i3DBox) = 0;

/**
 * Modifies the surface domains to take into account for &lt;tt&gt;this&lt;/tt&gt;
 * CATIntersectionSurSur operator (&lt;tt&gt;ADVANCED&lt;/tt&gt; mode).
 *&lt;br&gt; It does not change the current surface limitations.
 * @param iNewLimitsForSurface1
 * The pointer to the new domain of the first surface. If &lt;tt&gt;NULL&lt;/tt&gt;, the current limitation of the first
 * curve is used.
 * @param iNewLimitsForSurface2
 * The pointer to the new domain of the second surface. If &lt;tt&gt;NULL&lt;/tt&gt;, the current limitation of the second
 * curve is used.
 */
  virtual void SetLimits (CATSurLimits  * iNewLimitsForSurface1,
			  CATSurLimits  * iNewLimitsForSurface2) = 0;

 /** @nodoc 
 * Same as precedent method SetLimits.
  */
  virtual void HoldDomain(CATSurLimits *iNewLimitsForSurface1,
			  CATSurLimits *iNewLimitsForSurface2) = 0;

      /* Caution : the following method has priority on the previous above SetLimits */
      /* ie the solution can go out of the held domain                     */
      /* In the case of HoldDomain, an error is thrown and no solution is returned */

/**
 * @nodoc
 * Extrapolates the CATIntersectionSurSur solution until one of the operands boundary.
 *&lt;br&gt;This method has priority on the &lt;tt&gt;HoldDomain&lt;/tt&gt; method: the solution
 * can go outside the domain defined by &lt;tt&gt;HoldDomain&lt;/tt&gt;.
 *&lt;br&gt; The &lt;tt&gt;Run&lt;/tt&gt; method then should be called before reading solutions.
 */
   virtual void ReachBoundaryOf( CATSurface *iSurface ) = 0;

  /** @nodoc 
   * Same method as above, with index of surface as input.
   * @param IndexOperand
   * Index of surface to extrapolate to.
   * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *&lt;dl&gt;&lt;dt&gt;&lt;tt&gt;0&lt;/tt&gt; &lt;dd&gt; First surface defined at operator creation.
   *    &lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt; &lt;dd&gt; Second surface defined at operator creation.&lt;/dl&gt;
   */
   virtual void ReachBoundaryOf(CATLONG32 IndexOperand) = 0;

/**
 * @nodoc
 * Do not use. For specific use only.
 * Authorize solutions close from a boundary to go out of the domain.
 */
   virtual void SetExtrapol( CATBoolean iBoolean) = 0;

/**
 * @nodoc
 * Imposes initial and/or final points of the resulting surface of
 * a CATIntersectionSurSur operator. 
 *&lt;br&gt;In case of &lt;tt&gt;ADVANCED&lt;/tt&gt; mode.
 * @param iSetOfInitParamsOnSurface1
 * The pointer to a CATSetOfSurParam containing initial and/or final
 * points of the solution on the first surface.
 * @param iSetOfInitParamsOnSurface2
 * The pointer to a CATSetOfSurParam containing initial and/or final
 * points of the solution on the second surface, they should be identical in
 * space with those of the previous CATSetOfSurparam.
 *&lt;br&gt; This argument and the following one give the 
 * definition of the pieces of the CATIntersectionSurSur.
 * @param iStartingSignatureOnFirstSurface
 * The driving direction of the intersection edge on the first surface
 * with regards to each surface
 * normals at each points of &lt;tt&gt;iSetOfInitPoints&lt;/tt&gt;.
 * The natural way of the intersection edge at the starting point
 * is such that the tangent at this point has the same direction as the
 * vector product of the normals of each surface. 
 *&lt;br&gt;Consider that the surface normal represents the outside of the matter
 * delimited by a surface. A positive signature implies that the resulting 
 * matter of the intersection is on the edge left.
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;CATIntersectionSignPositive&lt;/tt&gt;&lt;dd&gt;The resulting 
 * matter of the intersection is on the edge left.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignNegative&lt;/tt&gt;&lt;dd&gt;The resulting 
 * matter of the intersection is on the edge right.
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignSameDirection&lt;/tt&gt;&lt;dd&gt; 
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignOppositeDirection&lt;/tt&gt;&lt;dd&gt;
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignUnknown&lt;/tt&gt;&lt;dd&gt;
 *     &lt;dt&gt;&lt;tt&gt;CATIntersectionSignUnset&lt;/tt&gt;&lt;dd&gt;&lt;/dl&gt; 
 * @param iTangents
 * When the signature is NonCrossing type, a dimension 3 vector 
 * has to be given to indicate the starting direction.
 * @param iLoopSearch
 * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;1&lt;/tt&gt;&lt;dd&gt;search of the scalop (loop) configurations
 *     &lt;dt&gt;&lt;tt&gt;0&lt;/tt&gt;&lt;dd&gt;otherwise &lt;/dl&gt; 
 *&lt;br&gt; The &lt;tt&gt;Run&lt;/tt&gt; method then should be called before reading solutions.
 */

   virtual void SetStartingPoints(
                        CATSetOfSurParams &amp;iSetOfInitParamsOnSurface1,
                        CATSetOfSurParams &amp;iSetOfInitParamsOnSurface2,
                        CATIntersectionSign *iStartingSignatureOnFirstSurface,
                        double *iTangents = NULL,
                        CATBoolean LoopSearch = 1 ) = 0;

/**
 * @nodoc
 * When one the surfaces is a plane and only the PCurve on the plane is required, enable
 * canonic solution on the plane.
 */ 
  virtual void SetCanonicalPCurveOnPlane() = 0;

  /** @nodoc 
  * Do not use.
  */
	virtual void SetUnstableWarning() = 0;

  /** @nodoc 
  * Asks operator not to cut the result Curve when crossing the Init points.
  */
  virtual void SetNonCutting(CATBoolean iDoNotCut=1)= 0;

  /** @nodoc 
  * Asks operator to keep result Curve in between Init points.
  */
  virtual void SetOnlyBetweenInits(CATBoolean iOnlyBetweenInits=1)= 0;

  /** @nodoc 
  * Asks operator to reconverge Init points if necessary.
  */
  virtual void SetConvergeInit(CATBoolean iReconv=1)= 0;

  /** @nodoc 
  * Asks operator to try for linear solutions.
  * &lt;br&gt; They are curves where the surfaces are tangent at each point.
  */
  virtual void SetTangentSol(CATBoolean iBoolean=1)= 0;

  /** @nodoc
  * Do not use.
  */
  virtual void SetAttribute(CATSurface * iSurface, CATCGMAttribute * iAttribute);

  /** @nodoc 
  * Do not use.
  */
  virtual CATCGMAttribute * GetAttribute(CATSurface * iSurface);

  /** @nodoc
  * For performance optimization.
  */
  virtual void SetOptimizedAttribute();
};

#include &quot;CreateIntersection.h&quot;
/** @nodoc */
ExportedByY30C3XGG
CATLONG32 CATIntersectionIsNull(CATSurface *iSurface1, CATSurface *iSurface2,
                           CATSurParam &amp;iParam1, CATSurParam &amp;iParam2,
                           CATSoftwareConfiguration* iConfig=NULL);
#endif
</div>
    
    <div class="navigation">
        <div><a href="CATIntersectionCrvSur.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIntersectionCrvSur.h</a></div>
        <div><a href="CATLocalAnalysis1D.html">‰∏ã‰∏ÄÈ°µ: CATLocalAnalysis1D.h ‚Üí</a></div>
    </div>
</body>
</html>