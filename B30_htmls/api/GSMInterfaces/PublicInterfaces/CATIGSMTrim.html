<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GSMInterfaces/PublicInterfaces/CATIGSMTrim.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>GSMInterfaces/PublicInterfaces/CATIGSMTrim.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIGSMTranslate.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIGSMTranslate.h</a></div>
        <div><a href="CATIGSMUIFactory.html">‰∏ã‰∏ÄÈ°µ: CATIGSMUIFactory.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/* -*-c++-*- */
#ifndef CATIGSMTrim_H
#define CATIGSMTrim_H
// 
// COPYRIGHT DASSAULT SYSTEMES 1999

/**
  * @CAA2Level L1
  * @CAA2Usage U3
  */

#include &quot;CATGitInterfacesExportedBy.h&quot;
#include &quot;CATISpecObject.h&quot;
#include &quot;CATGSMOrientation.h&quot;
#include &quot;CATListOfInt.h&quot;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATGitInterfaces IID  IID_CATIGSMTrim;
#else
extern &quot;C&quot; const IID IID_CATIGSMTrim;
#endif

/**
 * Interface to trim feature. 
 * &lt;b&gt;Role&lt;/b&gt;: Allows you to access data of the Trim feature created by using 
 * two elements (two curves or two surfaces) and two orientations
 * @see CATIGSMFactory#CreateTrim
 */
class ExportedByCATGitInterfaces CATIGSMTrim : public CATBaseUnknown
{
   CATDeclareInterface;

public: 

  /**
    * @deprecated V5R17 CATIGSMTrim#GetElem
    * Gets the first feature to trim (a curve or surface).
    *   @param oElem
    *      first feature to trim
    */
 virtual    HRESULT GetFirstElem(CATISpecObject_var &amp; oElem) = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#SetElem
    * Sets the first feature to trim (a curve or surface).
    *   @param iElem
    *      first feature to trim
    */
 virtual    HRESULT SetFirstElem(const CATISpecObject_var iElem) = 0;
 
  /**
    * @deprecated V5R17 CATIGSMTrim#GetElem
    * Gets the second feature to trim (a curve or surface).
    *   @param oElem
    *      second feature to cut
    */
 virtual    HRESULT GetSecondElem(CATISpecObject_var &amp; oElem) = 0; 

  /**
    * @deprecated V5R17 CATIGSMTrim#SetElem
    * Sets the second feature to trim (a curve or surface).
    *   @param iElem
    *      second feature to cut
    */
 virtual    HRESULT SetSecondElem(const CATISpecObject_var iElem) = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#GetNextOrientation
    * Gets the first orientation used to compute the trim.
    * Orientation specifies kept parts of first feature.&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming surfaces :&lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are specified by the &quot;natural&quot; normal to the second feature&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are specified by the inverse of the &quot;natural&quot; normal to the second feature&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves (without support): &lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are from beginning of the curve to the first intersection, &lt;BR&gt; 
    * and ,if there is one, from the second to the third intersection and so on until the end of the curve...&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are from the first intersection to the second (if there is one), &lt;BR&gt; 
    * and, if there is one, from the third to the fourth and so on until the end of the curve...&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves on support: &lt;BR&gt; 
    * - If CATGSMSameOrientation: &lt;BR&gt;
	*   Kept parts of the first curve are specified by the result of the cross product : normal(support surface)^tangent(second curve)&lt;BR&gt; 
    * - If CATGSMInvertOrientation:  &lt;BR&gt;
	*   Kept parts of the first curve are specified by the inverse of the result of the cross product : normal(support surface)^tangent(second curve)&lt;BR&gt; 
    *&lt;BR&gt; 
    *   @param oOrientation
    *      first orientation used to compute the trim
    */
 virtual    HRESULT GetFirstOrientation(CATGSMOrientation &amp; oOrientation) = 0;
 
   /**
    * @deprecated V5R17 CATIGSMTrim#SetNextOrientation(1)
    * Sets the first orientation used to compute the trim.
    * Orientation specifies kept parts of first feature.&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming surfaces :&lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are specified by the &quot;natural&quot; normal to the second feature&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are specified by the inverse of the &quot;natural&quot; normal to the second feature&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves (without support): &lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are from beginning of the curve to the first intersection, &lt;BR&gt; 
    * and ,if there is one, from the second to the third intersection and so on until the end of the curve...&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are from the first intersection to the second (if there is one), &lt;BR&gt; 
    * and, if there is one, from the third to the fourth and so on until the end of the curve...&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves on support: &lt;BR&gt; 
    * - If CATGSMSameOrientation: &lt;BR&gt;
	*   Kept parts of the first curve are specified by the result of the cross product : normal(support surface)^tangent(second curve)&lt;BR&gt; 
    * - If CATGSMInvertOrientation:  &lt;BR&gt;
	*   Kept parts of the first curve are specified by the inverse of the result of the cross product : normal(support surface)^tangent(second curve)&lt;BR&gt; 
    *&lt;BR&gt; 
    *   @param iOrientation
    *      first orientation used to compute the trim
    */
 virtual    HRESULT SetFirstOrientation(CATGSMOrientation iOrientation) = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#GetPreviousOrientation
    * Gets the second orientation used to compute the trim.
    * Orientation specifies kept parts of second feature.&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming surfaces :&lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are specified by the &quot;natural&quot; normal to the first feature&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are specified by the inverse of the &quot;natural&quot; normal to the first feature&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves (without support):&lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are from beginning of the curve to the first intersection, &lt;BR&gt; 
    * and ,if there is one, from the second to the third intersection and so on until the end of the curve...&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are from the first intersection to the second (if there is one), &lt;BR&gt; 
    * and, if there is one, from the third to the fourth and so on until the end of the curve...&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves on support: &lt;BR&gt; 
    * - If CATGSMSameOrientation: &lt;BR&gt;
	*   Kept parts of the second curve are specified by the result of the cross product : normal(support surface)^tangent(first curve)&lt;BR&gt; 
    * - If CATGSMInvertOrientation:  &lt;BR&gt;
	*   Kept parts of the second curve are specified by the inverse of the result of the cross product : normal(support surface)^tangent(first curve)&lt;BR&gt; 
    *&lt;BR&gt; 
    *   @param oOrientation
    *      second orientation used to compute the trim
    */
 virtual    HRESULT GetSecondOrientation(CATGSMOrientation &amp; oOrientation) = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#SetPreviousOrientation(1)
    * Sets the second orientation used to compute the trim.
    * Orientation specifies kept parts of second feature.&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming surfaces :&lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are specified by the &quot;natural&quot; normal to the first feature&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are specified by the inverse of the &quot;natural&quot; normal to the first feature&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves  (without support): &lt;BR&gt; 
    * - If CATGSMSameOrientation: Kept parts are from beginning of the curve to the first intersection, &lt;BR&gt; 
    * and ,if there is one, from the second to the third intersection and so on until the end of the curve...&lt;BR&gt; 
    * - If CATGSMInvertOrientation: Kept parts are from the first intersection to the second (if there is one), &lt;BR&gt; 
    * and, if there is one, from the third to the fourth and so on until the end of the curve...&lt;BR&gt; 
    *&lt;BR&gt; 
    * When trimming curves on support: &lt;BR&gt; 
    * - If CATGSMSameOrientation: &lt;BR&gt;
	*   Kept parts of the second curve are specified by the result of the cross product : normal(support surface)^tangent(first curve)&lt;BR&gt; 
    * - If CATGSMInvertOrientation:  &lt;BR&gt;
	*   Kept parts of the second curve are specified by the inverse of the result of the cross product : normal(support surface)^tangent(first curve)&lt;BR&gt; 
    *&lt;BR&gt; 
    *   @param iOrientation
    *      second orientation used to compute the trim
    */
 virtual    HRESULT SetSecondOrientation(CATGSMOrientation iOrientation) = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#InvertNextOrientation
    * Inverts the first orientation used to compute the trim. 
    */
 virtual    HRESULT InvertFirstOrientation() = 0;

  /**
    * @deprecated V5R17 CATIGSMTrim#InvertPreviousOrientation
    * Inverts the second orientation used to compute the trim. 
    */
 virtual    HRESULT InvertSecondOrientation() = 0;
	
  /**
    * Queries whether resulting topology is simplified or not.
    *   @param oMode
    *      Simplification option on (TRUE) or off (FALSE)
    */
 virtual    HRESULT GetSimplify(CATBoolean &amp; oMode) = 0;
	
  /**
    * Sets or unsets the simplification of the resulting topology.
    *   @param iMode
    *      Simplification option on (TRUE) or off (FALSE)
    */
 virtual    HRESULT  SetSimplify(CATBoolean iMode) = 0;
	
   /**
	 * Gets the support of the curves to trim (optional).
     *   @param oElem
     *      Support surface
     */
 virtual    HRESULT GetSupportElem(CATISpecObject_var &amp; oElem) = 0;
	
   /**
     * Sets the support of the curves to trim (optional).
     *   @param iElem
     *      Support surface
     */
 virtual    HRESULT SetSupportElem(const CATISpecObject_var iElem) = 0;


	
  /**
    * Sets or unsets the computation of intersection.
    *   @param iMode
    *      Computation option on (TRUE) or off (FALSE)
    */
 virtual    HRESULT  SetIntersectionComputation(CATBoolean iMode) = 0;

 /**
    * Queries whether intersection is computed or not.
    *   @param oMode
    *      Computation option on (TRUE) or off (FALSE)
    */
 virtual    HRESULT GetIntersectionComputation(CATBoolean &amp; oMode) = 0;
  /**
    * Gets the intersection.
    *    @param oElem
    *       Intersection
    */
 virtual    HRESULT GetIntersection(CATISpecObject_var &amp; oElem) = 0;


 /**
  * Adds an element to specifications. This element will be removed.
  * @param iElement
  *   Element to remove.  
  */ 
 virtual HRESULT AddElementToRemove(const CATISpecObject_var iElement) = 0;

 /**
  * Removes an element from specifications.
  * @param iRank
  *   Index of the removed element.
  */ 
 virtual HRESULT RemoveElementToRemove(const int iRank) = 0;

 /**
  * Adds an element to specifications. This element will be kept.
  * @param iElement
  *   Element to keep.  
  */ 
 virtual HRESULT AddElementToKeep(const CATISpecObject_var iElement) = 0;

 /**
  * Removes an element from specifications.
  * @param iRank
  *   Index of the kept element.
  */ 
 virtual HRESULT RemoveElementToKeep(const int iRank) = 0;

 /**
  * Gets the number of elements to remove.
  *   @param oNbElementsToRemove
  *      Number of elements to remove
  */
 virtual    HRESULT GetNbElementsToRemove(int &amp; oNbElementsToRemove) = 0;

 /**
  * Gets the number of elements to keep.
  *   @param oNbElementsToKeep
  *      Number of elements to keep
  */
 virtual    HRESULT GetNbElementsToKeep(int &amp; oNbElementsToKeep) = 0;

 /**
  * Gets the removed feature at a given index.
  *   @param oElem
  *      Removed feature 
  *   @param iRank
  *      Index of one of the removed features  
  */
 virtual    HRESULT GetRemovedElem(CATISpecObject_var &amp; oElem, const int iRank) = 0;

 /**
  * Gets the kept feature at a given index.
  *   @param oElem
  *      Kept feature 
  *   @param iRank
  *      Index of one of the kept features  
  */
 virtual    HRESULT GetKeptElem(CATISpecObject_var &amp; oElem, const int iRank) = 0;

 
 /**
    * Sets or unsets the automatic extrapolation mode.
    *   @param iMode
    *      Extrapolation mode on (TRUE) or off (FALSE)
    */
 virtual    HRESULT  SetAutomaticExtrapolationMode(CATBoolean iMode) = 0;

 /**
    * Queries whether automatic extrapolation mode is activated or not.
    *   @param oMode
    *      Extrapolation mode on (TRUE) or off (FALSE)
    */
 virtual    HRESULT GetAutomaticExtrapolationMode(CATBoolean &amp; oMode) = 0;


 /**
 * Gets the number of elements: couple(element, index of portion to keep on element).
 *   @param oNbElem
 *      Number of elements  
 */
 virtual    HRESULT GetNbElem(int &amp;oNbElem) = 0;

 /**
 * Gets the trimmed feature at a given index.  
 *   @param oElem
 *      trimmed feature 
 *   @param iRank
 *      Index of one of the trimmed features  
 */
 virtual    HRESULT GetElem(CATISpecObject_var &amp; oElem, const int iRank) = 0;

/**
 * Gets the list of trimmed features, removing duplicated.
 * @param oElems
 *   The list of trimmed features
 */ 
 virtual    HRESULT GetElems(CATLISTV(CATISpecObject_var) &amp; oElems) = 0;
 
 /**
 * Modifies the trimmed feature at a given index.  
 * Use AddElem method to specify a new trimmed element
 *   @param iElem
 *      trimmed feature 
 *   @param iRank
 *      Index of one of the trimmed features  
 */
 virtual    HRESULT SetElem(const CATISpecObject_var iElem, const int iRank) = 0;
 
 /**
 * Appends an element to trim.
 *   @param iElem
 *      feature to trim
 */
 virtual    HRESULT AddElem(const CATISpecObject_var &amp; iElem) = 0;
 
 /**
 * Removes a feature at a given index.
 *   @param iRank 
 *      index of the feature 
 */
 virtual    HRESULT RemoveElem (const int iRank) = 0;
 
 /**
 * Inserts an element.
 * @param iPosition 
 *   The position of the element in the list of elements.
 * @param iElem
 *   the element. 
 */ 
 virtual HRESULT InsertElem(const CATISpecObject_var iElem, const int iPosition) = 0;
 
 /**
 * Gets Orientation used to compute the feature, referring to the previous trimmed element.
 *   @param oOrientation  
 *      Orientation
 *   @param iRank 
 *      index (of one of the trimmed features) - 1
 *      iRank must be greater than 1 and lower than the number of elements - 1 
 */
 virtual    HRESULT GetPreviousOrientation(CATGSMOrientation &amp; oOrientation, const int iRank=1) = 0;
 
 /**
 * Gets Orientation used to compute the feature, referring to the next trimmed element.
 *   @param oOrientation  
 *      Orientation
 *   @param iRank 
 *      index (of one of the trimmed features) - 1
 *      iRank must be greater than 1 and lower than the number of elements - 1 
 */
 virtual    HRESULT GetNextOrientation(CATGSMOrientation &amp; oOrientation, const int iRank=1) = 0;
 
 /**
 * Sets the orientation used to compute the feature, referring to the previous trimmed element.
 *   @param iOrientation  
 *      Orientation
 *   @param iRank 
 *      index (of one of the trimmed features) - 1
 *      iRank must be greater than 1 and lower than the number of elements - 1 
 */
 virtual    HRESULT SetPreviousOrientation(CATGSMOrientation iOrientation, int iRank) = 0;

 /**
 * Sets the orientation used to compute the feature, referring to the next trimmed element.
 *   @param iOrientation  
 *      Orientation
 *   @param iRank 
 *      index (of one of the trimmed features) - 1
 *      iRank must be greater than 1 and lower than the number of elements - 1 
 */
 virtual    HRESULT SetNextOrientation(CATGSMOrientation iOrientation, int iRank) = 0;
 
 /**
 * Inverts the orientation used to compute the trim refering the previous trimmed element.
 */
 virtual    HRESULT InvertPreviousOrientation(const int iRank=1) = 0;
 /**
 * Inverts the orientation used to compute the trim refering the next trimmed element.
 */
 virtual    HRESULT InvertNextOrientation(const int iRank=1) = 0;

	
 /**
 * Sets Trim mode.
 *   @param iMode
 *      =1   Standard
 *      =2   Pieces
 */
 virtual    HRESULT  SetMode(const int iMode) = 0;

 /**
 * Gets Trim mode.
 *   @param oMode
 *      =1   Standard
 *      =2   Pieces
 */
 virtual    HRESULT  GetMode(int&amp; oMode) = 0;
 
 /**
 * Sets a portion to keep number in Pieces mode.
 * Used for the trim pieces of wires only
 *   @param iPortionNumber
 *      Index of portion to keep on the element
 *   @param iRank
 *      Index of the trimmed element
 */
 virtual    HRESULT SetPortionToKeep( const int iPortionNumber, const int iRank) = 0;
 
 /**
 * Gets a portion to keep number, giving the index of the element.
 * Used for the trim pieces of wires only
 *   @param oPortionNumber
 *      Index of portion to keep on the element
 *   @param iRank
 *      Index of the trimmed element
 */
 virtual    HRESULT GetPortionToKeep( int&amp; oPortionNumber, const int iRank) = 0;
 
 /**
 * Sets the number of intersections with the other elements, in Pieces mode.
 * Used for the trim pieces of wires only
 * If iNumberOfIntersections&lt;0, No check of the number of intersections at Update
 *   @param iElem
 *      trimmed feature 
 *   @param iNumberOfIntersections
 *      Number of intersections
 */
 virtual    HRESULT SetNumberOfIntersections( const CATISpecObject_var iElem, const int iNbIntersections) = 0;
 
 /**
 * Gets the number of intersections with the other elements, the index of the element, in Pieces mode.
 * Used for the trim pieces of wires only
 * If iNumberOfIntersections&lt;0, No check of the number of intersections at Update
 *   @param iElem
 *      trimmed feature 
 *   @param oNbIntersections
 *      Number of intersections
 */
 virtual    HRESULT GetNumberOfIntersections( const CATISpecObject_var iElem, int&amp; oNbIntersections) =0;
 
 /**
 * Sets the pieces cutters.
 * Used for the trim pieces of shells only
 *   @param iRank
       Index of the trimmed element (piece)
 *   @param iListCuttersIndex
       List of index corresponding of input shell index in &#x27;GetElems&#x27; list, that relimit the piece
       except in case of multiple intersection between shells
       where Index=IndexInputShell+NbInputShells*(1-iw) 
       (whith iw=1... : wire index in case of multiple intersection)
 *   @param iListOrientations
       list of corresponding orientations (list of CATGSMOrientation)
 */
 virtual    HRESULT SetPieceCutters(const int iRank, const CATListOfInt &amp; iListCuttersIndex, const CATListOfInt &amp; iListOrientations) = 0;

 /**
 * Gets the pieces cutters.
 * Used for the trim pieces of shells only
 *   @param iRank
       Index of the trimmed element (piece)
 *   @param oListCuttersIndex
       List of index corresponding of input shell index in &#x27;GetElems&#x27; list, that relimit the piece
       except in case of multiple intersection between shells
       where Index=IndexInputShell+NbInputShells*(1-iw) 
       (whith iw=1... : wire index in case of multiple intersection)
 *   @param oListOrientations
       list of corresponding orientations (list of CATGSMOrientation)
 */
 virtual    HRESULT GetPieceCutters(const int iRank, CATListOfInt &amp; oListCuttersIndex, CATListOfInt &amp; oListOrientations) = 0;

 /**
 * Gets the discrimination index.
 * Used for the trim pieces of shells only
 *   @param iRank
 *    Index of the trimmed element (piece)
 *   @param oIndex
 *    Discrimination Index
 *    Used to discrimine pieces when cutters orientations are not enough
 */
 virtual    HRESULT GetPieceDiscriminationIndex(const int iRank, int &amp; oIndex) = 0;

 /**
 * Sets the discrimination index.
 * Used for the trim pieces of shells only
 *   @param iRank
 *    Index of the trimmed element (piece)
 *   @param iIndex
 *    Discrimination Index
 *    Used to discrimine pieces when cutters orientations are not enough
 */
 virtual    HRESULT SetPieceDiscriminationIndex(const int iRank, int iIndex) = 0;

 /**
 * Sets keep all pieces mode.
 * Used for the trim pieces of shells only
 *   @param iKeepAllPieces
 *      CATTrue : all the pieces are kept during update,
 *      CATFalse : only chosen pieces are kept during update (default).
 *   @see CATBoolean
 */ 
 virtual  HRESULT SetKeepAllPiecesMode(CATBoolean iKeepAllPieces) = 0;

 /**
 * Gets keep all pieces mode.
 * Used for the trim pieces of shells only
 *   @param oKeepAllPieces
 *      CATTrue : all the pieces are kept during update,
 *      CATFalse : only chosen pieces are kept during update (default).
 *   @see CATBoolean
 */ 
 virtual  HRESULT GetKeepAllPiecesMode(CATBoolean &amp; oKeepAllPieces) = 0;

 /**
 * Sets the connected mode.
 *   @param iConnex
 *      CATTrue  = the check of connexity is enable,
 *      CATFalse = the check of connexity is disable.
 *   @see CATBoolean
 */ 
 virtual    HRESULT SetConnexMode(CATBoolean iConnex) = 0;
 /**
 * Gets the connected mode.
 *   @param oConnex
 *      CATFalse = non connected elements,
 *      CATTrue  = only connected elements
 *   @see CATBoolean
 */   
 virtual    HRESULT GetConnexMode(CATBoolean &amp; oConnex) = 0;
 
 /**
 * Sets the Manifold mode.
 *   @param iIsManifold
 *      CATFalse = the check is not performed (non manifold result is allowed),
 *      CATTrue  = the check is performed.
 *   @see CATBoolean
 */ 
 virtual    HRESULT SetManifoldMode(CATBoolean iIsManifold) = 0;
 /**
 * Gets the Manifold mode.
 *   @param oIsManifold
 *      CATFalse = the check is not performed (non manifold result is allowed),
 *      CATTrue  = the check is performed.
 *   @see CATBoolean
 */   
 virtual    HRESULT GetManifoldMode(CATBoolean &amp; oIsManifold) = 0;


 /**
 * Migrate binary feature to Standard mode.
 */
 virtual    HRESULT MigrateFromBinary() = 0;


};

CATDeclareHandler (CATIGSMTrim, CATBaseUnknown);
#endif // CATIGSMTrim_H
</div>
    
    <div class="navigation">
        <div><a href="CATIGSMTranslate.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIGSMTranslate.h</a></div>
        <div><a href="CATIGSMUIFactory.html">‰∏ã‰∏ÄÈ°µ: CATIGSMUIFactory.h ‚Üí</a></div>
    </div>
</body>
</html>