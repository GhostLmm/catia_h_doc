<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DNBHumanModelingInterfaces/PublicInterfaces/SWKISegment.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DNBHumanModelingInterfaces/PublicInterfaces/SWKISegment.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="SWKIRULASpecs.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SWKIRULASpecs.h</a></div>
        <div><a href="SWKISegment3DVisu.html">‰∏ã‰∏ÄÈ°µ: SWKISegment3DVisu.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">// COPYRIGHT DASSAULT SYSTEMES 2003
#ifndef SWKISegment_h
#define SWKISegment_h

/**
 * @CAA2Level L0
 * @CAA2Usage U0
 */

// *****************************************************************************
// Framework DNBHumanModelingInterfaces
// Copyright Safework Inc.
// *****************************************************************************
//  Abstract:
//  ---------
//    SWKISegment interface.
//    This interface offers non-IDL segment services.
// *****************************************************************************
//  Usage:
//  ------
//
// *****************************************************************************
//  Inheritance:
//  ------------
//
//    SWKIBodyElement
//
// *****************************************************************************
//  Main Methods:
//  -------------
//
//    SetInternalSegment
//    GetNumberOfChildren
//    GetChildAtIndex
//    GetNumberOfEllipses
//    GetEllipseAtIndex
//    GetEllipse
//    GetBody
//    GetChild
//    GetAncestor
//    GetSpineSegment
//    IsAncestor
//    IsDescendant
//    IsOnLeftSide
//    IsOnRightSide
//    IsPartOfSpine
//    IsPartOfCervical
//    GetMirrorSegment
//    GetNumberOfDOFs
//    GetDOFAtIndex
//    GetBeginPoint
//    GetEndPoint
//    GetBeginPointInGlobal
//    GetEndPointInGlobal
//    ResetPosture
//    MirrorCopyPosture
//    SwapPosture
//    ResetPrefAngles
//    MirrorCopyPrefAngles
//    SwapPrefAngles
//    RemoveLimits
//    ResetAngularLimitations
//    MirrorCopyAngularLimitations
//    SwapAngularLimitations
//    LockPosture
//    Optimize
//    SetPercentage
//    KeepLockStateForPasteFrom
//    GetDirection
//    GetDirectionInGlobal
//    GetLength
//    GetNumberOfMeshes
//    GetMeshAtIndex
//    GetWorstPosturalScoreDOF
//    SetFatherNode
//    GetFatherNode
//    GetIKPositionInGlobal
//    GetDefaultIKOffset
//    GetIKOffset
//    GetSegmentOffset
//    HasIKOffset
//    IsSAEHPointOffset
//    InitializeEllipses
//    InternalSettings
//    GetNameWithoutSide
//    FindStartSegment
//    GetNbHierarchies
//    GetHierarchyAtIndex
//    GetHierarchiesIndexes
//    GetPathToTexture
//    GetTextureScale
//    GetTextureOffset
//    SetSubDMode
//    GetSubDMode
//    RefreshSubDRep
//    GetPreviousPosition
//    MarkAncestors
//    MarkChildren
// *****************************************************************************
//  History
//  -------
//
//  Author: Jean-Guy AUGUSTIN
//  Date  : 00/02/18
//  Goal  : Creation
// *****************************************************************************
//
// --- DNBHumanModelingInterfaces
#include &quot;SWKEnums.h&quot;
#include &quot;SWKIBodyElement.h&quot;
//
// --- System
#include &quot;CATListOfInt.h&quot;
//
// --- DNBHumanModeling
class SWSegment;
class SWMesh;
//
// --- DNBHumanModelingInterfaces
class SWKIBody;
class SWKIDOF;
class SWKIEllipse;
class SWKISegmentNode;
class SWKISegmentOffset;
//
// --- ObjectModelerBase
class CATIContainer;
//
// --- ObjectSpecsModeler
class CATISpecObject;
//
// --- Mathematics
class CATMathDirection;
class CATMathPoint;

#ifdef _WINDOWS_SOURCE
#ifdef __SWKHumanModelingItf
#define ExportedBySWKHumanModelingItf __declspec(dllexport)
#else
#define ExportedBySWKHumanModelingItf __declspec(dllimport)
#endif
#else
#define ExportedBySWKHumanModelingItf
#endif

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedBySWKHumanModelingItf IID IID_SWKISegment;
#else
extern &quot;C&quot; const IID IID_SWKISegment;
#endif

/**
  * This interface provides non-IDL segment services.&lt;br&gt;
  * The &#x27;segment&#x27; term used in anatomy to designate&lt;br&gt;
  * a member of the body, whether it is mobile or not.&lt;br&gt;
  * It is the element that links joints together.&lt;br&gt;
  * A mobile segment always rotates around its anchor point,&lt;br&gt;
  * using its degrees of freedoms (DOFs).
  **/

#ifndef SWHierarchyInfluenceZone
#	define	SWHierarchyInfluenceZone	1
#endif
#ifndef SWHierarchyVisu
#	define	SWHierarchyVisu			2
#endif

class ExportedBySWKHumanModelingItf SWKISegment : public SWKIBodyElement
{
	CATDeclareInterface;

 public:
	/**
	  * Recnstruction mode:
	  * - SubDInvalidParam: internally used (as a default argument check). Should not be used
	  * - SubDNothing: the segment subd surface should not be updated in any way
	  * - XXXUpdateXXX: the segment subd surface only need to be &quot;updated&quot;, it has not undergone
	                geometry changes, but only rotations and translation in its whole
	  * - XXXRebuildXXX: the segment subd surface has undergone geometry modification (some vertices have moved)
	  *             it needs to be fully rebuilt
	  * - XXXIfNecessary: we only perform the operation if the segment position has changed
	  * - ForceXXXX: we perform the operation whatever the segment has moved or not
	  *
	  * for performance purposes, we can use the binary represenation (except for SubDInvalidParam)
	  * 4 bits having the following signification, from MSB to LSB:
	  * - 4: MSB bit not used
	  * - 3: if 1, indicates that we want to &quot;Force&quot; update; if 0, we do a &quot;if necessary&quot; check
	  * - 2: if 1, indicates that we want to &quot;Rebuild&quot;
	  * - 1: if 1, indicates that we want to (at least) &quot;Update&quot;
	  * so, the more bits are &quot;on&quot;, the more the flag is &quot;strong&quot;.
	  **/
	 enum SubDMode
	 {
		 SubDInvalidParam		= -1,
		 SubDNothing			= 0x0,
		 
		 SubDUpdateIfNecessary	= 0x1,	// 0001
		 SubDForceUpdate		= 0x5,	// 0101
		 
		 SubDRebuildIfNecessary	= 0x3,	// 0011
		SubDForceRebuild		= 0x7   // 0111
	 };

	/**
	  * Initialize the internal segment.&lt;br&gt;
	  * &lt;strong&gt;This method is to be used by the system only&lt;/strong&gt;.
	  **/
	virtual HRESULT SetInternalSegment(SWSegment * piInternalSegment,
							CATISpecObject * piSegmentStartUp,
							CATIContainer * piRootContainer) = 0;

	/**
	  * Return the number of children of the segment.&lt;br&gt;
	  * The manikin is built in such a way that each segment&lt;br&gt;
	  * can have one or more children, thus constituting a &lt;strong&gt;segment&lt;br&gt;
	  * hierarchy&lt;/strong&gt;.&lt;br&gt;
	  * The top segment of that hierarchy is the &lt;strong&gt;root&lt;/strong&gt; segment,&lt;br&gt;
	  * accessible from a call to method &lt;code&gt;GetRootSegment()&lt;/code&gt; of&lt;br&gt;
	  * interface &lt;code&gt;SWKIBody&lt;/code&gt;.
	  **/
	virtual unsigned GetNumberOfChildren() const = 0;

	/**
	  * Retrieve a child segment at the specified index.
	  *
	  * @param piIndex The index of the desired child.&lt;br&gt;
	  * First child segment is at index 0.
	  * @return The corresponding segment, or &lt;code&gt;NULL&lt;/code&gt;,
	  * if the index goes out of bounds.
	  **/
	virtual SWKISegment * GetChildAtIndex(unsigned piIndex) = 0;

	/**
	  * @return The number of ellipses on the segment.
	  **/
	virtual unsigned GetNumberOfEllipses() const = 0;

	/**
	  * Retrieve an ellipse at a specified index.
	  *
	  * @param piIndex The index of the desired ellipse.&lt;br&gt;
	  * First ellipse is at index 0.
	  * @return The corresponding ellipse, or &lt;code&gt;NULL&lt;/code&gt;,
	  * if the index goes out of bounds.
	  **/
	virtual SWKIEllipse * GetEllipseAtIndex(unsigned piIndex) = 0;

	/**
	  * Retrieve an ellipse from its short name.
	  *
	  * @param piShortName The short name of the desired ellipse.
	  * @return The corresponding ellipse, or &lt;code&gt;NULL&lt;/code&gt;,
	  * if no ellipse with the given short name exists.
	  **/
	virtual SWKIEllipse * GetEllipse(SWShortName piShortName) = 0;

	/**
	  * @return The body owning the segment.
	  **/
	virtual SWKIBody * GetBody() = 0;

	/**
	  * Retrieve a child segment from its short name.
	  *
	  * @param piShortName The short name of the desired child.
	  * @return The corresponding segment, or &lt;code&gt;NULL&lt;/code&gt;,
	  * if no child segment with the given short name exists.
	  **/
	virtual SWKISegment * GetChild(SWShortName piShortName) = 0;

	/**
	  * @return The ancestor of the segment in the hierarchy, or
	  * &lt;code&gt;NULL&lt;/code&gt;, if this segment has no ancestor.
	  **/
	virtual SWKISegment * GetAncestor() = 0;

	/**
	  * @return The spine segment which is the basic segment for spine sections manipulation
	  * &lt;code&gt;NULL&lt;/code&gt;, if this segment is not part of Spine or Cervical
	**/
	virtual SWKISegment* GetSpineSegment() = 0;
	
	/**
	  * @return &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * if this segment is an ancestor of the one passed&lt;br&gt;
	  * as a parameter,
	  * &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * otherwise.  We consider that a segment&lt;br&gt;
	  * not an ancestor of itself.
	  **/
	virtual boolean IsAncestor(SWShortName piOtherSegment) const = 0;

	/**
	  * @return &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * if this segment is a descendant of the one passed&lt;br&gt;
	  * as a parameter,
	  * &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * otherwise.  We consider that a segment&lt;br&gt;
	  * not a descendant of itself.
	  **/
	virtual boolean IsDescendant(SWShortName piOtherSegment) const = 0;

	/**
	  * @return &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * if this segment is on the left side&lt;br&gt;
	  * &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * otherwise.
	  **/
	virtual boolean IsOnLeftSide() const = 0;

	/**
	  * @return &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * if this segment is on the right side&lt;br&gt;
	  * &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * otherwise.
	  **/
	virtual boolean IsOnRightSide() const = 0;

	/**
	  * @return &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * if this segment is on the spine&lt;br&gt;
	  * &lt;code&gt;&lt;font color=&quot;blue&quot;&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;/font&gt;&lt;/code&gt;
	  * otherwise.
	  **/
	virtual boolean IsPartOfSpine() const = 0;

	/**
	  * @return &lt;code&gt;&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;true&lt;/font&gt;&lt;/strong&gt;&lt;/code&gt;
	  * if the segment belongs to the cervical part of the manikin,
	  * &lt;code&gt;&lt;strong&gt;&lt;font color=&quot;blue&quot;&gt;false&lt;/font&gt;&lt;/strong&gt;&lt;/code&gt; otherwise.
	  **/
	virtual boolean IsPartOfCervical() const = 0;

	/**
	  * @return The segment equivalent to this one but on the opposite
	  * side (ex.: right leg &lt;-&gt; left leg).
	  **/
	virtual SWKISegment * GetMirrorSegment() = 0;

	/**
	  * @return The number of degrees of freedom on the segment.
	  **/
	virtual unsigned GetNumberOfDOFs() const = 0;

	/**
	  * Return the degree of freedom at the specified index.&lt;br&gt;
	  * &lt;br&gt;
	  * &lt;strong&gt;N.B.&lt;/strong&gt;: A segment may have up to three degrees of freedom,&lt;br&gt;
	  * and these are numbered from 0 to 2.&lt;br&gt;
	  * &lt;br&gt;
	  * However, the degrees of freedom do not always have&lt;br&gt;
	  * consecutive indexes.  For instance, the forearm&lt;br&gt;
	  * has 2 DOFs, but these are numbered 0 and 2.&lt;br&gt;
	  * That is why the set of DOFs under a segment cannot&lt;br&gt;
	  * be properly accessed as if it was a continuous vector.&lt;br&gt;
	  * When looping through the degrees of freedom of a segment,&lt;br&gt;
	  * the application should always test whether the DOF retrieved is not&lt;br&gt;
	  * &lt;code&gt;NULL&lt;/code&gt;.&lt;br&gt;
	  *
	  * @param piIndex  The index of the DOF to retrieve.
	  * This parameter must be either &lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; or &lt;code&gt;2&lt;/code&gt;.
	  *
	  * @return The desired DOF, or &lt;code&gt;NULL&lt;/code&gt; if&lt;br&gt;
	  * the segment does not have a DOF at that position.
	  **/
	virtual SWKIDOF * GetDOFAtIndex(unsigned piIndex) = 0;

	/**
	  * @return The beginning point of the segment in local coordinates,&lt;br&gt;
	  * that is, with respect to the manikin&#x27;s root segment.
	  **/
	virtual CATMathPoint GetBeginPoint() = 0;

	/**
	  * @return The ending point of the segment in local coordinates,&lt;br&gt;
	  * that is, with respect to the manikin&#x27;s root.
	  **/
	virtual CATMathPoint GetEndPoint() = 0;

	/**
	  * @return The beginning point of the segment in global (world) coordinates.
	  **/
	virtual CATMathPoint GetBeginPointInGlobal() = 0;

	/**
	  * @return The ending point of the segment in global (world) coordinates.
	  **/
	virtual CATMathPoint GetEndPointInGlobal() = 0;

	/**
	  * Set the segment back to its default position.
	  *
	  * @param piKeepReferential If this parameter is set to TRUE
	  * (default value), the referential coordinates are kept.
	  * @param piDOFNumberToReset If this parameter is set to -1
	  * (default value), all DOFs will be reset, otherwise only the DOF number
	  * specified will be reset.
	  **/
	virtual void ResetPosture(boolean piKeepReferential = TRUE, const int piDOFNumberToReset = -1) = 0;

	/**
	  * Copy the posture on the equivalent segment, on the other side
	  * of the manikin. For instance, it copies the posture from the
	  * right leg to the left leg.
	  *
	  * @param piKeepReferential If this parameter is set to TRUE
	  * (default value), the referential coordinates are kept.
	  **/
	virtual void MirrorCopyPosture(boolean piKeepReferential = TRUE) = 0;

	/**
	  * Swap the posture with the equivalent segment, on the other side
	  * of the manikin. For instance, the right leg takes the posture of
	  * the left leg, and vice versa.
	  *
	  * @param piKeepReferential If this parameter is set to TRUE
	  * (default value), the referential coordinates are kept.
	  **/
	virtual void SwapPosture(boolean piKeepReferential = TRUE) = 0;

	/**
	  * Set the preferred angles back to its default value.
	  **/
	virtual void ResetPrefAngles(int piDOFId = -1) = 0;

	/**
	  * Copy the preferred angles on the equivalent segment, on the other side
	  * of the manikin. For instance, it copies the preferred angles from the
	  * right leg to the left leg.
	  **/
	virtual void MirrorCopyPrefAngles(int piDOFId = -1) = 0;

	/**
	  * Swap the preferred angles with the equivalent segment, on the other side
	  * of the manikin. For instance, the right leg takes the preferred angles of
	  * the left leg, and vice versa.
	  **/
	virtual void SwapPrefAngles(int piDOFId = -1) = 0;

	/**
	  * Removes the angular limitation on a specified DOF
	  **/
	virtual void RemoveLimits(int piDOFId = -1) = 0;

	/**
	  * Resets the angular limitations depending on the param piReset
	  * SWKEResetDefault  -&gt; SWKEResetLock OR SWKEResetNoLimits OR SWKEResetLimits
	  *                      depending of the first encountered.
	  * SWKEResetAll      -&gt; SWKEResetLock AND SWKEResetNoLimits AND SWKEResetLimits
	  * SWKEResetLock     -&gt; Unlock the value
	  * SWKEResetNoLimits -&gt; Restore the angular limitations
	  * SWKEResetLimits   -&gt; Set back the angular limitations to 50.0%
	  **/
	virtual void ResetAngularLimitations(int piDOFId = -1, SWKEReset piReset = SWKEResetDefault) = 0;

	/**
	  * Copy the angular limitations on the equivalent segment, on the other side
	  * of the manikin. For instance, it copies the angular limitations  from the
	  * right leg to the left leg.
	  **/
	virtual void MirrorCopyAngularLimitations(int piDOFId = -1) = 0;

	/**
	  * Swap the angular limitations with the equivalent segment, on the other side
	  * of the manikin. For instance, the right leg takes the angular limitations of
	  * the left leg, and vice versa.
	  **/
	virtual void SwapAngularLimitations(int piDOFId = -1) = 0;

	/**
	  * Lock the value of one of all DOFs on this segment.
	  *
	  * @param piDOFId The index of the DOF whose value must
	  * be locked.  If this parameter is omitted, or if its value
	  * is higher than 2 or negative, all DOFs are locked.
	  **/
	virtual void LockPosture(int piDOFId = -1) = 0;

	/**
	  * Sets the limits to match the best PrefAngle for the DOF piDOFId
	  **/
	virtual void Optimize(int piDOFId = -1) = 0;

	/**
	  * Sets the angular limitations to a percentage for the DOF piDOFId
	  **/
	virtual void SetPercentage(double piPercentage, int piDOFId = -1) = 0;
	
	/**
	  * @param piKeep The PasteFrom function will never changes the state of the
	  * lock if the piKeep value is TRUE.
	  **/
	virtual void KeepLockStateForPasteFrom(boolean piKeep) = 0;

	/**
	  * @return The direction of the segment in local coordinates,&lt;br&gt;
	  * that is, with respect to the manikin&#x27;s root.
	  **/
	virtual CATMathDirection GetDirection() = 0;

	/**
	  * @return The direction of the segment in global (world) coordinates.
	  **/
	virtual CATMathDirection GetDirectionInGlobal() = 0;

	/**
	  * @return The length of the segment, in centimeters.
	  **/
	virtual double GetLength() const = 0;

	/**
	  * @return The number of meshes (surface of skin) on the segment.
	  **/
	virtual unsigned GetNumberOfMeshes() const = 0;

	/**
	  * Retrieve a mesh at the specified index.
	  *
	  * @param piIndex The index of the mesh to return.&lt;br&gt;
	  * First mesh is at index 0.
	  * @return The mesh at the specified index, or &lt;code&gt;NULL&lt;/code&gt;&lt;br&gt;
	  * if the index goes out of bounds.
	  **/
	virtual const SWMesh * GetMeshAtIndex(unsigned piIndex) const = 0;

	/**
	  * @return The DOF having the worst postural score on the current segment.
	  **/
	virtual SWKIDOF * GetWorstPosturalScoreDOF() = 0;

	/**
	  * Set the segment node that will be the father of this segment in the
	  * V5 specification tree.
	  *
	  * This method is to be used by the system only.
	  **/
	virtual HRESULT SetFatherNode(SWKISegmentNode * piSegmentNode) = 0;

	/**
	  * @return the node that is the parent of this segment in the V5 specification tree.
	  **/
	virtual SWKISegmentNode * GetFatherNode() = 0;

	/**
	  * @return The IK end effector matrix position for this segment.
	  **/

	virtual CATMathAxis GetIKPositionInGlobal() = 0;
	
	/**
	  * Get the default value of the offset.
	  **/
	virtual void GetDefaultIKOffset(CATMathAxis &amp; poAxis) = 0;

	/**
	  * @return the axis of the active offset for this segment.
	  **/
	virtual CATMathAxis GetIKOffset() = 0;

	/**
	  * @return the active offset for this segment.
	  **/
	virtual SWKISegmentOffset * GetSegmentOffset() = 0;

	/**
	  * @return true if the segment has an active offset 
	  **/
	virtual boolean HasIKOffset() = 0;

	/**
	  * Ask HPoint IK offset is HPoint of SAE (J826).
	  **/
	virtual boolean IsSAEHPointOffset() = 0;

	/**
	  * @nodoc
	  */
	virtual void InitializeEllipses() = 0;

	/**
	  * @nodoc
	  */
	virtual void * InternalSettings(void * piInternalData = NULL) = 0;
	
	/**
	  * @return The full name of the segment without the &quot;left&quot; or &quot;right&quot; part.
	  **/
	virtual CATUnicodeString GetNameWithoutSide() const = 0;

	/**
	  *	Returns the start segment of the given segment
	  */
	virtual SWShortName FindStartSegment(SWShortName piSegment) const = 0;

	/**
	  * Get the number of faces &quot;owned&quot; by this segment
	  * The returned value depends on the specified parameter
	  * @param piMode Indicates which information should be retrieved
	  * legal values:
	  *	- SWHierarchyInfluenceZone: the returned value is the number of faces influenced by
	  * this segment. The influenced faces are the ones that have at least one vertex 
	  * influenced by an ellipse owned by this segment
	  *	- SWHierarchyVisu: the returned value is the number of faces displayed by this
	  * segment. The &quot;visu&quot; faces are the ones whose higher influence coefficient is relative
	  * to an ellipse owned by this segment
	  **/
	virtual int  GetNbHierarchies(int piMode)  const = 0;

	/**
	  * Get the index of the face in the base mesh
	  * The returned value depends on the specified parameter
	  * @param piMode Indicates which information should be retrieved
	  * legal values:
	  *	- SWHierarchyInfluenceZone: the returned value is the number of faces influenced by
	  * this segment. The influenced faces are the ones that have at least one vertex 
	  * influenced by an ellipse owned by this segment
	  *	- SWHierarchyVisu: the returned value is the number of faces displayed by this
	  * segment. The &quot;visu&quot; faces are the ones whose higher influence coefficient is relative
	  * to an ellipse owned by this segment
	  * @param piModeIndex The index of the face in the array specified by piMode
	  **/
	virtual int  GetHierarchyAtIndex(int piMode, int piModeIndex) = 0;

	/**
	  * Set the index of the face in the base mesh
	  * @param piMode Indicates which information should be retrieved
	  * legal values:
	  *	- SWHierarchyInfluenceZone: the returned value is the number of faces influenced by
	  * this segment. The influenced faces are the ones that have at least one vertex 
	  * influenced by an ellipse owned by this segment
	  *	- SWHierarchyVisu: the returned value is the number of faces displayed by this
	  * segment. The &quot;visu&quot; faces are the ones whose higher influence coefficient is relative
	  * to an ellipse owned by this segment
	  * @param piModeIndex The index of the face in the array specified by Mode
	  * @param piValue The value to set
	  **/
	virtual void SetHierarchyAtIndex(int piMode, int piModeIndex, int piValue) = 0;

	/**
	  * Get a pointer to the specified array
	  * The returned value depends on the specified parameter
	  * @param piMode Indicates which information should be retrieved
	  * legal values:
	  *	- SWHierarchyInfluenceZone: the returned value is the number of faces influenced by
	  * this segment. The influenced faces are the ones that have at least one vertex 
	  * influenced by an ellipse owned by this segment
	  *	- SWHierarchyVisu: the returned value is the number of faces displayed by this
	  * segment. The &quot;visu&quot; faces are the ones whose higher influence coefficient is relative
	  * to an ellipse owned by this segment
	  **/
	virtual CATListOfInt *GetHierarchiesIndexes(int piMode) = 0;

	/**
	  * Get the path of the file mapped as texture on this segment
	  **/
	virtual CATUnicodeString GetPathToTexture() = 0;

	/**
	  * Get the scale factor for the texture (float [2], along U and V)
	  **/
	virtual float *GetTextureScale() = 0;

	/**
	  * Get the offset factor for the texture (float [2], along U and V)
	  **/
	virtual float *GetTextureOffset() = 0;

	/**
	  * Set the flag SubDMode, indicating the way the subd surface should be updated/rebuilt
	  * available modes:
	  * - SubDNothing
	  * - SubDForceRebuild
	  * - SubDForceUpdate
	  * - SubDRebuildIfNecessary
	  * - SubDUpdateIfNecessary
	  * there are many options:
	  * - piMode: the mode the segment should be switched to
	  * - piSetToStrongest: if TRUE, the &quot;strongest&quot; mode of the segment&#x27;s current mode and piMode set as parameter is used
	  * - piRecursive: if TRUE, the flag is set down to children
	  * - piRecursiveMode: the mode to switch the children to
	  *       if piRecursive is set to TRUE and piRecursiveMode is not specified, then the children are set to the same kind of
	  *       reconstruction (Rebuild or Update) but it is limited to a &quot;XXXIfNecessary&quot; reconstruction
	  **/
	virtual SWKISegment::SubDMode SetSubDMode(SWKISegment::SubDMode piMode,
											  boolean piSetToStrongest = FALSE,
											  boolean piRecursive = FALSE,
											  SWKISegment::SubDMode piRecursiveMode = SWKISegment::SubDInvalidParam) = 0;
	virtual SWKISegment::SubDMode GetSubDMode() = 0;

	/**
	  *
	  **/
	virtual void RefreshSubDRep() = 0;
	
	/**
	  * Get the previous position of this segment
	  **/
	virtual CATMathAxis GetPreviousPosition() = 0;

	/**
	  * Those two methods put the flag SubDRebuildIfNecessary on all
	  * ancestors &amp; children until a segment that has an influence zone
	  * is found.
	  **/
	virtual int MarkAncestors() = 0;
	virtual int MarkChildren() = 0;
};

CATDeclareHandler(SWKISegment, SWKIBodyElement);
#endif
</div>
    
    <div class="navigation">
        <div><a href="SWKIRULASpecs.html">‚Üê ‰∏ä‰∏ÄÈ°µ: SWKIRULASpecs.h</a></div>
        <div><a href="SWKISegment3DVisu.html">‰∏ã‰∏ÄÈ°µ: SWKISegment3DVisu.h ‚Üí</a></div>
    </div>
</body>
</html>