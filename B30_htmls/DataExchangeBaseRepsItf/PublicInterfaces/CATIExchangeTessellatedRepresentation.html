<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataExchangeBaseRepsItf/PublicInterfaces/CATIExchangeTessellatedRepresentation.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DataExchangeBaseRepsItf/PublicInterfaces/CATIExchangeTessellatedRepresentation.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIExchangeTessellatedAnnotationRepresentation.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIExchangeTessellatedAnnotationRepresentation.h</a></div>
        <div><a href="CATIExchangeTessellatedRepresentationPlus.html">‰∏ã‰∏ÄÈ°µ: CATIExchangeTessellatedRepresentationPlus.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/* -*-c++-*- */

#ifndef CATIExchangeTessellatedRepresentation_H
#define CATIExchangeTessellatedRepresentation_H

// COPYRIGHT DASSAULT SYSTEMES PROVENCE 2004

/**
 * @CAA2Level L0
 * @CAA2Usage U0
 */

//===================================================================
//
// 24/08/2004: MAX: API redefinition
// 16/04/2003: MAX: CAA Documentation &amp; signature review
// 07/02/2003: ABM: Extension to support Lods and Instances.
// 07/02/2003: ABM: Extension to support Scene Trees Browsing
// 10/12/2002: ABM: Creation: flattened retrieval of Surface, Curve and Coordinate systems 
//
//===================================================================

// ABM Comments For Review // To be removed from Header
// -&gt; This Class Purpose is not aimed to support PMIs and Drawings which are relevant to a separate packaging Area

#include &quot;DataExchangeBaseRepsItfCPP.h&quot;
#include &quot;CATBaseUnknown.h&quot;

class CATUnicodeString;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByDataExchangeBaseRepsItfCPP IID IID_CATIExchangeTessellatedRepresentation;
#else
extern &quot;C&quot; const IID IID_CATIExchangeTessellatedRepresentation ;
#endif

// String to be returned by implementations on method CATIExchangeRepresentation::GetRepresentationType
// and to give to CATIExchangeInputDocument::GetRepresentation
#define XCAD_TESSELLATED_REPRESENTATION &quot;TessellatedRepresentation&quot;


typedef enum {	NOD_ContainerNode = 1,
				NOD_SolidNode,
				NOD_SurfacicNode,
				NOD_CustomNode,
				NOD_CoordinateSystem,
				NOD_GP,
				NOD_Unknown
			} KindOfNode ;

typedef enum {	GP_Face = 1,
				GP_Plane,
				GP_Cylinder,
				GP_Cone,
				GP_Sphere,
				GP_Edge,
				GP_Line,
				GP_Circle,
				GP_Point,
				GP_Unknown
			} KindOfGP ;

/**
 * Interface to exchange tessellated representations (surfaces and curves).
 * &lt;b&gt;Role&lt;/b&gt;: This interface provides a view on a XCAD document as a tessellated representation.
 * &lt;br&gt;Available from CATIA V5R15.
 */ 
class ExportedByDataExchangeBaseRepsItfCPP CATIExchangeTessellatedRepresentation:	public CATBaseUnknown
{
  CATDeclareInterface;

  public:
/**
 * Retrieves the tessellation options.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oSAGValue
 *				the used SAG (geometric precision) for the tessellation.
 * @param oAngleValue
 *				the max angle between consecutive normals for the tessellation.
 * @param oStepValue
 *				the max size of edges for the tessellation.
 */
	 virtual HRESULT GetSAG(const void* iNodeID, float* oSAGValue, float* oAngleValue, float* oStepValue) = 0;

/**
 * Retrieves the root nodes&#x27; number.
 * @param oNodeCount
 *				the number of root nodes.
 */
	 virtual HRESULT GetRootNodesCount(unsigned int* oNodeCount) = 0;

/**
 * Retrieves the root node&#x27;s ID from its index.
 * @param iRootIndex
 *				the node&#x27;s index from 0 to root nodes number - 1.
 * @param oRootNodeID
 *				the root node&#x27;s ID.
 */
	 virtual HRESULT GetRootNode(const unsigned int iRootIndex, void*&amp; oRootNodeID) = 0;

/**
 * Retrieves the number of children of the current node.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oNodeCount
 *				the number of children nodes.
 */
	 virtual HRESULT GetChildCount(const void* iNodeID, unsigned int* oNodeCount) = 0;

/**
 * Retrieves the node&#x27;s ID from its index.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param iChildIndex
 *				the child&#x27;s index from 0 to children number - 1.
 * @param oChildNodeID
 *				the ID of the child.
 */
	 virtual HRESULT GetChild(const void* iNodeID, const unsigned int iChildIndex, void*&amp; oChildNodeID) = 0;

/**
 * Retrieves the node&#x27;s type.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oNodeType
 *				the node&#x27;s type.
 */
	 virtual HRESULT GetNodeType(const void* iNodeID, KindOfNode&amp; oNodeType) = 0;

/**
 * Retrieves the node&#x27;s GP type.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oGPType
 *				the GP&#x27;s type.
 * @return
 * If current node isn&#x27;t a GP, returns S_FALSE.
 */
	 virtual HRESULT GetGPType(const void* iNodeID, KindOfGP&amp; oGPType) = 0;

/**
 * Retrieves the orientation matrix of the node.
 * (in relation with its immediate father)
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oRotationMatrix
 *				the rotation component:
 *								oRotationMatrix[0][x] : U vector
 *								oRotationMatrix[1][x] : V vector
 *								oRotationMatrix[2][x] : W vector
 * @param oTranslationVector
 *				the translation component.
 * @return
 * If current node has no orientation matrix, returns S_FALSE.
 */
	virtual HRESULT GetNodeOrientationMatrix(const void* iNodeID, float oRotationMatrix[3][3], float oTranslationVector[3]) = 0;

/**
 * Retrieves the node&#x27;s UID.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oNodeUID
 *				the node&#x27;s UID.
 */
	virtual HRESULT GetNodeUID(const void* iNodeID, CATUnicodeString&amp; oNodeUID) = 0;

/**
 * Retrieves the coordinates system.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oOriginPoint
 *				the origin of the coordinate system.
 * @param oFirstVector
 *				the first vector which defines the system.
 * @param oSecondVector
 *				the second vector which defines the system.
 */
	virtual HRESULT GetCoordinateSystem(const void* iNodeID, double oOriginPoint[3], double oFirstVector[3], double oSecondVector[3]) = 0;

/**
 * Retrieves the color of a node.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oRed
 *				the red component.
 *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oRed&lt;/tt&gt; ranges from 0 to 255.
 * @param oGreen
 *				the green component.
 *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oGreen&lt;/tt&gt; ranges from 0 to 255.
 * @param oBlue
 *				the blue component.
 *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oBlue&lt;/tt&gt; ranges from 0 to 255.
 * @param oAlpha
 *				the alpha component.
 *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oAlpha&lt;/tt&gt; ranges from 0 to 255.
 */
	virtual HRESULT GetNodeColor(const void* iNodeID, unsigned int* oRed, unsigned int* oGreen, unsigned int* oBlue, unsigned int* oAlpha = NULL) = 0;

/**
 * Retrieves the bounding sphere of a node.
 * This sphere represents the smallest sphere containing the object under the node it&#x27;s linked to.
 * This information is used at the rendering time to know if a given element is visible on the screen
 * and needs to be drawn or not.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oCenterPoint
 *				the center of the sphere.
 * @param oRadius
 *				the radius of the sphere.
 */
	virtual HRESULT GetNodeBoundingSphere(const void* iNodeID, float oCenterPoint[3], float* oRadius) = 0;

/*********************************************************************************************************************/
//                                               GP DATA
/*********************************************************************************************************************/

/**
 * Retrieves the face&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oVerticesNumber
 *				the vertices number.
 *				If information on vertices is shared with another element, returned size for this parameter is equal to 0.
 * @param oVertices
 *				an array made of face vertices coordinates: XYZXYZXYZ...
 *				Its size is equal to three times the face vertices number.
 * @param oNormalsNumber
 *				the number of normals.
 *				If information on normals is shared with another element, returned size for this parameter is equal to 0.
 * @param oNormals
 *				an array made of normals coordinates. It is organized as &lt;tt&gt;oVertices&lt;/tt&gt; : one vertex has exactly
 *				one normal at the same field entry.
 * @param oSingleTrianglesNumber
 *				the number of single triangles in the face. 
 * @param oSingleTrianglesIndices
 *				the array used to store the single triangles vertices. Each of its field represents
 *				a vertex index, in the &lt;tt&gt;oVertices&lt;/tt&gt; array.
 *				As,  we find, in the &lt;tt&gt;*oVertices&lt;/tt&gt; array, the XYZ coordinates for each
 *				vertex, the indices used to designate the vertices are multiples of three.
 * @param oStripTrianglesNumber
 *				the number of face triangles strips.
 * @param oStripTrianglesIndices
 *				the array used to store the face triangles strips vertices. Each field contains a
 *				vertex index, belonging to one of the strips, in the oVertices array.  As, we find, in the
 *				&lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
 *				vertex, the indices used to designate the vertices are multiples of three.
 * @param oNbVertexPerStripTriangle
 *				an array containing the number of vertices for each face triangles strip.
 *				The size of this array is equal to &lt;tt&gt;*oStripTrianglesNumber&lt;/tt&gt;. For example, the first strip
 *				is made with &lt;tt&gt;*oNbVertexPerStripTriangle[0]&lt;/tt&gt; vertices.
 * @param oFanTrianglesNumber
 *				the number of face triangles fans.
 * @param oFanTrianglesIndices
 *				the array used to store the face triangles fans vertices. Each field contains a
 *				vertex index, belonging to one of the fans, in the &lt;tt&gt;oVertices&lt;/tt&gt; array.  As, we find, in the
 *				&lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
 *				vertex, the indices used to designate the vertices are multiples of three.
 * @param oNbVertexPerFanTriangle
 *				the array containing the number of vertices for each face triangles fan.
 *				The size of this array is equal to &lt;tt&gt;*oFanTrianglesNumber&lt;/tt&gt;. For example, the first fan
 *				is made with &lt;tt&gt;*oNbVertexPerFanTriangle[0]&lt;/tt&gt; vertices.
 */
	virtual HRESULT GetFaceData(const void* iNodeID, int* oVerticesNumber, float** oVertices, int* oNormalsNumber, float** oNormals,
								int* oSingleTrianglesNumber, int** oSingleTrianglesIndices, int* oStripTrianglesNumber,
								int** oStripTrianglesIndices, int** oNbVertexPerStripTriangle, int* oFanTrianglesNumber,
								int** oFanTrianglesIndices, int** oNbVertexPerFanTriangle) = 0;

/**
 * Retrieves the plane&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oBasePoint
 *				a point on the plane.
 * @param oNormalVector
 *				an unit vector perpendicular to the plane.
 */
	virtual HRESULT GetPlaneData(const void* iNodeID, double oBasePoint[3], double oNormalVector[3]) = 0;

/**
 * Retrieves the cylinder&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oBasePoint
 *				the center of the cylinder&#x27;s base.
 * @param oAxisVector
 *				the vector defining the axis of the cylinder. Its length is the length of the cylinder.
 * @param oRadius
 *				the radius of the cylinder&#x27;s base circle.
 */
	virtual HRESULT GetCylinderData(const void* iNodeID, double oBasePoint[3], double oAxisVector[3], double* oRadius) = 0;

/**
 * Retrieves the cone&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oBasePoint
 *				the apex point of the cone.
 * @param oAxisVector
 *				the vector defining the axis of the cone. Its length is the length of the cone.
 * @param oHalfAngle
 *				the acute angle subtended between the axis and a generator of the cone ( 0 &lt; angle &lt; PI/2 ).
 */
	virtual HRESULT GetConeData(const void* iNodeID, double oBasePoint[3], double oAxisVector[3], double* oHalfAngle) = 0;

/**
 * Retrieves the sphere&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oCenterPoint
 *				the center of the sphere.
 * @param oRadius
 *				the radius of the sphere.
 */
	virtual HRESULT GetSphereData(const void* iNodeID, double oCenterPoint[3], double* oRadius) = 0;

/**
 * Retrieves the edge&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oFace1Node
 *				the first face the edge belongs to. This face shares vertices informations with the edge.
 * @param oFace2Node
 *				the second face the edge belongs to. This face can be set to NULL if doesn&#x27;t exist.
 * @param oFace1Vertices
 *				the first face vertices coordinates array: XYZXYZXYZ...
 * @param oVerticesNumber
 *				the number of vertices in the edge.
 * @param oVerticesIndices
 *				edge vertices indices array, taken from the first face.
 *				This means that these indices allow to access vertices coordinates only through first face data.
 */
	virtual HRESULT GetEdgeData(const void* iNodeID, void** oFace1Node, void** oFace2Node, float** oFace1Vertices, unsigned int* oVerticesNumber, int** oVerticesIndices) = 0;

/**
 * Retrieves the polyline&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oPoints
 *				the points coordinates array.
 *				Array of points coordinates: XYZXYZXYZ...
 *				Its size is equal to three times the number of points.
 * @param oNbPoints
 *				Retrieves the number of points.
 * @param oLineType
 *				Retrieves the line type.
 *				&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 *				&lt;dl&gt;
 *				&lt;dt&gt;LINES&lt;/dt&gt;
 *				&lt;dd&gt;The number of points must be even. A line will be drawn
 *				between points 1 and 2, an other line will be drawn between
 *				points 3 and 4, ...&lt;/dd&gt;
 *				&lt;dt&gt;LINE_STRIP&lt;/dt&gt;
 *				&lt;dd&gt;The number of points can be either even or odd. A line will
 *				be drawn between points 1 and 2, then, an other line will be drawn
 *				between points 2 and 3, ...&lt;/dd&gt;
 *				&lt;dt&gt;LINE_LOOP&lt;/dt&gt;
 *				&lt;dd&gt;Same as &lt;tt&gt;LINE_LOOP&lt;/tt&gt;, excepted that one more line will be
 *				drawn between the last and the first points.&lt;/dd&gt;
 *				&lt;/dl&gt;
 */
	virtual HRESULT GetPolyLineData(const void* iNodeID, float **oPoints, int *oNbPoints,int *oLineType) = 0;

/**
 * Retrieves the point&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oPoints
 *				the points coordinates array.
 *				Array of points coordinates: XYZXYZXYZ...
 *				Its size is equal to three times the number of points.
 * @param oNbPoints
 *				Retrieves the number of points.
 */
	virtual HRESULT GetPointData(const void* iNodeID, float **oPoints, int *oNbPoints) = 0;

/**
 * Retrieves the 3D circle arc&#x27;s parameters.
 * @param iNodeID
 *				the node&#x27;s ID.
 * @param oCenterPoint
 *				the center of the circle.
 * @param oNormalVector
 *				the normal to the circle plan, this vector is normalized.
 * @param oRadius
 *				the circle radius.
 */
	virtual HRESULT GetCircleData(const void* iNodeID, double oCenterPoint[3], double oNormalVector[3], double* oRadius) = 0;

};
CATDeclareHandler(CATIExchangeTessellatedRepresentation, CATBaseUnknown);

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATIExchangeTessellatedAnnotationRepresentation.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIExchangeTessellatedAnnotationRepresentation.h</a></div>
        <div><a href="CATIExchangeTessellatedRepresentationPlus.html">‰∏ã‰∏ÄÈ°µ: CATIExchangeTessellatedRepresentationPlus.h ‚Üí</a></div>
    </div>
</body>
</html>