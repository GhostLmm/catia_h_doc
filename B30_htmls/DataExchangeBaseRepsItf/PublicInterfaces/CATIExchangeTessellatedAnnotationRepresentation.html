<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DataExchangeBaseRepsItf/PublicInterfaces/CATIExchangeTessellatedAnnotationRepresentation.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DataExchangeBaseRepsItf/PublicInterfaces/CATIExchangeTessellatedAnnotationRepresentation.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIExchangeTabulatedCylinder.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIExchangeTabulatedCylinder.h</a></div>
        <div><a href="CATIExchangeTessellatedRepresentation.html">‰∏ã‰∏ÄÈ°µ: CATIExchangeTessellatedRepresentation.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">// COPYRIGHT Dassault Systemes Provence 2009
//===================================================================
//
// CATIExchangeTessellatedAnnotationRepresentation.h
// Define the CATIExchangeTessellatedAnnotationRepresentation interface
//
//===================================================================
//
// Usage notes:
//   New interface: describe its use here
//
//===================================================================
//
//  Feb 2009  Creation: Code generated by the CAA wizard  JRX
//  Oct 2009  DFB : XCAD API GA in R20 - replace CATIExchange3DTessellatedAnnotationRepresentation
//  Oct 2014  DFB : XCAD API used by default in V5-6R2015
//===================================================================
#ifndef CATIExchangeTessellatedAnnotationRepresentation_H
#define CATIExchangeTessellatedAnnotationRepresentation_H

/**
 * @CAA2Level L0
 * @CAA2Usage U0 
 */

#include &quot;DataExchangeBaseRepsItfCPP.h&quot;
#include &quot;CATBaseUnknown.h&quot;
#include &quot;CATListOfCATUnicodeString.h&quot;
#include &quot;CATListOfInt.h&quot;

#include &quot;CATIExchangeTessellatedRepresentation.h&quot; // for enums (KindOfNode)

class CATString;

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByDataExchangeBaseRepsItfCPP IID IID_CATIExchangeTessellatedAnnotationRepresentation;
#else
extern &quot;C&quot; const IID IID_CATIExchangeTessellatedAnnotationRepresentation ;
#endif

//------------------------------------------------------------------
// String to be returned by implementations on method CATIExchangeRepresentation::GetRepresentationType
// and to give to CATIExchangeInputDocument::GetRepresentation
#define XCAD_TESSELLATED_ANNOTATION_REPRESENTATION &quot;3dTessellatedAnnotationRepresentation&quot;

typedef enum {	            
GP_2DPolyline,
GP_2DPolygon,	
GP_2DFace,
GP_2DArcCircle,
} KindOf2DGP ;


/**
 * Interface to exchange Functional And Tolerancing Annotations (FTA) as tessellated representations.
 * &lt;b&gt;Role&lt;/b&gt;: This interface provides a view on a XCAD document containing FTA as a tessellated representation.
 * &lt;br&gt;Available from CATIA V5R19SP4 LA and V5R20 GA.
 */ 
class ExportedByDataExchangeBaseRepsItfCPP CATIExchangeTessellatedAnnotationRepresentation: public CATBaseUnknown
{
  
   CATDeclareInterface;

public:

    /**   
   * Retrieves the geometrical entities (Face, edge, vertex, independent curve or point) on which an annotation is attached.   
   * @param oNbGeometricID
   *				the number of Identifier of the geometric element to which one or more annotation are attached
   * @param oGeometricalID
   *				the unique Identifier of the geometric element to which one or more annotation are attached   
   * This method is called before the Geometrical Conversion in order to initialize the Mapping Table   
   * Recommended method for FTA Links on Geometry
   * Be careful: independent curve or point are treated only if the Mapping table is completed.
   */
   virtual HRESULT GetGeometricalIDList(int * oNbGeometricID, int* &amp;oGeometricalID) = 0;

   /**
   * Retrieves the tessellation options.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oSAGValue
   *				the used SAG (geometric precision) for the tessellation.
   * @param oAngleValue
   *				the max angle between consecutive normals for the tessellation.
   * @param oStepValue
   *				the max size of edges for the tessellation.
   * Not Mandatory method
   */
   virtual HRESULT GetSAG(const void* iNodeID, float* oSAGValue, float* oAngleValue, float* oStepValue) = 0;

   /**
   * Retrieves the root nodes&#x27; number.
   * @param oNodeCount
   *				the number of root nodes.
   * Mandatory method
   */
   virtual HRESULT GetRootNodesCount(unsigned int* oNodeCount) = 0;

   /**
   * Retrieves the root node&#x27;s ID from its index.
   * @param iRootIndex
   *				the node&#x27;s index from 0 to root nodes number - 1.
   * @param oRootNodeID
   *				the root node&#x27;s ID.
   * Mandatory method
   */
   virtual HRESULT GetRootNode(const unsigned int iRootIndex, void*&amp; oRootNodeID) = 0;

   /**
   * Retrieves the number of children of the current node.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oNodeCount
   *				the number of children nodes.
   * Mandatory method
   */
   virtual HRESULT GetChildCount(const void* iNodeID, unsigned int* oNodeCount) = 0;

   /**
   * Retrieves the node&#x27;s ID from its index.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param iChildIndex
   *				the child&#x27;s index from 0 to children number - 1.
   * @param oChildNodeID
   *				the ID of the child. 
   * Mandatory method
   */
   virtual HRESULT GetChild(const void* iNodeID, const unsigned int iChildIndex, void*&amp; oChildNodeID) = 0;

   /**
   * Retrieves the node&#x27;s type.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oNodeType
   *				the node&#x27;s type.
   * Not Mandatory method
   */
   virtual HRESULT GetNodeType(const void* iNodeID, KindOfNode&amp; oNodeType) = 0;

   /**
   * Retrieves the node&#x27;s Annotation type.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oAnnotationType
   *				the Annotation type.   
   *                XCAD_FTA_Datum, 
   *                XCAD_FTA_SizeAndDimension, 
   *                XCAD_FTA_Form, 
   *                XCAD_FTA_Orientation,
   *                XCAD_FTA_Position,   
   *                XCAD_FTA_RunOut,
   *                XCAD_FTA_NonSemantic,   
   *                XCAD_FTA_PartialSurface,      
   *                XCAD_FTA_View,      
   * @param oAnnotationSubType
   *				the Annotation sub type.
   *           For Datum Type :
   *              XCAD_FTA_SUBTYPE_DatumSimple
   *              XCAD_FTA_SUBTYPE_DatumTarget
   *           For Size and Dimension Type :
   *              XCAD_FTA_SUBTYPE_LinearDimension
   *              XCAD_FTA_SUBTYPE_AngularDimension
   *              XCAD_FTA_SUBTYPE_ChamferDimension
   *              XCAD_FTA_SUBTYPE_BasicDim
   *              XCAD_FTA_SUBTYPE_OrientedLinearDimension
   *              XCAD_FTA_SUBTYPE_OrientedAngularDimension                    
   *           For Form Type :
   *              XCAD_FTA_SUBTYPE_Straightness
   *              XCAD_FTA_SUBTYPE_Flatness
   *              XCAD_FTA_SUBTYPE_Circularity
   *              XCAD_FTA_SUBTYPE_Cylindricity
   *              XCAD_FTA_SUBTYPE_ProfileOfAnyLine
   *              XCAD_FTA_SUBTYPE_ProfileOfASurface
   *              XCAD_FTA_SUBTYPE_PatternLocation
   *           For Orientation Type : 
   *              XCAD_FTA_SUBTYPE_Angularity
   *              XCAD_FTA_SUBTYPE_Perpendicularity
   *              XCAD_FTA_SUBTYPE_Parallelism
   *           For Position Type :
   *              XCAD_FTA_SUBTYPE_Position 
   *              XCAD_FTA_SUBTYPE_Concentricity
   *              XCAD_FTA_SUBTYPE_Symmetry
   *              XCAD_FTA_SUBTYPE_PositionOfAnyLine
   *              XCAD_FTA_SUBTYPE_PositionOfASurface
   *           For Runout Type : 
   *              XCAD_FTA_SUBTYPE_CircularRunOut
   *              XCAD_FTA_SUBTYPE_TotalRunOut
   *           For NonSemantic Type :
   *              XCAD_FTA_SUBTYPE_Roughness
   *              XCAD_FTA_SUBTYPE_Weld
   *              XCAD_FTA_SUBTYPE_Text
   *              XCAD_FTA_SUBTYPE_FlagNote
   *              XCAD_FTA_SUBTYPE_Noa
   *              XCAD_FTA_SUBTYPE_Group  
   *              XCAD_FTA_SUBTYPE_CoordinateDimension
   *              XCAD_FTA_SUBTYPE_GeneralTolerance
   *              XCAD_FTA_SUBTYPE_DatumTarget
   *              XCAD_FTA_SUBTYPE_DatumSimple
   *           For Partial surface (restricted area) Type :
   *              XCAD_FTA_SUBTYPE_RestrictedArea
   *           For View Type :
   *              XCAD_FTA_SUBTYPE_View
   * Mandatory method
   */
   virtual HRESULT GetNodeAnnotationType(const void* iNodeID, CATString&amp; oAnnotationType, CATString&amp; oAnnotationSubType) = 0;

   /**
   * Retrieves the node&#x27;s tolerance value.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oAnnotationTolerance
   *				the Annotation Tolerance.
					For Size and Dimension type, the tolerance value is only for the toleranced dimensions. 
					It corresponds to the tolerance interval 
					(absolute value of the difference between the upper tolerance value and the lower tolerance value). 
					For chamfer size subtype it is the tolerance of the linear dimension.
					For Form and Position Orientation and Runout, the tolerance value is the tolerance zone size.
					All the other types of annotation do not have a tolerance value.

   */
   virtual HRESULT GetNodeAnnotationTolerance(const void* iNodeID, double&amp; oAnnotationTolerance) = 0;


   /**
   * Retrieves the 3D plane on a Node   
   * defines the 3D plane in which all node 2D geometric definitions will be expressed.
   * @param  iNodeID
   *				the node&#x27;s ID.   
   * @param Origin
   *				The Origin of space defining the plane.
   * @param VectorX
   *				The X vector of the plane.
   * @param VectorY
   *				The Y vector of the plane
   * @return
   * If current node has no plane, returns S_FALSE.
   */
   virtual HRESULT GetNodePlane(const void* iNodeID, float oOrigin[3], float oVectorX[3], float oVectorY[3]) = 0;

   /**
   * Retrieves the 2D orientation matrix in the plane returned by GetNodePlane.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oRotationMatrix
   *				the rotation component.
   * @param oTranslationVector
   *				the translation component.
   * @return
   * If current node has no orientation matrix, returns S_FALSE.
   */
   virtual HRESULT GetNodeOrientationMatrix(const void* iNodeID, float oRotationMatrix[2][2], float oTranslationVector[2]) = 0;

   /**
   * Retrieves the 2D node&#x27;s GP type.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oGPType
   *				the GP&#x27;s type.
   * @return
   * If current node isn&#x27;t a 2D GP, returns E_FAIL.
   * Mandatory method
   */
   virtual HRESULT Get2DGPType(const void* iNodeID, KindOf2DGP&amp; oGPType) = 0;

   /**
   * Retrieves the 2D polyline&#x27;s parameters.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oPoints
   *				the points coordinates array.
   *				Array of points coordinates: XYXYXY...
   *				Its size is equal to two times the number of points.
   * @param oNbPoints
   *				Retrieves the number of points.
   * @param oLineType
   *				Retrieves the line type.
   *				&lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   *				&lt;dl&gt;
   *				&lt;dt&gt;LINES&lt;/dt&gt; (=0)
   *				&lt;dd&gt;The number of points must be even. A line will be drawn
   *				between points 1 and 2, an other line will be drawn between
   *				points 3 and 4, ...&lt;/dd&gt;
   *				&lt;dt&gt;LINE_STRIP&lt;/dt&gt; (=1)
   *				&lt;dd&gt;The number of points can be either even or odd. A line will
   *				be drawn between points 1 and 2, then, an other line will be drawn
   *				between points 2 and 3, ...&lt;/dd&gt;
   *				&lt;dt&gt;LINE_LOOP&lt;/dt&gt; (=2)
   *				&lt;dd&gt;Same as &lt;tt&gt;LINE_STRIP&lt;/tt&gt;, excepted that one more line will be
   *				drawn between the last and the first points.&lt;/dd&gt;
   *				&lt;/dl&gt;
   * @return
   * If current node hasn&#x27;t a 2D Polyline Data, returns E_FAIL.
   */
   virtual HRESULT Get2DPolyLineData(const void* iNodeID, float **oPoints, int *oNbPoints, int *oLineType) = 0;


   /**
   * Retrieves the 2D polygon&#x27;s parameters.
   * Specification: The last contour is external, the others are internal (in order to define holes).
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oPoints
   *				the points coordinates array.
   *				Array of points coordinates: XYXYXY...
   *				Its size is equal to two times the number of points.
   * @param oNbContour
   *           The number of contour.   
   *
   * @param oNbOfPtPerContour
   *           The number of points for each contour.
   *   
   * @return
   * If current node hasn&#x27;t a 2D Polygon Data, returns E_FAIL.
   */   
   virtual HRESULT Get2DPolygonData(const void* iNodeID, float **oPoints, int *oNbContour, int **oNbOfPtPerContour) = 0;

 
   /**
   * Retrieves the 2D face&#x27;s parameters.
   * @param oPoints
   *   Array containing the x, y  coordinates for
   *   each point of the polygon. Its size is equal
   *   to two times the number of points. So, the coordinates
   *   x, y of the first point are respectively stored in iPoints[0], and  iPoints[1],
   *   the coordinates x, y of the second point, in iPoints[2], iPoints[3], and so on...
   * @param oNbPoint
   *   The number of points used to define the polygon.
   * @param oFill
   *	the integer which allows to construct a 2D polygon
   *	just with edges or filled with graphic attributes.
   *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;: 
   *	&lt;ul&gt;&lt;li&gt;NOFILL : just edges are drawn.&lt;/li&gt;
   *	&lt;li&gt;FILL : the 2D circle arc or the 2D circle is filled
   *				with graphic attributes.&lt;/li&gt;&lt;/ul&gt;
   * @param oNbTriangles
   *	The number of group of triangles which compose the 2D polygon after the tesselation.
   * @param oType
   *	Array which contain the type of each group of triangles.
   *	&lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;:
   *	&lt;ul&gt;
   *		&lt;li&gt;0 : single triangles&lt;/li&gt;
   *		&lt;li&gt;1 : triangle strip&lt;/li&gt;
   *		&lt;li&gt;2 : triangle fan&lt;/li&gt;
   *	&lt;/ul&gt;
   *	Its size is equal to &lt;tt&gt;oNbTriangles&lt;/tt&gt;.
   * @param oTriangles
   *	Array which contain the number of vertex for each group of triangles.
   *	Its size is equal to &lt;tt&gt;oNbTriangles&lt;/tt&gt;.
   * @param oVertex
   *	Array of indices of vertex which compose the 2D polygon.&lt;br&gt;
   *	This array is composed of various arrays which represent one group of triangles.
   *	And each group of triangles have a type defined by the array &quot;oType&quot;.
   *	&lt;ul&gt;
   *	&lt;li&gt;
   *		If the group is made of single triangles, indices are written 
   *		like in the following sample :
   *	&lt;pre&gt;
   *	1              4
   *	|\           /|
   *	| \         / |
   *	|  \       /  |
   *	|   \     /   |
   *	|____\   /____|
   *	2     3  5    6  
   *	&lt;/pre&gt;
   *	&lt;/li&gt;
   *	&lt;li&gt;
   *		if the group is a triangle strip, indices are written like in the following sample :
   *	&lt;pre&gt;
   *	1     3      5
   *	-------------
   *	\     |\     |\
   *	 \    | \    | \
   *	  \   |  \   |  \
   *	   \  |   \  |   \
   *	    \ |    \ |    \
   *	     \|_____\|_____\
   *	      2      4       6
   *	&lt;/pre&gt;
   *	&lt;/li&gt;
   *	&lt;li&gt;
   *		if the group is a triangle fan, indices are written like in the following sample :
   *	&lt;pre&gt;
   *	2      1
   *	 _______    
   *	|     /|\
   *	|    / | \
   *	|   /  |  \
   *	|  /   |   \
   *	| /    |    \
   *	|/_____|_____\
   *	3      4      5
   *	&lt;/pre&gt;
   *	&lt;/li&gt;
   *	&lt;/ul&gt;
   * DO NOT USE this method
   */
   virtual HRESULT Get2DFaceData(const void* iNodeID, float **oPoints, int *oNbPoint, int *oFill, 
                                    int * oNbTriangle, int ** oType, int ** oTriangle, int ** oVertex) = 0;

   /**
   * Retrieves the 2D circle arc&#x27;s parameters.
   * @param oCenter
   *	         the center of the 2D circle arc, it is a 2D point.
   * @param oRadius
   *	         the radius of the 2D circle arc.
   * @param oBegin_angle
   *	         the begin angle to construct a 2D circle arc.
   *	         &lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;: the default value is 0.
   *	         By this way, it creates a 2D circle.
   * @param oEnd_angle
   *	         the end angle to construct a 2D circle arc.
   *	         &lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;: the default value is 2*pi.
   *	         By this way, it creates a 2D circle.
   * @param oFill
   *	         the integer which allows to construct a 2D circle arc
   *	         just with edges or filled with graphic attributes.
   *	         &lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;: 
   *		         &lt;br&gt;NOFILL : (=0) just edges are drawn.
   *		         &lt;br&gt;FILL : (=1) the 2D circle arc or the 2D circle is filled
   *				              with graphic attributes.
   */
   virtual HRESULT Get2DArcCircleData(const void* iNodeID, double **oCenter, double *oRadius, 
                                       double *oBegin_angle, double *oEnd_angle, int *oFill) = 0;

   /**
   * Retrieves the color of a node.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oRed
   *				the red component.
   *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oRed&lt;/tt&gt; ranges from 0 to 255.
   * @param oGreen
   *				the green component.
   *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oGreen&lt;/tt&gt; ranges from 0 to 255.
   * @param oBlue
   *				the blue component.
   *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oBlue&lt;/tt&gt; ranges from 0 to 255.
   * @param oAlpha
   *				the alpha component.
   *				&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;oAlpha&lt;/tt&gt; ranges from 0 to 255.
   */
   virtual HRESULT GetNodeColor(const void* iNodeID, unsigned int* oRed, unsigned int* oGreen, unsigned int* oBlue, unsigned int* oAlpha = NULL) = 0;


   /**
   * Retrieves the properties of a node.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oShow
   *				the Show component.
   *           &lt;b&gt;Legal values&lt;/b&gt;: 1=Show - 0=No_show
   * @param oThickness
   *				the Thickness component.
   *				Real value of the thickness in millimeters.
   * @param oNodeName
   *				the name of the Annotation
   */
   virtual HRESULT GetNodeProperties(const void* iNodeID, unsigned int* oShow, float* oThickness, CATUnicodeString&amp; oNodeName) = 0;

   /**
   * Retrieves the link to geometry of a node.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oNbGeometricID
   *				the number of Identifier of the geometric element to which the annotation is attached
   * @param oGeometricID
   *				the Identifier of the geometric element to which the annotation is attached
   */
   virtual HRESULT GetNodeGeometry(const void* iNodeID, int * oNbGeometricID , int* &amp;oGeometricID) = 0; 


   /**
   * Retrieves the link to associated annotation of a node.
   * The associated annotation(s) has(have) been created before by same API.
   * Datum simple pointing on one or several Datum targets.
   * View pointing on one or several annotations (except Group or View annotations).
   * Group pointing on one or several annotations (except Group or View annotations).
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param oNbAssociatedAnnotationID
   *				the number of Identifier of the associated annotation element to which the annotation is attached
   * @param oAssociatedAnnotationID
   *				the Identifier of the associated annotation to which the annotation is attached
   *                The caller must delete this array...
   */
   virtual HRESULT GetNodeAssociatedAnnotation(const void* iNodeID, int * oNbAssociatedAnnotationID , void** &amp;oAssociatedAnnotationID) = 0; 

   /**
   * Retrieves the 3D viewpoint (camera) for a Group feature.
   * @param iNodeID
   *				The Group node&#x27;s ID.
   * @param oOrigin
   *				The origin (point) of the camera.
   * @param oDirection
   *				The sight direction (vector) of a 3D camera.
   *           It results a rotation of the camera around it&#x27;s origin.
   *           This direction must be perpendicular to the up direction.   
   * @param oZenith
   *				The up direction (vector) of a 3D camera.
   *           It results a rotation of the camera around it&#x27;s sight direction.
   *           This direction must be perpendicular to the sight direction.
   * @param oTarget
   *				The target point of a 3D camera.
   *           It results a change of the camera sight direction.       
   * @return
   * If current node has no camera parameters, returns S_FALSE.
   */
   virtual HRESULT GetNodeCameraParameters(const void* iNodeID, float oOrigin[3], float oDirection[3], float oZenith[3], float oTarget[3]) = 0; 


   /**
   * Retrieves the User Defined Attributes Attached to a node.
   * @param iNodeID
   *				the node&#x27;s ID.
   * @param  oNbParams,  
   *				The Number of Text Fields  attached to the node 
   * @param  oNodeParamsNames, 
   * 				the Parameter Fields 
   * @param  oNodeParamsValues 
   *				The Value Fields
   * @return
   * If no UDA, returns S_FALSE.
   */
   virtual HRESULT GetNodeUDA(const void* iNodeID, unsigned int* oNbParams,  CATUnicodeString** oNodeParamsNames, CATUnicodeString** oNodeParamsValues ) = 0; // Parameter definition TBC 

    /**
     * 
     * Retrieves the 3D camera attributes for a Group node.
     * @param iNodeID
     *              The Group node&#x27;s ID.
     * @param oCameraType
     *				The type of the camera.
     *	         &lt;br&gt;&lt;b&gt;legal values&lt;/b&gt;: 
     *		         &lt;br&gt;&quot;3D_CONIC_CAMERA&quot;
     *		         &lt;br&gt;&quot;3D_CYLINDRIC_CAMERA&quot;
     *		         &lt;br&gt;&quot;UNKNOWN_CAMERA&quot;
     * @param oCameraViewAngle
     *			This parameter is used only for &quot;3D_CONIC_CAMERA&quot; cameras
     * @param oCameraZoom
     *			This parameter is used only for &quot;3D_CYLINDRIC_CAMERA&quot; cameras
     * @return
     * If current node has no camera parameters, returns S_FALSE.
     */
    virtual HRESULT GetNodeCameraAttributes(const void* iNodeID, CATUnicodeString &amp;oCameraType, double &amp;oCameraViewAngle, double &amp;oCameraZoom) = 0 ;

    /** 
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the line style characteristics for the current node
    * @param iNodeID
    *              The Annotation node&#x27;s ID.
    * @param oPattern
    *		    	The line style pattern
    *          &lt;br&gt; This argument must be processed as a &quot;linear bitmap&quot; :
    *          &lt;br&gt; Each &quot;1&quot; bit represents a shown pixel
    *          &lt;br&gt; Each &quot;0&quot; bit represent an unshown pixel.
    * @param oRatio
    *              The line style ratio
    *          &lt;br&gt; Use this argument as a magnification factor of the pattern.
    *          &lt;br&gt; Exemple : if pattern is 27242 (0110101001101010 in binary) and ratio is 3,
    *          &lt;br&gt; the line must be drawned like this (* are shown pixel, . are unshown) :
    *          &lt;br&gt;  ...******...***...***......******...***...***...
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeLineStyle(const void* iNodeID, unsigned short &amp;oPattern, unsigned short &amp;oRatio ) = 0 ;

    /** 
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the &quot;Parallel To Screen&quot; state for a node.
    *
    * @param iNodeID [in]
    *   the node&#x27;s ID.
    * @param oParallelToScreenState [out]
    *   The &#x27;Parrallel to screen&#x27; state
    * @param oZoomableState [out]
    *   The &#x27;Zoomable&#x27; state (only if the &#x27;Parrallel to screen&#x27; state is TRUE)
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeAnnotationParallelToScreenState(const void* iNodeID, CATBoolean &amp;oParallelToScreenState, CATBoolean &amp;oZoomableState) = 0 ;

    /** 
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the &quot;Parallel To Screen&quot; origin for a GP node.
    *
    * @param iNodeID [in]
    *   the node&#x27;s ID.
    * @param Origin
    *	The Origin in model coordinates of the &quot;Parralel To Screen&quot; GP.
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeGPParallelToScreenOrigin (const void* iNodeID, float oOrigin[3]) = 0 ;

    /**
     * 
     * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the attributes for a Group node.
     * @param iNodeID
     *              The Group node&#x27;s ID.
     * @param oActiveViewNodeId Active View NodeID.
     *          &lt;br&gt; If NULL : There is no Active view for this group.
     * @param oClippingState
     *			&lt;br&gt; TRUE : The active view is used to define a clipping plane.
     *          &lt;br&gt; FALSE : There is no clipping plane applied.
     */
    virtual HRESULT GetNodeAnnotationGroupAttributes(const void* iNodeID, void *&amp;oActiveViewNodeId, CATBoolean &amp;oClippingState) = 0 ;

    /** 
    * GetNodeAnnotationGroupAssociatedBodies
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the bodies (geometric sets, ...) 
    * that are visually managed by this Group.
    * The associated bodies are not shown in default case; they become visible with the Group.
    * This method should be used only with XCAD option to get 
    * the 3D tessellated representation with structure.
    *
    * @param iNodeID [in]
    *   the node&#x27;s ID.
    * @param oNbOfAssociatedBodiesID [out]
    *   the number of Identifiers of the Associated bodies
    * @param oAssociatedBodiesID [out]
    *   The array of Identifiers of the Associated bodies, corresponding 
    *   to ID in the 3D tessellated representation with structure.
    *   The caller must delete this array:
    *   delete [] oAssociatedBodiesID ;
    *   oAssociatedBodiesID = NULL ;
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeAnnotationGroupAssociatedBodies(const void* iNodeID,   unsigned int &amp;oNbOfAssociatedBodiesID,   void** &amp;oAssociatedBodiesID) = 0 ;

    /** 
    * GetNodeAnnotationConstructionGeometry
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entities of the Annotations.
    *
    * @param iRootNodeID [in]
    *   the node&#x27;s ID.
    * @param oNbConstructionGeometryNode [out]
    *   the number of Construction geometry entities of the Annotations.
    * @param oConstructionGeometryNodeID [out]
    *   The array of Identifiers of the number of Construction geometry entities of the Annotations.
    *   The caller must delete this array:
    *   delete [] oConstructionGeometryNodeID ;
    *   oConstructionGeometryNodeID = NULL ;
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeAnnotationConstructionGeometry(const void* iRootNodeID, unsigned int &amp; oNbConstructionGeometryNode ,  void** &amp;oConstructionGeometryNodeID) = 0 ;


    /** 
    * GetNodeConstructionGeometryNameAndType
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Name and Type
    *
    * @param iConstructionGeometryNode [in]
    *   the node&#x27;s ID.
    * @param oConstructionGeometryType [out]
    *   The CG entity Type
    *   Depending on this type, the following methods GetNodeCG*Parameters can be used on the node&#x27;s ID.
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeConstructionGeometryType(const void* iConstructionGeometryNode, CATUnicodeString &amp; oConstructionGeometryType ) = 0 ;


    /** 
    * GetNodeCGPointParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Point)
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oPointParameters[3] [out]
    *   The point coord (XYZ)
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGPointParameters   (const void* iConstructionGeometryNode,  double oPointParameters[3]) = 0 ;
    
    /** 
    * GetNodeCGLineParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Line)
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oStartPoint [out]
    *   The start point coord (XYZ)
    * @param oEndPoint [out]
    *   The end point coord (XYZ)
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGLineParameters    (const void* iConstructionGeometryNode,  double oStartPoint [3],    double oEndPoint [3]) = 0 ;
    
    /** 
    * GetNodeCGCircleParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Circle)
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oRadius [out]
    *   The radius of the circle
    * @param oPlaneOrigin [out]
    *   The Origin point coord (XYZ)
    * @param oPlaneFirstDirection [out]
    *   The first vector coord (XYZ)
    * @param oPlaneSecondDirection [out]
    *   The second vector coord (XYZ)
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGCircleParameters  (const void* iConstructionGeometryNode,   /*double oOriginPoint [3],*/  double &amp; oRadius,              
        double oPlaneOrigin [3],                  double oPlaneFirstDirection [3],             double oPlaneSecondDirection [3]) = 0 ;
    
    /** 
    * GetNodeCGPlaneParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Plane)
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oOriginPoint [out]
    *   The origin point coord (XYZ)
    * @param oFirstVector [out]
    *   The first vector start and end points coord (2 * XYZ)
    * @param oSecondVector [out]
    *   The second vector start and end points coord (2 * XYZ)
    * @param oAngle [out]
    *   The angle in radians
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGPlaneParameters   (const void* iConstructionGeometryNode,  double oOriginPoint [3],   double oFirstVector [2][3],    double oSecondVector[2][3], double &amp; oAngle) = 0 ;
    
    /** 
    * GetNodeCGCylinderParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Cylinder)
    * A cylinder will be obtained by the revolution of a line parallel to the given axis, 
    *  around the position point, at a distance given by the radius value of this point.
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oPositionPoint [out]
    *   The origin point coord (XYZ)
    * @param oRadius [out]
    *   The radius value
    * @param oStartPoint [out]
    *   The start point of the parallel axis of revolution, to build the cylinder
    * @param oEndPoint [out]
    *   The end point of the parallel axis of revolution, to build the cylinder
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGCylinderParameters(const void* iConstructionGeometryNode,  double oPositionPoint [3], double &amp; oRadius,              double oStartPoint [3],     double oEndPoint [3]) = 0 ;
    
    /** 
    * GetNodeCGThreadComponents
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Thread)
    * A thread is defined by one cylinder (cf. GetNodeCGCylinderParameters)
    *  and two planes (cf. twice GetNodeCGPlaneParameters).
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oThreadCylinderPositionPoint [out]
    *   cf. GetNodeCGCylinderParameters 2nd argument
    * @param oThreadCylinderRadius [out]
    *   cf. GetNodeCGCylinderParameters 3rd argument
    * @param oThreadCylinderStartPoint [out]
    *   cf. GetNodeCGCylinderParameters 4th argument
    * @param oThreadCylinderEndPoint [out]
    *   cf. GetNodeCGCylinderParameters 5th argument
    * @param oThreadUpperPlaneOriginPoint [out]
    *   cf. GetNodeCGPlaneParameters 2nd argument
    * @param oThreadUpperPlaneFirstVector [out]
    *   cf. GetNodeCGPlaneParameters 3rd argument
    * @param oThreadUpperPlaneSecondVector [out]
    *   cf. GetNodeCGPlaneParameters 4th argument
    * @param oThreadUpperPlaneAngle [out]
    *   cf. GetNodeCGPlaneParameters 5th argument
    * @param oThreadLowerPlaneOriginPoint [out]
    *   cf. GetNodeCGPlaneParameters 2nd argument
    * @param oThreadLowerPlaneFirstVector [out]
    *   cf. GetNodeCGPlaneParameters 3rd argument
    * @param oThreadLowerPlaneSecondVector [out]
    *   cf. GetNodeCGPlaneParameters 4th argument
    * @param oThreadLowerPlaneAngle [out]
    *   cf. GetNodeCGPlaneParameters 5th argument
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGThreadComponents  (const void* iConstructionGeometryNode,  
        double oThreadCylinderPositionPoint [3],  double &amp; oThreadCylinderRadius,              double oThreadCylinderStartPoint [3],      double oThreadCylinderEndPoint [3],                                                                       
        double oThreadUpperPlaneOriginPoint [3],  double oThreadUpperPlaneFirstVector [2][3],  double oThreadUpperPlaneSecondVector[2][3],    double &amp; oThreadUpperPlaneAngle,
        double oThreadLowerPlaneOriginPoint [3],  double oThreadLowerPlaneFirstVector [2][3],  double oThreadLowerPlaneSecondVector[2][3],    double &amp; oThreadLowerPlaneAngle ) = 0 ;

    /** 
    * GetNodeCGThreadParameters
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the Construction geometry entity Parameters (for a Thread)
    * A thread is represented by two parallel circle arcs, joined by two lines,
    * with a third circle arc (internal), between both others (external : upper and lower).
    * This method gives the two external circle arcs.
    * The start and end points of each arc are also the extremities of the thread lines
    * (start upper arc to start lower arc, end upper arc to end lower arc).
    * The average of both external circle arcs parameters gives the internal circle arc parameters.
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oUpperCircleCenterPoint [out]
    *   Center point coord. (X Y Z) of the Upper external circle
    * @param oUpperCircleRadius [out]
    *   The radius of the Upper external circle
    * @param oUpperCirclePlaneFirstDirection [out]
    *   The First direction of the Upper circle support plane
    * @param oUpperCirclePlaneSecondDirection [out]
    *   The Second direction of the Upper circle support plane
    * @param oUpperCircleStartPoint [out]
    *   The Strat point of the Upper external circle arc
    * @param oUpperCircleEndPoint [out]
    *   The End point of the Upper external circle arc
    * @param oLowerCircleCenterPoint [out]
    *   Center point coord. (X Y Z) of the Lower external circle
    * @param oLowerCircleRadius [out]
    *   The radius of the Lower external circle
    * @param oLowerCirclePlaneFirstDirection [out]
    *   The First direction of the Lower circle support plane
    * @param oLowerCirclePlaneSecondDirection [out]
    *   The Second direction of the Lower circle support plane
    * @param oLowerCircleStartPoint [out]
    *   The Strat point of the Lower external circle arc
    * @param oLowerCircleEndPoint [out]
    *   The End point of the Lower external circle arc
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGThreadParameters(const void* iConstructionGeometryNode, 
       double oUpperCircleCenterPoint [3] ,          double &amp; oUpperCircleRadius,           
       double oUpperCirclePlaneFirstDirection [3] ,  double oUpperCirclePlaneSecondDirection [3] , 
       double oUpperCircleStartPoint [3] ,           double oUpperCircleEndPoint [3] , 
       double oLowerCircleCenterPoint [3],           double &amp; oLowerCircleRadius,         
       double oLowerCirclePlaneFirstDirection [3] ,  double oLowerCirclePlaneSecondDirection [3] , 
       double oLowerCircleStartPoint [3] ,           double oLowerCircleEndPoint [3] ) = 0 ;


    /** 
    * GetNodeCGUID
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: To get the UID of a Construction Geometry entity, from its NodeID.
    *
    * @param iConstructionGeometryNode [in]
    *   The CG node&#x27;s ID.
    * @param oListOfIDs [out]
    *   The list of UID for each geometrical component of the input CG.
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeCGUID(const void* iConstructionGeometryNode, 
       CATListOfInt &amp; oListOfIDs ) = 0 ;


    /** 
    * GetNodeAnnotationGroupAssociatedCG
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrieves the CG (Construction geometry entities) 
    * that are visually managed by this Group.
    * The associated CG are not shown in default case; they become visible with the Group.
    *
    * @param iNodeID [in]
    *   the node&#x27;s ID.
    * @param oNbOfAssociatedCGID [out]
    *   the number of Identifiers of the Associated CG
    * @param oAssociatedCGID [out]
    *   The array of Identifiers of the Associated CG, corresponding 
    *   to ID returned by GetNodeAnnotationConstructionGeometry.
    *   The caller must delete this array:
    *   delete [] oAssociatedBodiesID ;
    *   oAssociatedBodiesID = NULL ;
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeAnnotationGroupAssociatedCG(const void* iNodeID,   unsigned int &amp;oNbOfAssociatedCGID,   void** &amp;oAssociatedCGID) = 0 ;




    /** 
    * Short role of the method.
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Retrive CATUnicodeString equivalent for FTA.
    *
    * @param iAnnotationNode [in]
    *   Annotation Node
    * @param oValidationString [out]
    *   Equivalent UnicodeString
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if everything ran ok, otherwise...
    *
    */
    virtual HRESULT GetNodeAnnotationValidationString( const void * iAnnotationNode, CATUnicodeString &amp; oValidationString) = 0;

    /** 
    * Retrieves the path of the link to geometry of a node.
    *
    * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: In addition to GetNodeGeometry() method, 
    * this method gives the full path between the current annotation
    * and the geometrical element(s) given by GetNodeGeometry() method.
    * This method must be used only if the current annotation and
    * the linked geometrical element(s) are not in the same Document.
    *
    * @param iNodeID [in]
    *   The node&#x27;s ID.
    * @param oNbOfGeometryPathes [out]
    *   The number of Pathes (size of the array oGeometryPathesTable).
    * @param oGeometryPathesTable [out]
    *   Array of List of CATUnicodeString to define the full pathes.
    *   Each element of this array is a List of CATUnicodeString that corresponds to a path.
    *   Each element of such list must be composed like this:
    *   &quot;Type1:Value1:Type2:Value2&lt;...&gt;:&quot; (the &quot;:&quot; character is a separator that must not be used in the path elements)
    *   Sample: if the path is MyAnnotation &gt; MyProduct &gt; MyPartInstance.1 &gt; MyPart &gt; MyBody 
    *   (where those strings are some Name identifiers), 
    *   the list describing this path will be composed by 5 strings:
    *   1 &gt; &quot;Name:MyAnnotation:&quot;
    *   2 &gt; &quot;Name:MyProduct:&quot;
    *   3 &gt; &quot;Name:MyPartInstance.1:&quot;
    *   4 &gt; &quot;Name:MyPart:&quot;
    *   5 &gt; &quot;Name:MyBody:&quot;
    *   The identifiers types can be customized but the Name type is mandatory.
    *   Sample: &quot;Name:MyProduct:Type:ASMProd:UID:0dfe4885:&quot;
    *   Input and Output implementations must communicate on what kinds of identifiers are used by this method.
    *
    * @return
    *   &lt;code&gt;S_OK&lt;/code&gt; if one or more path is returned
    *   &lt;code&gt;E_FAIL&lt;/code&gt; if no path is defined
    *   (e.g. when there is no linked geometry or if the linked geometry is in the same document, ...)
    *
    */
    virtual HRESULT GetNodeGeometryFullPath(const void* iNodeID,
                                                              int &amp; oNbOfGeometryPathes ,
                                                              CATListOfCATUnicodeString* &amp;oGeometryPathesTable) = 0 ;



  // No constructors or destructors on this pure virtual base class
  // --------------------------------------------------------------
};
CATDeclareHandler(CATIExchangeTessellatedAnnotationRepresentation, CATBaseUnknown);
//------------------------------------------------------------------

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATIExchangeTabulatedCylinder.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIExchangeTabulatedCylinder.h</a></div>
        <div><a href="CATIExchangeTessellatedRepresentation.html">‰∏ã‰∏ÄÈ°µ: CATIExchangeTessellatedRepresentation.h ‚Üí</a></div>
    </div>
</body>
</html>