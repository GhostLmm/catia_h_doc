<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATRdgInterfaces/PublicInterfaces/CATIRdgLight.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CATRdgInterfaces/PublicInterfaces/CATIRdgLight.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATIRdgGeometry.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIRdgGeometry.h</a></div>
        <div><a href="CATIRdgMaterial.html">‰∏ã‰∏ÄÈ°µ: CATIRdgMaterial.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATIRdgLight_h
#define CATIRdgLight_h

// COPYRIGHT DASSAULT SYSTEMES 2003

/**
 * @CAA2Level L0
 * @CAA2Usage U3
 */

#include &quot;CATRdgItfCPP.h&quot;
#include &quot;CATIRdgBase.h&quot;
#include &quot;CATBooleanDef.h&quot;


#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATRdgItfCPP IID IID_CATIRdgLight;
#else
extern &quot;C&quot; const IID IID_CATIRdgLight;
#endif

/** 
 * Interface for lights.
 * &lt;b&gt;Role&lt;/b&gt;:
 * This is the interface that every light implements.
 * It is used to access the data needed for rendering.
 */

class ExportedByCATRdgItfCPP CATIRdgLight : public CATIRdgBase
{
/** @nodoc */
  CATDeclareInterface;

  public:

/**
 * Returns the transformation matrix.
 * @param oTransfo
 *   The matrix. The coefficients are given COLUMN by COLUMN.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetTransfo(double oTransfo[12]) = 0;

/** @nodoc */
    enum CATLightType { Spot=1, Point=2, Directional=3 };

/**
 * Returns the light type.
 * @param oType
 *   The light type.
 *   &lt;ul&gt; light type.
 *   &lt;li&gt; Spot &lt;/li&gt;
 *   &lt;li&gt; Point &lt;/li&gt;
 *   &lt;li&gt; Directional &lt;/li&gt;
 *   &lt;/ul&gt;
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetLightType(CATIRdgLight::CATLightType &amp;oType) = 0;

/**
 * Returns the light colors.
 * @param oAmbient
 *   The RGB ambient color. Each color component
 *   ranges from &lt;code&gt;0.&lt;/code&gt; to &lt;code&gt;1.&lt;/code&gt;. 
 * @param oDiffuse
 *   The RGB diffuse color. Each color component
 *   ranges from &lt;code&gt;0.&lt;/code&gt; to &lt;code&gt;1.&lt;/code&gt;. 
 * @param oSpecular
 *   The RGB specular color. Each color component
 *   ranges from &lt;code&gt;0.&lt;/code&gt; to &lt;code&gt;1.&lt;/code&gt;. 
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetColors(double oAmbient[3], double oDiffuse[3], double oSpecular[3]) = 0;

/**
 * Returns the light intensity. 
 * @param oIntensity
 *   The light intensity. 
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetIntensity(double &amp;oIntensity) = 0;

/**
 * Returns the spot light angle. The angle ranges
 * from &lt;code&gt;0.&lt;/code&gt; to &lt;code&gt;90.&lt;/code&gt;.
 * @param oAngle
 *   The spot light angle (in degrees).
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetSpotAngle(double &amp;oAngle) = 0;

/**
 * Returns the light maximum distance of illumination.
 * The light illuminates from its origin to its end
 * distance. Objects farther than this distance are not
 * affected by the light.
 * @param oDistance
 *   The distance of illumination end.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetEndDistance(double &amp;oDistance) = 0;

/**
 * Returns the light attenuation values.
 * It represents where the light intensity starts 
 * to attenuate.
 * @param oDistance
 *   The distance of attenuation start.
 *   The light illuminates from its origin to its end
 *   distance. Objects farther than this distance are not
 *   affected by the light.
 * @param oAngle
 *   The attenuation angle (in degrees).
 *   It represents the angle from the light axis where
 *   the illumination starts to attenuate.
 *   When this parameter is equal to the spot angle, there is
 *   no angle attenuation.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetAttenuation(double &amp;oStart, double &amp;oAngle) = 0;

/**
 * Returns the light falloff exponent.
 * It represents the the way light attenuates.
 * It is an exponent so the falloff is 1/exp(oExponent).
 * Physically correct lights have an exponent of 2.
 * 0 means no attenuation.
 * @param oExponent
 *   The falloff exponent.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetFalloffExponent(double &amp;oExponent) = 0;

/**
 * Returns the shadow status.
 * @param oStatus
 *   The shadow status.
 *   &lt;ul&gt; shadow status.
 *   &lt;li&gt; TRUE  light casts shadows &lt;/li&gt;
 *   &lt;li&gt; FALSE light does not cast shadows &lt;/li&gt;
 *   &lt;/ul&gt;
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetShadowStatus(CATBoolean &amp;oStatus) = 0;

/** @nodoc */
    enum CATLightArea { None=1, Rectangle=2, Disk=3, Sphere=4, Cylinder=5 };

/**
 * Returns the light area type.
 * @param oType
 *   The light area.
 *   &lt;ul&gt; light area.
 *   &lt;li&gt; None &lt;/li&gt;
 *   &lt;li&gt; Rectangle &lt;/li&gt;
 *   &lt;li&gt; Disk &lt;/li&gt;
 *   &lt;li&gt; Sphere &lt;/li&gt;
 *   &lt;li&gt; Cylinder &lt;/li&gt;
 *   &lt;/ul&gt;
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetAreaType(CATIRdgLight::CATLightArea &amp;oType) = 0;

/**
 * Returns the light area visibility status.
 * @param oStatus
 *   The area visibility status.
 *   &lt;ul&gt; active status.
 *   &lt;li&gt; TRUE  light area is rendered &lt;/li&gt;
 *   &lt;li&gt; FALSE light area is not rendered &lt;/li&gt;
 *   &lt;/ul&gt;
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetShowAreaStatus(CATBoolean &amp;oStatus) = 0;

/**
 * Returns the rectangle area size.
 * @param oLength
 *   The length value (in mm).
 * @param oWidth
 *   The width value (in mm).
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetRectangleArea(double &amp;oLength, double &amp;oWidth) = 0;

/**
 * Returns the disk area size.
 * @param oRadius
 *   The radius value (in mm).
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetDiskArea(double &amp;oRadius) = 0;

/**
 * Returns the sphere area size.
 * @param oRadius
 *   The radius value (in mm).
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetSphereArea(double &amp;oRadius) = 0;

/**
 * Returns the cylinder area size.
 * @param oRadius
 *   The radius value (in mm).
 * @param oHeight
 *   The height value (in mm).
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetCylinderArea(double &amp;oRadius, double &amp;oHeight) = 0;

/**
 * Returns the number of samples taken in each direction 
 * when the area light is sampled.
 * @param oSamplesU
 *   The number of samples taken in the U direction.
 * @param oSamplesV
 *   The number of samples taken in the V direction.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetAreaSamples(int &amp;oSamplesU, int &amp;oSamplesV) = 0;

/**
 * Returns the indirect illumination status.
 * @param oStatus
 *   The indirect illumination status.
 *   &lt;ul&gt; indirect illumination status.
 *   &lt;li&gt; TRUE  indirect illumination is enabled &lt;/li&gt;
 *   &lt;li&gt; FALSE indirect illumination is disabled &lt;/li&gt;
 *   &lt;/ul&gt;
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetIndirectIlluminationStatus(CATBoolean &amp;oStatus) = 0;

/**
 * Returns the indirect illumination energy.
 * @param oEnergy
 *   The energy.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetEnergy(double &amp;oEnergy) = 0;

/**
 * Returns the maximum number of photons to 
 * store from this light source.
 * @param oCaustics
 *   The maximum number of stored photons
 *   for caustics.
 * @param oGlobal
 *   The maximum number of stored photons
 *   for global illumination.
 * @return
 *   An HRESULT value.
 *   &lt;br&gt;&lt;b&gt; Legal values&lt;/b&gt;:
 *   &lt;li&gt;&lt;tt&gt;S_OK&lt;/tt&gt; the operation succeeded &lt;/li&gt;
 *   &lt;li&gt;&lt;tt&gt;E_FAIL&lt;/tt&gt; otherwise &lt;/li&gt;.
 */
    virtual HRESULT GetPhotons(int &amp;oCaustics, int &amp;oGlobal) = 0;
};

/** @nodoc */
CATDeclareHandler(CATIRdgLight,CATIRdgBase);

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATIRdgGeometry.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATIRdgGeometry.h</a></div>
        <div><a href="CATIRdgMaterial.html">‰∏ã‰∏ÄÈ°µ: CATIRdgMaterial.h ‚Üí</a></div>
    </div>
</body>
</html>