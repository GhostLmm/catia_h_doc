<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DialogEngine/PublicInterfaces/CATStateCommand.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>DialogEngine/PublicInterfaces/CATStateCommand.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATStateCancelNotification.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATStateCancelNotification.h</a></div>
        <div><a href="CATStateCondition.html">‰∏ã‰∏ÄÈ°µ: CATStateCondition.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATStateCommand_H
#define CATStateCommand_H
#include &quot;CATDialogEngine.h&quot;

// COPYRIGHT DASSAULT SYSTEMES 1999
// protected DI0STATE.m

/**
 * @CAA2Level L1
 * @CAA2Usage U2
 */

#include &quot;CATDialogAgent.h&quot;

#include &quot;CATDlgEngUtility.h&quot;
#include &quot;CATCommand.h&quot;
#include &quot;CATDiaAction.h&quot;
#include &quot;CATDialogState.h&quot;
#include &quot;CATUnicodeString.h&quot;
#include &quot;CATStateCondition.h&quot;
#include &quot;CATAcquisitionFilter.h&quot;
#include &quot;CATDiaError.h&quot;
#include &quot;CATBooleanDef.h&quot;

class CATDialogTransition;
class CATCommandGlobalUndo;
class CATString;
class CATFrmEditor;
class CATBaseUnknown;

/**
 * Base class for a State Command.
 * &lt;b&gt;Role&lt;/b&gt;: A State Command is a command modeled as a state machine.
 * It is a graph made of states linked between them using incoming and
 * outgoing transitions. 
 * The states are composed of dialog agents which let the end user input the
 * requested parameters. 
 * Conditions may be associated with states and transitions in order to 
 * guide the progression according to the user inputs. Actions are linked
 * to states and transition to execute the know-how of the command.
 * &lt;br&gt;
 * To create a State Command, derive the &lt;tt&gt;CATStateCommand&lt;/tt&gt; class and 
 * override the methods:
 * &lt;ul&gt;
 * &lt;li&gt;@href CATCommand#Activate &lt;/li&gt;
 * &lt;li&gt;@href CATCommand#Desactivate &lt;/li&gt;
 * &lt;li&gt;@href CATCommand#Cancel &lt;/li&gt;
 * &lt;/ul&gt;
 * if needed to manage the activation cycle and above all
 * &lt;ul&gt;
 * &lt;li&gt;@href #BuildGraph &lt;/li&gt; called once before the first @href 
 * CATCommand#Activate method
 * &lt;/ul&gt;
 * in order to build the state chart.
 * &lt;p&gt;
 * &lt;b&gt;Life cycle&lt;/b&gt;
 * &lt;p&gt;
 * In general, a main State Command is allocated by the command header
 * and is deallocated by the internal focus mechanism.
 * &lt;br&gt;A main State Command ends when:
 * &lt;ul&gt;
 * &lt;li&gt;another exclusive command is activated:
 * the State Command is cancelled by the focus manager.&lt;/li&gt;
 * &lt;li&gt;the NULL state is reached:
 * the State Command cancels itself.&lt;/li&gt;
 * &lt;li&gt;the Cancel state is reached:
 * same as the NULL state, but a global Undo is executed.&lt;/li&gt;
 * &lt;li&gt;the @href CATCommand#RequestDelayedDestruction method is called:
 * a good State Command prefers to use transitions towards the NULL state.&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * &lt;b&gt;Error Management during execution&lt;/b&gt;
 * &lt;p&gt;
 * Exceptions thrown during condition evaluation or action execution must be caught
 * by the condition methods or the action methods.
 * &lt;br&gt;Nevertheless, if DialogEngine catches one, the main State Command is desactivated
 * while a default error dialog box displays information about the error.
 * Then the main State Command resumes after the error dialog box is closed.
 * 
 * @see CATDialogState, CATDialogTransition, CATStateCondition, CATDiaAction, CATDialogAgent
 */

class ExportedByCATDialogEngine CATStateCommand : public CATDialogAgent
{
  
  /** @nodoc */
  CATDeclareClass;
  
public:
  
  /**
  * Constructs a State Command.
  * @param iId
  *   The command identifier. It must be unique and is used to retrieve the 
  *   undo/redo titles in the command message file.
  * @param iBehavior
  *   The behavior of the command.
  * @param iMode
  *   The focus mode.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: With the default mode 
  *   &lt;tt&gt;CATCommandModeExclusive&lt;/tt&gt;, the command takes the focus and 
  *   cancels the other commands. This mode is mandatory if the command 
  *   modifies the model.
  *   &lt;br&gt;The other possible mode is &lt;tt&gt;CATCommandModeShared&lt;/tt&gt;: the command
  *   only deactivates the active command and takes the focus. The previous
  *   command will resume when the current command ends.
  *   &lt;br&gt;The &lt;tt&gt;CATCommandModeUndefined&lt;/tt&gt; mode is forbidden with a main
  *   State Command since it needs to take the focus, but must be used for a
  *   State Command used as an agent of another State Command.
  */
  CATStateCommand (const CATString &amp; iId, 
                   CATDlgEngBehavior iBehavior=NULL, 
                   CATCommandMode iMode=CATCommandModeExclusive);
  
  /** @nodoc
  * Constructor reserved for CATSelect (the SELECT command) and CATEditAgent only
  */
  CATStateCommand (const CATString &amp; iId, 
                   CATFrmEditor * iEditor,
                   CATDlgEngBehavior iBehavior=NULL, 
                   CATCommandMode iMode=CATCommandModeExclusive,
                   CATBoolean iCreateImpl=TRUE);
  /** @nodoc
  * Constructor reserved for P3 commands only
  */
  CATStateCommand (const CATString &amp; iId, 
                   CATCommand * iFather,
                   CATDlgEngBehavior iBehavior=NULL, 
                   CATCommandMode iMode=CATCommandModeExclusive);

  /**
  * @nodoc
  * OBSOLETE : Do not use
  */
  CATStateCommand (CATCommandMode iMode=CATCommandModeExclusive);
  /**
  * @nodoc
  * OBSOLETE : Do not use
  */
  CATStateCommand (const CATString &amp; iId,
                   CATCommandMode iMode);
  
  virtual ~CATStateCommand ();
  
  /*---------------------------------*/
  //     GRAPH DEFINITION  
  /*---------------------------------*/
  
  /**
  * Builds the command statechart.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Override this method to define the command graph.
  */
  virtual void BuildGraph (); 
  
  /** @nodoc
  * Manages the light edit manipulators.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Override this method to manage the light edit manipulators
  * &lt;br&gt;This is to be called instead of BuildGraph for undefined commands with the
  * CATDlgEngParallel behavior.
  */
  virtual void BuildParallel (); 
  
  /** @nodoc */   
  virtual HRESULT CreateGraph (); 
  
  
  /*---------------------------------*/
  //           STATES  
  /*---------------------------------*/
  
  /**
  * Creates the initial state or retrieves it if it already exists.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The initial state is the state with which the command 
  * starts. There is only one initial state.
  * @param iId
  *   The resource identifier used to retrieve the state prompt in the command
  *   message file.
  *   This identifier is useful only if the initial state doesn&#x27;t already
  *   exist. 
  * @return 
  *   The initial state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the state is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogState * GetInitialState (const CATString &amp; iId);
  
  /** @nodoc */
  virtual CATDialogState * GetInitialState ();
  
  /**
  * Creates the cancel state or retrieves it if it already exists.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: When the dialog reaches the cancel state, the command
  * ends as if it had reached the NULL state, and a global undo is executed.
  * @return 
  *   The cancel state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the state is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogState * GetCancelState ();
  
  /**
  * Creates a state.
  * @param iId
  *   The resource identifier used to retrieve the state prompt in the command
  *   message file.
  * @return 
  *   The state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the state is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogState * AddDialogState (const CATString &amp;iId);
  
  /**
  * Adds an existing state to the command.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Use this method only with @href CATPanelState states. 
  * Otherwise, use the @href #AddDialogState method which creates and adds the
  * state in the same time.
  * @param iState
  *   The state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iState&lt;/tt&gt; is kept, and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  */
  virtual void AddDialogState (CATDialogState * iState);
  
  /**
  * Declares a state as the initial state.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: May be useful if you need to modify a graph inherited 
  * from the base class but don&#x27;t use it dynamically during the dialog.
  * It replaces the previous initial state but this former state still
  * belongs to the graph. 
  * @param iState
  *   The new initial state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iState&lt;/tt&gt; is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command 
  *   destructor
  *   call.
  */
  virtual void SetInitialState (CATDialogState * iState);
  
  /**
  * Removes a state from a command.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: May be useful if you need to modify a graph inherited 
  * from the base class but don&#x27;t use it dynamically during the dialog.
  * &lt;br&gt;This state must not be linked to a transition (the transition must be
  * removed first) and must not be the cancel state nor the initial state.
  * @param iState
  *   The state to remove.
  * @return 
  *   The error return code.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:  
  *   &lt;ul&gt;
  *   &lt;li&gt;0: the state is removed successfully.&lt;/li&gt;
  *   &lt;li&gt;1: the state is not found.&lt;/li&gt;
  *   &lt;li&gt;2: the remove operation failed because the state is still useful.
  *          (it is the initial or the cancel state or it is linked to a 
  *          transition.&lt;/li&gt;
  *   &lt;/ul&gt;
  */
  virtual int RemoveState (CATDialogState * iState);
  
  /**
  * Points to the first command state.
  * @see #GetNextState 
  */
  virtual void InitStateList ();
  
  /**
  * Returns the pointed command state and points to the next one.
  * &lt;br&gt;&lt;b&gt;Precondition&lt;/b&gt;: Set the pointer to the first command state
  * using @href #InitStateList before traversing out the command state
  * list using calls to &lt;tt&gt;GetNextState&lt;/tt&gt; enclosed in a loop.
  * @return 
  *   The pointed state.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogState * GetNextState ();
  
  
  /*---------------------------------*/
  //      TRANSITIONS  
  /*---------------------------------*/
  
  /**
  * Creates a transition given its source and target states.
  * @param iSource
  *   The source state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iSource&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command 
  *   destructor call.
  * @param iTarget
  *   The target state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iTarget&lt;/tt&gt; is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: The target state may be NULL to represent the
  *   end of the command.  
  * @return 
  *   The transition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the transition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogTransition * AddTransition (CATDialogState * iSource,
                                               CATDialogState * iTarget);
  
  /**
  * Creates a transition given its source and target states, its condition 
  * and its action.
  * @param iSource
  *   The source state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iSource&lt;/tt&gt; is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @param iTarget
  *   The target state.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iTarget&lt;/tt&gt; is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor  call.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: The target state may be NULL to represent the
  *   end of the command.  
  * @param iCondition
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: The condition may be NULL or specified later
  *   by the @href CATDialogTransition#SetCondition method. A NULL condition 
  *   evaluates TRUE, so the transition fires at the first agent valuation.
  * @param iAction
  *   The action.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: The action may be NULL or specified later
  *   by the @href CATDialogTransition#SetAction method.
  * @return 
  *   The transition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the transition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogTransition * AddTransition (CATDialogState * iSource,
                                               CATDialogState * iTarget, 
                                               CATStateCondition * iCondition,
                                               CATDiaAction * iAction);
  
  /** @nodoc */
  virtual CATDialogTransition * AddTransition (CATDialogState * Initial,
                                               CATDialogState * Final,
                                               CATStateCondition * Condition);
  
  /** @nodoc */
  virtual CATDialogTransition * AddTransition (CATDialogState * Initial,
                                               CATDialogState * Final,
                                               CATDiaAction * Action);
  
  /** @nodoc */
  virtual void AddTransition (CATDialogTransition * trans);
  
  
  /**
  * Points to the first command transition.
  * @see #GetNextTransition 
  */
  virtual void InitTransitionList ();
  
  /**
  * Returns the pointed command transition and points to the next one.
  * &lt;br&gt;&lt;b&gt;Precondition&lt;/b&gt;: Set the pointer to the first command transition
  * using @href #InitTransitionList before traversing out the command 
  * transition list using calls to &lt;tt&gt;GetNextTransition&lt;/tt&gt; enclosed in a
  * loop.
  * @return 
  *   The pointed transition.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogTransition * GetNextTransition ();
  
  /**
  * Removes a transition from a command.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: May be useful if you need to modify a graph inherited 
  * from the base class but don&#x27;t use it dynamically during the dialog.
  * @param iTrans
  *   The transition to remove.
  * @return 
  *   The error return code.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:  
  *   &lt;ul&gt;
  *   &lt;li&gt;0: the transition is removed successfully.&lt;/li&gt;
  *   &lt;li&gt;1: the transition is not found.&lt;/li&gt;
  *   &lt;/ul&gt;
  */
  virtual int RemoveTransition (CATDialogTransition * iTrans);
  
  
  /*---------------------------------*/
  //      ACTIONS  
  /*---------------------------------*/
  
  /**
  * Creates a composite action which combines actions using the AND operator.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The &lt;tt&gt;iAct1&lt;/tt&gt; action is executed first. Then the
  * &lt;tt&gt;iAct2&lt;/tt&gt; action is executed whatever &lt;tt&gt;iAct1&lt;/tt&gt; returned.
  * @param iAct1
  *   The first action to execute.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iAct1&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @param iAct2
  *   The second action to execute.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iAct2&lt;/tt&gt;is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @return 
  *   The composite action.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the action is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATDiaAction * AndAction (CATDiaAction * iAct1, CATDiaAction * iAct2);
  
  /**
  * Creates a composite action which combines actions using the OR operator.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The &lt;tt&gt;iAct1&lt;/tt&gt; action is executed first. Then the 
  * &lt;tt&gt;iAct2&lt;/tt&gt; action is executed only if &lt;tt&gt;iAct1&lt;/tt&gt; returned TRUE.
  * @param iAct1
  *   The first action to execute.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iAct1&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @param iAct2
  *   The second action to execute.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iAct2&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @return 
  *   The composite action.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the action is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATDiaAction * OrAction (CATDiaAction * iAct1 , CATDiaAction * iAct2);
  
  /**
  * Creates an action given the addresses of the methods to execute.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: These methods must be methods of the current state
  * command.
  * @param iDo
  *   The method to execute in the normal mode.
  * @param iBeforeUndo
  *   The method to undo what has been done in the &lt;tt&gt;iDo&lt;/tt&gt; method.
  *   This method is executed before the transaction undo and must not 
  *   modify transactional objects.
  * @param iBeforeRedo
  *   The method to redo what has been done in the &lt;tt&gt;iDo&lt;/tt&gt; method.
  *   This method is executed before the transaction redo and must not 
  *   modify transactional objects.
  * @param iData
  *   An object that can be useful for the action.
  *   This data will be given as the argument of the 
  *   &lt;tt&gt;ActionMethod&lt;/tt&gt; methods.
  *   &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: A copy of &lt;tt&gt;iData&lt;/tt&gt; is kept. 
  *   Deallocate this object only in the command destructor.
  * @return 
  *   The action.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the action is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATDiaAction * Action (ActionMethod iDo, 
                         ActionMethod iBeforeUndo=NULL,
                         ActionMethod iBeforeRedo=NULL, 
                         void * iData=NULL);
  
  
  /*---------------------------------*/
  //      CONDITIONS  
  /*---------------------------------*/
  
  /**
  * Creates a composite condition which combines conditions using the 
  * AND operator.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The AND condition returns TRUE if its subconditions
  * return both TRUE.
  * The &lt;tt&gt;iCond1&lt;/tt&gt; condition is evaluated first. Then the &lt;tt&gt;iCond2&lt;/tt&gt;
  * condition is evaluated only if &lt;tt&gt;iCond1&lt;/tt&gt; returned TRUE.
  * @param iCond1
  *   The first condition to evaluate.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iCond1&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @param iCond2
  *   The second condition to evaluate.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iCond2&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @return 
  *   The composite condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * AndCondition (CATStateCondition * iCond1, 
                                    CATStateCondition * iCond2);
  
  /**
  * Creates a composite condition which combines conditions using the 
  * OR operator.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The OR condition returns TRUE if one of its subconditions
  * returns TRUE.
  * The &lt;tt&gt;iCond1&lt;/tt&gt; condition is evaluated first. Then the &lt;tt&gt;iCond2&lt;/tt&gt;
  * condition is evaluated only if &lt;tt&gt;iCond1&lt;/tt&gt; returned FALSE.
  * @param iCond1
  *   The first condition to evaluate.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iCond1&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @param iCond2
  *   The second condition to evaluate.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iCond2&lt;/tt&gt; is kept and 
  *   AddRef&#x27;ed. It is Released at the end of the command before the command 
  *   destructor call.
  * @return 
  *   The composite condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * OrCondition (CATStateCondition * iCond1, 
                                   CATStateCondition * iCond2);
  
  /**
  * Creates a composite condition which uses the NOT operator on its 
  * subcondition.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The NOT condition returns TRUE if its subcondition 
  * returns FALSE.
  * @param iCond
  *   The subcondition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A copy of &lt;tt&gt;iCond&lt;/tt&gt; is kept and
  *   AddRef&#x27;ed. It is Released at the end of the command before the command
  *   destructor call.
  * @return 
  *   The composite condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * NotCondition (CATStateCondition * iCond);
  
  /**
  * Creates a condition given the address of a method to execute.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method must be a method of the current State Command.
  * @param iEvaluate
  *   The method to execute to evaluate the condition.
  * @param iData
  *   An object that can be useful for the condition.
  *   This data will be given as the argument of the 
  *   &lt;tt&gt;iEvaluate&lt;/tt&gt; method.
  *   &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: A copy of &lt;tt&gt;iData&lt;/tt&gt; is kept. 
  *   Deallocate this object only in the command destructor.
  * @return 
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * Condition (ConditionMethod iEvaluate, 
                                 void * iData=NULL);
  
  /**
  * Creates a NOT condition given the address of a method to execute.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method must be a method of the current State Command.
  * &lt;br&gt;The condition returns TRUE if the method returns FALSE.
  * @param iEvaluate
  *   The method to execute to evaluate the condition.
  *   This method gives a result opposite to the condition result.
  * @param iData
  *   An object that can be useful for the condition.
  *   This data will be given as the argument of the 
  *   &lt;tt&gt;iEvaluate&lt;/tt&gt; method.
  *   &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: A copy of &lt;tt&gt;iData&lt;/tt&gt; is kept. 
  *   Deallocate this object only in the command destructor.
  * @return 
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * NotCondition (ConditionMethod iEvaluate, 
                                    void * iData=NULL);
  
  /**
  * Creates a condition which checks whether an agent is valued.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The condition evaluates TRUE if the &lt;tt&gt;iAgent&lt;/tt&gt; agent
  * is valued.
  * @param iAgent
  *   The agent.
  * @return 
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * IsOutputSetCondition (CATCommand * iAgent);
  
  /**
  * Creates a condition which checks whether an agent is the latest modified
  * agent.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The condition evaluates TRUE if the &lt;tt&gt;iAgent&lt;/tt&gt; agent
  * has just been modified and if it was due to a notification which belongs 
  * to the &lt;tt&gt;iNotifClass&lt;/tt&gt; class.
  * @param iAgent
  *   The agent.
  * @param iNotifClass
  *   The notification class.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: It can be NULL: the condition only checks if 
  *   the &lt;tt&gt;iAgent&lt;/tt&gt; agent has just been modified.  
  * @return 
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * IsLastModifiedAgentCondition (CATCommand * iAgent, 
                                                    const char * iNotifClass);
  
  /**
  * Creates a condition which checks whether an agent is the latest modified
  * agent.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The condition evaluates TRUE if the &lt;tt&gt;iAgent&lt;/tt&gt; agent
  * has just been modified and if it was due to the &lt;tt&gt;iNotif&lt;/tt&gt; 
  * notification.
  * @param iAgent
  *   The agent.
  * @param iNotif
  *   The address of a notification.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: It can be NULL: the condition only checks if 
  *   the &lt;tt&gt;iAgent&lt;/tt&gt; agent has just been modified.  
  * @return 
  *   The condition.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the condition is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  CATStateCondition * IsLastModifiedAgentCondition (CATCommand * iAgent, 
                                                    CATNotification * iNotif=NULL);
  
  
  /*---------------------------------*/
  //      FILTERS  
  /*---------------------------------*/
  
  /**
  * Creates an agent filter given the address of a method to execute.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method must be a method of the current State Command.
  * @param iMeth
  *   The method to filter the agent value.
  * @param iData
  *   An object that can be useful for the filter.
  *   This data will be given as the argument of the 
  *   &lt;tt&gt;iMeth&lt;/tt&gt; method.
  *   &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: A copy of &lt;tt&gt;iData&lt;/tt&gt; is kept. 
  *   Deallocate this object only in the command destructor.
  * @return 
  *   The filter.
  *   &lt;br&gt;&lt;b&gt;Cyclic reference&lt;/b&gt;: A pointer to the filter is kept and
  *   Released at the end of the command before the command destructor call.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  * See also: @href CATDialogAgent#AndFilter, @href CATDialogAgent#OrFilter
  * and @href CATDialogAgent#NotFilter methods.
  */
  CATAcquisitionFilter * Filter (FilterMethod iMeth, void * iData);
  
  /*---------------------------------*/
  //      VALUATION FROM THE CSO  
  /*---------------------------------*/
  
  /**
  * Declares an agent as a CSO client.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: At the beginning of the command, @href 
  * CATPathElementAgent agents declared as CSO clients will try to get valued 
  * with the @href CATPathElement objects present in the CSO.
  * &lt;br&gt;All the objects in the CSO must be used: if an object in the CSO can 
  * not be used to value an agent, all the valuations from the CSO are 
  * cancelled.
  * &lt;br&gt;This CSO client mecanism is useful to program object/action commands.
  * &lt;br&gt;As regards repeating commands, this mechanism only works at the first 
  * execution of the command.
  * @param iAgent
  *   The agent to be valued from the CSO..
  */
  void AddCSOClient (CATCommand *);
  
  /**
  * Sets the object in the CATSDO.
  * @param iObject
  *   This object  is set in the SDO 
  * @see CATCommandHeaderWithSDOForAgent
  */
  void AddSDOElement (CATBaseUnknown * iObject);
  
  
  /*---------------------------------*/
  //  INFORMATION ON THE PROCESS
  /*---------------------------------*/
  
  /**
  * Returns the current state.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: In a transition action, the current state is the source
  * state of the transition.
  * @return 
  *   The current state.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATDialogState * GetCurrentState () const;
  
  /**
  * Returns the agent which has just been modified.
  * @return 
  *   The agent.
  *   &lt;br&gt;&lt;b&gt;Lifecycle rules deviation&lt;/b&gt;: This method doesn&#x27;t AddRef the 
  *   returned value.
  */
  virtual CATCommand * GetLastModifiedAgent () const;
  
  /**
  * Tests if an agent has just been modified.
  * @param iAgent
  *   The agent.
  * @return 
  *   The result of the test.
  */
  virtual CATBoolean IsLastModifiedAgent (CATCommand * iAgent) const;
  
  /**
  * Returns the latest notification.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method only works just after the notification 
  * reception. So it cannot be used in undo/redo methods.
  * @return
  *   The notification.
  */
  virtual CATNotification * GetLastNotification () const;
  
  /** @nodoc */
  virtual CATDialogAgent::ValuationMode GetLastModificationMode () const;
  
  
  /*---------------------------------*/
  //  UNDO/REDO MANAGEMENT
  /*---------------------------------*/
  
  /**
  * Tests if a redo is being processed.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: It may be useful if a method is used as a Do and a Redo
  * method, to avoid modifying transactional objects in Redo mode.
  * @return 
  *   The result of the test.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:1 in redo mode, 0 in normal or undo mode.
  */
  virtual int IsRedoMode () const;
  
  /**
  * Returns the undo/redo object associated with the command.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method returns an object with methods to execute
  * when the command is undone or redone.
  * @return
  *   The undo/redo object.
  */
  virtual CATCommandGlobalUndo * GetGlobalUndo ();
  
  /**
  * Adds a local Undo step.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method adds a local step in the Undo stack.
  * &lt;br&gt;When a transition is executed as a consequence of an explicit acquisition agent valuation
  *     (and not as a consequence of a user action) no Undo step is stacked (whatever the agent&#x27;s behavior).
  *     This method enables you to explicitely add a local Undo step.
  * @param iUndoObject
  *   The Undo/Redo step manager for this step. No specific Undo/Redo step manager is requested
  *   if there is no specific need (Undo/Redo for features is already managed).
  * @param iUndoTitle
  *   The title displayed in the Undo history.
  * @param iUndoBehavior
  *   The behavior.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  *   &lt;br&gt;&lt;tt&gt;CATDlgEngWithUndoStep&lt;/tt&gt;: The step is displayed in the Undo history (default).
  *   &lt;br&gt;&lt;tt&gt;NULL&lt;/tt&gt;: Reserved for internal usage.
  * &lt;br&gt;&lt;b&gt;Example of usage&lt;/b&gt;: When a selection is expected, sometimes the user uses a contextual menu
  *    to create an element which will be explicitely got as an input for the selection as soon as
  *    it is created. This can be done by explicitely valuating an acquisition agent with the CSO content
  *    during resume of the main command.
  *    By default, the Undo command then undoes both selection and creation of the element.
  *    In order to enable the user to undo the selection without undoing the creation of the element,
  *    this method can be used to add a local Undo step.
  * &lt;br&gt;&lt;b&gt;Example of implementation&lt;/b&gt;:
  * &lt;pre&gt;
  *    CATPathElementAgent * curPathAgent = ...; 
  *    if (curPathAgent)
  *    {
  *      // create explicit local undo step
  *      CATCommandGlobalUndo * GlobalUndo = new CATCommandGlobalUndo;
  *      if (GlobalUndo)
  *      {
  *        AddLocalUndo(GlobalUndo,MyStep);
  *        GlobalUndo -&gt; Release(); GlobalUndo = NULL;
  *      }
  *      // value curPathAgent
  *      curPathAgent -&gt; SetValue(...);
  *      curPathAgent -&gt; SetValuation();
  *    }
  * &lt;/pre&gt;
  */
  void AddLocalUndo (CATCommandGlobalUndo * iUndoObject,
                     const CATUnicodeString &amp; iUndoTitle,
                     CATDlgEngBehavior iUndoBehavior=CATDlgEngWithUndoStep);
  /**
  * @nodoc
  * OBSOLETE
  */
  void AddLocalUndo (CATCommandGlobalUndo * UndoObject,
                     CATDlgEngBehavior UndoType=CATDlgEngWithUndoStep);
  
  /**
  * Requests to undo local steps in the State Command.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method can be used:
  * &lt;ul&gt;
  * &lt;li&gt;in the @href #Rescue method
  * or in the command which is in charge of the error management
  * (defined using the @href #SetErrorCommand method).&lt;/li&gt;
  * &lt;li&gt;during an action execution.&lt;/li&gt;
  * &lt;/ul&gt;
  * It requests to undo local steps at the end of the transition.
  * @param iCount
  *   The number of local Undos to execute.
  *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: from one (default) to the number of local undos
  *   for the State Command.  
  */
  void RequestLocalUndo (int iCount=1);
  
  /**
  * Requests to undo the State Command when it ends.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method can be used:
  * &lt;ul&gt;
  * &lt;li&gt;in the @href #Rescue method
  * or in the command which is in charge of the error management
  * (defined using the @href #SetErrorCommand method).&lt;/li&gt;
  * &lt;li&gt;during an action execution.&lt;/li&gt;
  * &lt;/ul&gt;
  * It requests a global undo at the end of the State Command.
  * &lt;br&gt;&lt;b&gt;Note&lt;/b&gt;: It is recommended to use transitions towards the
  * Cancel state rather than using this method.
  */
  void ExecuteUndoAtEnd ();
  
  /*---------------------------------*/
  //  ERROR MANAGEMENT
  /*---------------------------------*/
  
  /**
  * Cleans data if an error occurs.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Override this method to clean data after the
  * default error dialog box is closed.
  * &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: If the @href #SetErrorCommand method is used, it is useless
  * to override this method.
  */
  virtual void Rescue ();
  
  /**
  * Sets a specific command to manage errors.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This command replaces the default error dialog box displayed 
  * when an exception is caught during a condition evaluation or an action execution.
  * &lt;br&gt;It must be instantiated with the &lt;tt&gt;CATCommandModeUndefined&lt;/tt&gt; mode
  * in the @href #BuildGraph method of the main State Command,
  * and the error treatment must be done in the overridden @href CATCommand#Activate method.
  * &lt;br&gt;When an exception occurs, DialogEngine requires a shared focus for this command
  * and after the error treatment the State Command resumes.
  * @see CATCommand 
  * @param iCmd
  *   The command.
  *   &lt;br&gt;&lt;b&gt;Warning&lt;/b&gt;: A pointer to the error command is kept 
  *   without being AddRef&#x27;ed. Deallocate this command only at the end of
  *   the main State Command.
  */
  void SetErrorCommand (CATCommand * iCmd);  
  
  /**
  * Returns the error caught by DialogEngine during a condition evaluation or
  * an action execution.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: This method can be used in the @href #Rescue method
  * or in the command which is in charge of the error management
  * to get information about the error.
  * @return 
  *   The error.
  */
  CATDiaError * GetError (); 
  
  /*--------------------*/
  //  DEBUG FACILITIES
  /*--------------------*/
  
  /**
  * Sets the debug mode.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: Activates or desactivates the State Command debug trace mode.
  * &lt;br&gt;When activated, information about the command and its components
  * is displayed in the standard output at different steps of its life cycle.
  * @param iMode
  *  &lt;b&gt;Legal values&lt;/b&gt;:
  *  &lt;br&gt;&lt;tt&gt;FALSE&lt;/tt&gt; :The trace mode is not activated.
  *  &lt;br&gt;&lt;tt&gt;TRUE&lt;/tt&gt;  :The trace mode is activated.
  */
  void SetDebugMode (CATBoolean iMode);
  
  
  /*---------------------------------*/
  //  FOR INTERNAL USE
  /*---------------------------------*/
  
  
  /* notification reception */
  
  /** @nodoc */
  void ActivateCB (CATCommand * sendObject,
                   CATNotification * evt,
                   CATCommandClientData data);
  /** @nodoc */
  void DesactivateCB (CATCommand * sendObject,
                      CATNotification * evt,
                      CATCommandClientData data);
  /** @nodoc */
  void CancelCB (CATCommand * sendObject,
                 CATNotification * evt,
                 CATCommandClientData data);
  /** @nodoc */
  void AnalyseCB (CATCommand * Cmd,
                  CATNotification * Evt,
                  CATCommandClientData Data);
  
  /**
  * Requests the state command delayed destruction.
  * &lt;br&gt;&lt;b&gt;Role&lt;/b&gt;: The state command will be destroyed as soon as this will be possible.
  * This must be used only when the state command is used as an agent of another state command,
  * in this state command&#x27;s destructor.
  * This must not be used inside a state command to stop its execution.
  */
  virtual void RequestDelayedDestruction ();
  
};

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATStateCancelNotification.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATStateCancelNotification.h</a></div>
        <div><a href="CATStateCondition.html">‰∏ã‰∏ÄÈ°µ: CATStateCondition.h ‚Üí</a></div>
    </div>
</body>
</html>