<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NewTopologicalObjects/PublicInterfaces/CATTopOperator.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>NewTopologicalObjects/PublicInterfaces/CATTopOperator.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATTopMultiResult.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATTopMultiResult.h</a></div>
        <div><a href="CATTopPositionPtFaceOperator.html">‰∏ã‰∏ÄÈ°µ: CATTopPositionPtFaceOperator.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATTopOperator_H
#define CATTopOperator_H

// COPYRIGHT DASSAULT SYSTEMES  1999

/**
* @CAA2Level L1
* @CAA2Usage U1
*/ 

#include &quot;ExportedByCATTopologicalObjects.h&quot;
#include &quot;CATCGMOperator.h&quot;
#include &quot;CATTopData.h&quot;
#include &quot;CATMathDef.h&quot;
#include &quot;CATBodyFreezeMode.h&quot;

#include &quot;ListPOfCATBody.h&quot;
#include &quot;CATListOfCATGeometries.h&quot;
#include &quot;ListPOfCATCell.h&quot;
#include &quot;CATTopOpInError.h&quot;
#include &quot;CATListPOfCATCGMDiagnoses.h&quot;
#include &quot;CATIAV5Level.h&quot;
#include &quot;CATIACGMLevel.h&quot;
#include &quot;CATGeometryType.h&quot;
#include &quot;CATTopCheckJournalType.h&quot;
#ifdef CATIACGMV5R22
struct CATCGMVoBResult;
class CATLISTP(CATCGMVoBResult);
#endif 


class CATICGMUnknown;
class CATGeometry;
class CATBody;
class CATError;
class CATCGMJournal;
class CATCGMJournalList;
class CATSoftwareConfiguration;
class CATTopCheckJournalData;
class CATCGMStream;
class CATExtTopOperator;
class CATCGMODTScaleManager;
class CATCellManifoldsManager;
class CATExtTopOperator;
#ifdef CATIACGMV5R20
class CATTopMultiResult;
class CATCGMCellTracker;
#endif 

#ifdef CATIACGMV5R20
class CATContextForFastRun;
class CATContextForFastRunExt;
#endif 
class CATDeclarativeManifoldAgent;
class CATLISTP(CATDeclarativeManifoldAgent);
#ifdef CATIACGMV5R22
struct CATCGMVoBTool;
#endif 
#ifdef CATIACGMR215CAA
class CATPGMDRepBehavior;
#endif

  /**
   * Abstract class for the topological operators.
   *&lt;br&gt;
   * The topological operators follow the use frame of all operator and satisfy to the smart mechanism: the
   * input bodies are not modified. A new resulting body is created, 
   * possibly sharing data with the input ones. They are not streamable.
   * To use a topological operator:
   *&lt;ul&gt;
   * &lt;li&gt;Create it with the &lt;tt&gt;CATCreateTopXxx&lt;/tt&gt; global methods
   * &lt;li&gt;Tune it with appropriate options, using the &lt;tt&gt;SetXxx&lt;/tt&gt; methods.
   * &lt;li&gt;Run it
   * &lt;li&gt;Get the result with the &lt;tt&gt;GetResult&lt;/tt&gt; method. If you do not want 
   * to keep the resulting body, use the @href CATICGMContainer#Remove method to remove it from the 
   * geometric factory.
   *&lt;li&gt;&lt;tt&gt;delete&lt;/tt&gt; it after use.
   *&lt;/ul&gt; 
   */
class ExportedByCATTopologicalObjects CATTopOperator : public CATCGMOperator
{
  CATCGMVirtualDeclareClass(CATTopOperator);
public:
   
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //            C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

   /**
   * Destructor.
   */
   virtual ~CATTopOperator();
   
 	/**
 	* Returns a pointer to the resulting body.
	* The body is frozen and completed if &lt;tt&gt;CATBodyFreezeOn&lt;/tt&gt; is active (default mode).
	* @return
	* The pointer to the resulting body. Use @href CATICGMContainer#Remove if you do not want to keep it.
	*/
  virtual CATBody * GetResult();
   
   /**
   * Returns the pointer to the resulting body.
   * The pointer to the journal of the operation.
   * @param iJournal
   * The pointer to the journal to fill.
   * @return
   * The pointer to the resulting body. If you do not want to keep it, 
   * use the @href CATICGMContainer#Remove method to remove it from the 
   * geometric factory.
   */
   virtual CATBody* GetResult(CATCGMJournalList* iJournal);
 
   
	/**
	 * Defines the state of the resulting body.
	 * @param iOnOrOff
	 * The state of the resulting body. 
	 */
  void SetFreezeMode(CATBodyFreezeMode iOnOrOff);
	
	/**
	 * Returns the mode in which the resulting body is created.
	 * @return
	 * The smart mode.
	 */
  CATBodyFreezeMode GetFreezeMode()const;
 
   /**
   * Returns a pointer to the topological journal associated with &lt;tt&gt;this&lt;/tt&gt; CATTopOperator.
   * &lt;br&gt;Only available if a journal was given at the operator creation.
   * @return
   * The pointer to the journal of the operation.
   */
   CATCGMJournalList* GetJournal() ;

   /**
   * Returns the input objects used by &lt;tt&gt;this&lt;/tt&gt; CATTopOperator to create its journal.
   * @param oSucceeded
   * This returned value tells whether &lt;tt&gt;this&lt;/tt&gt; CATTopOperator
   * actually defined its journal inputs or not. If &lt;tt&gt;FALSE&lt;/tt&gt;,
   * the content of &lt;tt&gt;oObjects&lt;/tt&gt; should not be relied on.
   * @param oObjects
   * The list of requested inputs.
   * @param iCopy_Or_Not
   * The copy status of requested input objects.
   * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
   * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt; CATTopCheckCopy &lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;
   *     &lt;dt&gt;&lt;tt&gt; CATTopCheckNoCopy &lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;
   *     &lt;dt&gt;&lt;tt&gt; CATTopCheckNeutral &lt;/tt&gt;&lt;/dt&gt;&lt;dd&gt;&lt;/dl&gt;   
   * @param iTypeOfObjects
   * The geometric type of the requested input objects.
   */
   virtual void GetInputObjectsForJournal(CATBoolean              &amp; oSucceeded,
                                          CATLISTP(CATICGMObject) &amp; oObjects,
                                          CATTopCheckJournalType    iCopy_Or_Not = CATTopCheckCopy,
                                          CATGeometricType          iTypeOfObjects = CATBodyType) ;
  
#ifdef CATIACGMV5R21
   /**
   * @nodoc
   * Associates an interruption function with this operator.
   * @param ipInterruptFunction
   * The interruption function to be written by the application calling this operator.
   * Must return TRUE if the operator is to be interrupted.
   */
   void EnableInterrupt(CATCGMInterruptFunction ipInterruptFunction);
#endif
  

  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //               N O N - C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

   /**
   * @nodoc
   */
   virtual CATBoolean HasConsistentResult(CATLONG32 &amp; nberr, CATError **&amp; Diagnostic) const;
   
   /** @nodoc */
   void GetTopData(CATTopData&amp; oTopData) const;
   
   /** 
   * @nodoc
   * Defines the Software configuration to be taken 
   * into acccount by &lt;tt&gt;this&lt;/tt&gt; operator.
   * @param iConfig
   * The Software configuration.
   */
   virtual void SetSoftwareConfiguration(CATSoftwareConfiguration* iConfig);
   
   /** 
   * @nodoc
   * Returns the Software configuration to be taken 
   * into acccount by &lt;tt&gt;this&lt;/tt&gt; operator.
   * @return
   * The Software configuration.
   */
   virtual CATSoftwareConfiguration* GetSoftwareConfiguration() const;
   
   /** @nodoc */
   CATTopOpInError* GetWarning();

   /** @nodoc */
   void AppendWarning(CATCGMDiagnosis* iWarning);


   /** @nodoc */
   void RemoveAllWarning();

   
   /** @nodoc @nocgmitf  CheckJournal / pour donner les entrees de l&#x27;operateur ... */
   void AddInputBody(CATBody* input, CATTopCheckJournalType copy_or_not = CATTopCheckCopy);
   
   /** @nodoc @nocgmitf  CheckJournal / pour donner d&#x27;autres entree non Body (elements de sketch ...) ... */
   void AddInputObject(CATICGMObject* obj, CATTopCheckJournalType copy_or_not = CATTopCheckNoCopy);
   
   /** @nodoc @nocgmitf  CheckJournal / pour donner d&#x27;autres entree non Body (elements de sketch ...) ... */
   void AddInputObjects(const CATLISTP(CATGeometry)&amp; objs, CATTopCheckJournalType copy_or_not = CATTopCheckNoCopy);
   
   
   /** @nodoc @nocgmitf  CheckJournal /pour donner d&#x27;autres entree non Body (elements de sketch ...) ... */
   void GetInputBodies(CATLISTP(CATBody)&amp; );
   
   /** @nodoc @nocgmitf  CheckJournal /... */
   void SetOutputBody(CATBody* iResult);
   
   /** @nodoc @nocgmitf  CheckJournal /... */
   CATBody* GetOutputBody();
   

    /** @nodoc @nocgmitf CATTopCheckJournal : returns null value only if no error detected,   */
   int BasicCheckJournal(int iLevelOfCheck = 10, CATCGMOutput *iForceDump=NULL);

    /** @nodoc @nocgmitf CATTopCheckJournal   */
   virtual void RequireDefinitionOfInputAndOutputObjects();

    /** @nodoc @nocgmitf CATTopCheckJournal   */
   CATBoolean IsFullyDefinedForInputAndOutputObjects();

    /** @nodoc @nocgmitf CATTopCheckJournal   */
    void SetFullyDefinedForInputAndOutputObjects(CATBoolean iStatus);



    /** @nodoc @nocgmitf CATCGMReplay associe avec CATTopOperator::WriteInput()  */
   static void LoadInOutput(CATCGMStream&amp; ioStream, 
     CATGeoFactory*          &amp;iFactory,
     CATTopData              &amp;ioTopData,
     CATBodyFreezeMode       &amp;iFreezeMode,
     CATLISTP(CATICGMObject) &amp;ioInputCopy,
     CATLISTP(CATICGMObject) &amp;ioInputNoCopy, 
     CATBody*                &amp;ioOutputBody,
     CATLISTP(CATICGMObject) *ioInputNeutral = NULL,
     // l&#x27;appelant passe un ScaleManager s&#x27;il est pret a gerer
     // le rescale des donnees, ainsi que l&#x27;acces aux elements
     // par leur tag via ce ScaleManager. NLD020807
#ifdef CATIACGMV5R20
     CATCGMODTScaleManager   *iCGMODTScaleManager=NULL,
     CATContextForFastRunExt* iopCtxExt = NULL);
#else
     CATCGMODTScaleManager   *iCGMODTScaleManager=NULL);
#endif

    /** @nodoc @nocgmitf CATCGMReplay  */
   void WriteTopOperator(CATGeoFactory  *iFactory, 
                         CATCGMStream   &amp;ioStream, 
                         CATBoolean      iWithSpecifiedInOut = FALSE);

    /** @nodoc @nocgmitf CATCGMReplay  */
   static void ReadTopOperator(CATGeoFactory* iFactory,CATCGMStream&amp; ioStream, 
     CATTopData            &amp;ioTopData,
     CATBodyFreezeMode     &amp;iFreezeMode,
     CATBoolean iWithSpecifiedInOut       = FALSE,
     CATLISTP(CATICGMObject) *ioInputCopy   = NULL, 
     CATLISTP(CATICGMObject) *ioInputNoCopy = NULL, 
     CATBody*                *ioOutputBody  = NULL,
     CATLISTP(CATICGMObject) *ioInputNeutral = NULL,
     // l&#x27;appelant passe un ScaleManager s&#x27;il est pret a gerer
     // le rescale des donnees, ainsi que l&#x27;acces aux elements
     // par leur tag via ce ScaleManager. NLD020807
     CATCGMODTScaleManager   *iCGMODTScaleManager=NULL,
     CATContextForFastRunExt* iopCtxExt = NULL);

    /** @nodoc @nocgmitf CATCGMReplay  / CATTopCheckJournal */
   void DefineInputAndOutputObjects(CATLISTP(CATICGMObject) &amp;InputCopy,
                                    CATLISTP(CATICGMObject) &amp;InputNoCopy, 
                                    CATBody*                &amp;OutputBody,
                                    CATLISTP(CATICGMObject) *ioInputNeutral = NULL);
  
   /**
   * @nodoc
   */
   virtual CATBoolean GivesBodyAsResult() const;

   /**
   * @nodoc
   */
   virtual CATBoolean GivesValidJournalAsResult(CATCGMJournalList ** ioDuplicatedButExpectedValid) const;



    /** @nodoc @nocgmitf CATCGMReplay pour obtenir la liste des objets concernees par l&#x27;operation  */
   CATBoolean HasInOutReplayDefinition(CATLISTP(CATICGMObject) &amp; ioObjects,
                                       const CATBoolean          iAskForInputCopy    = TRUE,
                                       const CATBoolean          iAskForInputNoCopy  = TRUE,
                                       const CATBoolean          iAskForInputNeutral = TRUE,
                                       const CATBoolean          iAskForOutput       = TRUE);


  /** @nodoc  */
  inline CATExtTopOperator *GetTopExtensible(CATBoolean iRequired = TRUE) const;

   
  /** @nodoc @nocgmitf : CATCGMReplay  / Dump de la definition de l&#x27;operateur et son status actuel (Config,Input) + affinite */
  virtual void Dump( CATCGMOutput&amp; os ) ;
   
  /** @nodoc @nocgmitf : CATCGMReplay  / Dump du resultat de l&#x27;execution l&#x27;operateur (Body,Journal) + affinite */
  virtual void DumpOutput(CATCGMOutput &amp;os);

  /** @nodoc @nocgmitf : CATCGMReplay  / Sauvegarde des informations avant execution (Input/Output ,Config, ..) + affinite */
  void WriteInput(CATCGMStream  &amp; ioStream);

  /** 
  *  @nodoc 
  *  Warning: This API is not stable and is only used for debug.
  *  NOT TO BE USED IN CAA APPLICATIONS
  */
  static int CleanNewerUnused(CATICGMUnknown* ipBodyOrFactory);

  /** @nodoc : debug objets + bodies implicites */
  static int CleanAnyNewerUnused(CATICGMUnknown* ipBodyOrFactory);

   /** @nodoc  */
  void CreateManifolds(ListPOfCATBody &amp;iListOfInputBodies, CATBody * iOutputBody, 
    CATCGMJournalList* iTopOpJournal, CATCGMJournalList* ioManifoldBasedJournal = NULL);

  /** @nodoc */
  HRESULT AppendDeclarativeManifoldAgent(CATDeclarativeManifoldAgent* &amp;ioAgent);

  /** @nodoc */
  CATBody* GetLiveResult();
  /** @nodoc */
  CATBody* GetLiveResult(CATCGMJournalList* ioManifoldBasedJournal);

#ifdef CATIACGMV5R20
  public :
  /**
   * @nodoc
   * @return [out, CATBaseUnknown#Release]
  */
  virtual CATContextForFastRun* GetContextForFastRun(CATBoolean iGetOnly = FALSE);
#endif
#ifdef CATIACGMV5R20
   public :
     /** 
   * @nodoc
   *  Enable the cell tracking
   * @param iEnable
   * value used to enable or disable the cell tracking. 
   * Default value: TRUE (Enable)  
   */
	void       EnableCellTracker(CATBoolean iEnable = TRUE);

     /** 
   * @nodoc
   *  Returns the current status of Cell Tracker Activation
   * @return
   * return TRUE if enable otherwise FALSE
   */
	CATBoolean IsCellTrackerEnable();




protected :

    /** 
   * @nodoc
   * @return
   * The pointer to the journal of the operation.
   */
   virtual  CATCGMJournalList* GetJournalForCellTracker() ;

public:

     /** 
   * @nodoc
   *  Must be called after Run() 
   *  Create a cell tracker service 
   * @return
   * A pointer on the created cell tracker
   * You must delete the cell tracker after usage
   */
	virtual    CATCGMCellTracker * CreateCellTracker();

    /** 
   * @nodoc @nocgmitf
   *  Returns CATTopMultiResult if this operator is multiple result.
   * @return
   * return CATTopMultiResult * result
   */
	virtual  CATTopMultiResult * IsMultiResult();
  
#endif

#ifdef CATIACGMR217CAA
   /** 
   * @nodoc @nocgmitf
   *  Returns true for this class.
   * @return
   * return CATBoolean 
   */
   virtual  CATBoolean IsACATTopOperator();
#endif

#ifdef CATIACGMV5R22
/**
   * @nodoc
 */
  virtual void SetVoBTool(CATCGMVoBTool * iTool);

/**
   * @nodoc
 */
  virtual void GetVoBResults(CATLISTP(CATCGMVoBResult) &amp; iFailureResults, CATBoolean iBlock, CATBoolean &amp;iCompletion);
#endif

#ifdef CATIACGMR215CAA
/**
  *  @nodoc 
  *  SetDRepBehavior defines the behavior of the lifivication and of the journal.
  *  @param iDRepBehavior : Use CATDeclarativeContext and CATDeclarativeApplication to create this object. 
  *  NOT TO BE USED IN CAA APPLICATIONS
  */
  virtual void SetDRepBehavior (CATPGMDRepBehavior *iDRepBehavior);

  /**
  * Activates Failsafe mode : in the case of failure, instead of throwing an error,
  * a partial or non-optimal result is returned.
  * &lt;br&gt; Please notice that not all operators support this mode. By default an operator doesn&#x27;t support Failsafe,
  * except where it is explicitly declared.
  * &lt;br&gt; This option is not activated by default.
  * &lt;br&gt; The error diagnosis are stored by the operator, and can be retrieved via &lt;tt&gt;GetFailsafeDiagnosis&lt;/tt&gt; method.
  * @param iFailsafeMode
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt;&lt;dd&gt; Failsafe mode not active: if a failure occurs, an error is thrown.
  *     &lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt;&lt;dd&gt; Failsafe mode active: if a failure occurs, a partial result is returned.&lt;/dl&gt;
  */
  virtual void SetFailsafeMode(CATBoolean iFailsafeMode); 

  /**
  * To be used to know if Failsafe mode is active.
  * @return
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
  * &lt;dl&gt;&lt;dt&gt;&lt;tt&gt;FALSE&lt;/tt&gt;&lt;dd&gt; Failsafe mode is not active.
  *     &lt;dt&gt;&lt;tt&gt;TRUE&lt;/tt&gt;&lt;dd&gt; Failsafe mode is active.&lt;/dl&gt;
  */
  virtual CATBoolean GetFailsafeMode();

  /**
  * If Failsafe mode is active, this method allows to retrieve all failure diagnosis after &lt;tt&gt;Run&lt;/tt&gt;.
  * Failsafe mode should be activated using &lt;tt&gt;SetFailsafeMode&lt;/tt&gt; method before &lt;tt&gt;Run&lt;/tt&gt;.
  * @param oFailsafeDiagnosis
  * The list of failure diagnosis stored during the operation.
  * &lt;br&gt; All diagnosis should be destroyed by the caller using &lt;tt&gt;Release&lt;/tt&gt;.
  */
  virtual void GetFailsafeDiagnosis(CATLISTP(CATCGMDiagnosis) &amp; oFailsafeDiagnosis);

#endif

#ifdef CATIACGMR419CAA 

  /** @nodoc @nocgmitf Operator Delegation Management */
  virtual int TransferGenericSettingsToDelegateBeforeRun(CATTopOperator &amp;iDelegateOperator);  
  /** 
  * @nodoc @nocgmitf 
  * Operator Delegation Management : ioDelegateJournal might be a concatenated journal different from the one filled by the Delegate Operator
  * The mechanism allows the caller to insert an operation (conversion from exact to poly ...) before the Run and then merge the 2 journals before recording the results
  * If ioDelegateJournal is not valuated to NULL during this call, the caller is still responsible of its life cycle management
  */
  virtual int TransferResultDataFromDelegateAfterRun(CATTopOperator &amp;iDelegateOperator, CATCGMJournalList * &amp;ioDelegateJournal);

#endif


protected:

   /**
   * @nodoc
   * Virtual constructor.&lt;br&gt;
   * Cannot be called. Use the &lt;tt&gt;CATCreateTopX&lt;/tt&gt; global functions
   * to create the Xxx operator.
   */
   CATTopOperator(CATGeoFactory*     iFactory, 
                  CATTopData*        iTopData,
                  CATBodyFreezeMode  iBodyFreezeMode=CATBodyFreezeOn,
                  CATExtTopOperator *iExtensible = NULL);
   
   /** @nodoc */
   CATTopOperator(CATGeoFactory     * factory, 
                  CATCGMJournalList * journal=NULL,
                  CATBodyFreezeMode   iBodyFreezeMode=CATBodyFreezeOn,
                  CATExtTopOperator *iExtensible = NULL);


   /** @nodoc  To be or not to be a Topological Operator ...   */
   virtual CATTopOperator* IsTopological();
   
   /** @nodoc : CATCGMReplay  / Controle des donnees d&#x27;entree avant execution (Check Body d&#x27;Input) */
  virtual CATCGMOperator::CATCheckDiagnostic CheckInput(CATCGMOutput &amp; os);

   /** @nodoc : CATCGMReplay  / Controle de validite des resultats (TopCheckJournal +..) */
  virtual CATCGMOperator::CATCheckDiagnostic CheckOutput(CATCGMOutput &amp; os);

  


  /** @nodoc   dedicated to CATTopOperator/CATCGMreplay : internal use, do not overload */
  virtual void                               WriteTopOutput(CATCGMStream &amp; ioStream);

  /** @nodoc   dedicated to CATTopOperator/CATCGMreplay : internal use, do not overload */
  virtual CATTopCheckJournal*                ReadTopOutput(CATCGMStream&amp; ioStream);

  /** @nodoc   dedicated to CATTopOperator/CATCGMreplay : internal use, do not overload */
  virtual void                               DumpTopOutput(CATTopCheckJournal* iEquivalent,CATCGMOutput&amp; os);

  /** @nodoc   dedicated to CATTopOperator/CATCGMreplay : internal use, do not overload */
	virtual CATBoolean                         ValidateTopOutput(CATTopCheckJournal* iEquivalent,CATCGMOutput&amp; os);



   /** @nodoc */
   CATBody*           _Result;
   /** @nodoc */
   void SetResult(CATBody*);
   /** @nodoc */
   void SetJournal(CATCGMJournalList* Journal);
   /** @nodoc */
   virtual CATSoftwareConfiguration* GetConfig();
   /** @nodoc */
   void SetTopData(CATTopData* iTopData);

   /** @nodoc */
   CATTopData CreateTopDataForInner(CATCGMJournalList  *&amp; ioInnerJournal);

  /**  @nodoc */
#ifndef CATTopOperator_no_freezemode
	CATBodyFreezeMode  _freezemode;
#endif

  /** @nodoc CATTopCheckJournal */
  CATTopCheckJournalData* GetTopCheckJournalData(CATBoolean iRequired);

  /** @nodoc  */
  virtual CATCellManifoldsManager* CreateCellManifoldsManager(ListPOfCATBody &amp;iListOfCopyInputBodies, ListPOfCATBody &amp;iListOfNoCopyInputBodies,
    CATBody * iOutputBody, CATCGMJournalList* iTopOpJournal);

  /** @nodoc  */
#if (defined(CATIACGMV5R21) || defined(CATIAR210))
public:
#else
protected:
#endif
  virtual void ReadInputBodies(ListPOfCATBody &amp;oListOfCopyInputBodies, ListPOfCATBody &amp;oListOfNoCopyInputBodies);

protected:
#if (defined(CATIACGMV5R21) || defined(CATIAR210))
  void GetAddedAgents(CATLISTP(CATDeclarativeManifoldAgent) &amp;iAddedAgents);
#endif

#ifdef CATIACGMR215CAA
  virtual void AppendFailsafeDiagnosis(CATCGMDiagnosis * iDiagnosis);
#endif

private:
  
 
  /** @nodoc  forbidden functionnality */
  CATTopOperator(const CATTopOperator&amp;);

  /** @nodoc   forbidden functionnality */
  CATTopOperator&amp; operator=(const CATTopOperator&amp;);

  
  /** @nodoc CATTopCheckJournal */
  void CalculateInputScope();

   /** @nodoc CATTopCheckJournal */
  void CalculateInputScopeLS();
  
  /** @nodoc CATTopCheckJournal */
#ifdef CATIACGMR421CAA
  void CalculateReportOutputScope(CATBoolean iInternalOrStandardCheck, CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);
#else
  void CalculateReportOutputScope(CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);
#endif

  /** @nodoc CATTopCheckJournal */
  void CalculateReportOutputScopeOld(CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);

  /** @nodoc CATTopCheckJournal */
#ifdef CATIACGMR421CAA
  void CalculateReportOutputScopeNew(CATBoolean iInternalOrStandardCheck, CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);
#else
  void CalculateReportOutputScopeNew(CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);
#endif

  
  /** @nodoc CATTopCheckJournal */
  void CalculateReportOutputScopeLS(CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);

#ifdef CATIACGMR421CAA  
  /** @nodoc CATTopCheckJournal */
  //void CalculateReportOutputInternalScope(CATBoolean&amp; iBadGeometryType, CATBoolean&amp; iUnknownCell);
#endif
  
  
  /** @nodoc CATTopCheckJournal */
  void CalculateOutputScope();

   /** @nodoc CATTopCheckJournal */
  void CalculateOutputScopeLS();
   
  void CheckType(CATICGMObject *obj, CATCGMJournal * itm = NULL);
    
#ifdef CATIACGMR421CAA  
  /** @nodoc CATTopCheckJournal */
  int  ObjectIsInInputs(CATICGMObject *obj, CATBoolean iInternalOrStandardCheck = FALSE);
  /** @nodoc CATTopCheckJournal */
  int  ObjectIsInInternalInputs(CATICGMObject *obj);
#else
  int  ObjectIsInInputs(CATICGMObject *obj);
#endif
  
  /** @nodoc CATTopCheckJournal */
#ifdef CATIACGMR421CAA  
  int  ObjectIsInOutPut(CATICGMObject *obj, CATBoolean iInternalOrStandardCheck = FALSE);
  int  ObjectIsInInternalOutPut(CATICGMObject *obj);
#else
  int  ObjectIsInOutPut(CATICGMObject *obj);
#endif

  /** @nodoc CATTopCheckJournal */
  void ThrowError(const char * errmess, CATCGMJournal * itm = NULL);

  /** @nodoc CATTopCheckJournal */
#ifdef CATIACGMR421CAA  
  void FillScope(CATBody * iBody, CATLISTP(CATICGMObject) &amp; iScope,CATLISTP(CATICGMObject) &amp; iInternalScope);
#else
  void FillScope(CATBody * iBody, CATLISTP(CATICGMObject) &amp; iScope);
#endif

  /** @nodoc CATTopCheckJournal LIVE SHAPE */
  void FillScopeLS(CATBody * iBody, CATLISTP(CATICGMObject) &amp; iScope);
  
  /** @nodoc CATTopCheckJournal */
  void FillCells(CATBody * iBody, CATLISTP(CATCell) &amp; iCells);
  
  /** @nodoc CATTopCheckJournal */
  void DumpBodyCells(CATBody * iBody, CATCGMOutput &amp; os, const char * message = NULL);

  
  /** @nodoc mkodtimpact */
  CATSoftwareConfiguration* MustDisappearOldDeprecatedConfiguration() const;
#ifdef CATIACGMR217CAA
  /** @nodoc */
  virtual void CopyTopOperatorDataPreRunFrom (CATCGMOperator const *  iSource);
  /** @nodoc */
  virtual void CopyTopOperatorDataPostRunFrom (CATCGMOperator const *  iSource);
 /** @nodoc */
  virtual void CopyTopMultiResultDataPreRunFrom (CATCGMOperator const *  iSource);
 /** @nodoc */
  virtual void CopyTopMultiResultDataPostRunFrom (CATCGMOperator const *  iSource);
#endif

  /** @nodoc */
  CATBoolean _EmptyInputJournal;

#ifdef CATIACGMV5R20

private:

  /** @nodoc */
  CATBoolean _EnableCellTracker;

#endif 

private:
  CATLISTP(CATDeclarativeManifoldAgent)* _AddedAgents;


  /** @nodoc */
  friend class CATExtTopOperator;
};


/** @nodoc  */
inline CATExtTopOperator *CATTopOperator::GetTopExtensible(CATBoolean iRequired) const
{
  return (CATExtTopOperator *) (void *) ((_Extensible || !iRequired) ? _Extensible  : RequireExtensible() );
}

/** @nodoc @nocgmitf CATCGMReplay  */
// iTopOperator will delete iCGMODTScaleManager at destructor call
extern &quot;C&quot; ExportedByCATTopologicalObjects
void SetCGMODTScaleManager(CATTopOperator* iTopOperator,
                           CATCGMODTScaleManager* iCGMODTScaleManager) ; 

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATTopMultiResult.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATTopMultiResult.h</a></div>
        <div><a href="CATTopPositionPtFaceOperator.html">‰∏ã‰∏ÄÈ°µ: CATTopPositionPtFaceOperator.h ‚Üí</a></div>
    </div>
</body>
</html>