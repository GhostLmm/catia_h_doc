<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System/PublicInterfaces/BigLittle.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>System/PublicInterfaces/BigLittle.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="ArrayDesc.html">‚Üê ‰∏ä‰∏ÄÈ°µ: ArrayDesc.h</a></div>
        <div><a href="CATApplication.html">‰∏ã‰∏ÄÈ°µ: CATApplication.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">

// COPYRIGHT DASSAULT SYSTEMES 2000
/** @CAA2Required */
/**********************************************************************/
/* DON T DIRECTLY INCLUDE THIS HEADER IN YOUR APPLICATION CODE. IT IS */
/* REQUIRED TO BUILD CAA APPLICATIONS BUT IT MAY DISAPEAR AT ANY TIME */
/**********************************************************************/



#ifndef BigLittle
	//-----------------------------------------------------------------
	// Macro specifique Windows
	//-----------------------------------------------------------------

   // Traduction Big Endian Little Endian
//#if (defined(__SUNPRO_CC ) &amp;&amp; (__SUNPRO_CC &gt;= 0x550))

#define BigLittle(buffer,length,basictype)      \
if (length != 0 ) {                             \
  int _idx1_ = 0;                               \
  for ( ; _idx1_ &lt; length ; _idx1_ += sizeof(basictype)) { \
    char * _begin_ = (char*)(((char*)buffer)+_idx1_);      \
    char * _end_ =  _begin_ + sizeof(basictype) - 1 ;      \
    int  _idx2_ = 0;                                       \
    for ( ; _idx2_ &lt; sizeof(basictype)/2 ; _idx2_++) {     \
      char _tmp_   = *_begin_;     \
      *(_begin_++) = *_end_;       \
      *(_end_--)   = _tmp_;        \
    }                          \
  }                            \
}                              \

//#else
//	  #define BigLittle(buffer,length,basictype) 		  \
//	  if (length != 0)                                        \
//	  {                                                       \
//	  unsigned int Indice1, Indice2 ;			  \
//	  basictype WorkZone;					  \
//	  basictype* pBuffer;					  \
//	  char* pC1;						  \
//	  char* pC2; 						  \
//								  \
//	  for (Indice1 = 0 , pBuffer = buffer ; Indice1 &lt; (length/sizeof(basictype)) ; Indice1 ++, pBuffer++) \
//	  {							  \
//	   WorkZone = *(pBuffer);				  \
//	   pC1 = (char*) pBuffer;				  \
//	   pC2 = (char*) (&amp;WorkZone) +sizeof(basictype) -1 ;  	  \
//	   for (Indice2 = 0 ; Indice2 &lt; sizeof(basictype) ; Indice2++)	  \
//	   {							  \
//	    *(pC1++) = *(pC2--);				  \
//	   }							  \
//	  }							  \
//	  }							  \
//
//#endif

/* API sur big/little endian
   ************************* */

/* Explications
   ============ */

/* Problematique
   ------------- */

// Les divers possibilites de ranger les octets composant un mot machine amenent a distinguer
// les processeurs selon le mode rangement.

// Les 2 manieres de ranger les octets composant un mot machine de 16 bits sont :

//    Octet-addresse-0 | Octet-addresse-1
//   ------------------|------------------
// 1) Poid fort        | Poid faible
// 2) Poid faible      | Poid fort

// Les 2 manieres les plus repandues de ranger les octets composant un mot machine de 32 bits sont :

//    Octet-addresse-0 | Octet-addresse-1 | Octet-addresse-2 | Octet-addresse-3
//   ------------------|------------------|------------------|------------------
// 1) Poid tres fort   | Poid fort        | Poid faible      | Poid tres faible
// 2) Poid tres faible | Poid faible      | Poid fort        | Poid tres fort

// Cette dichotomie des processeurs a inspire certain a parler de sexe d&#x27;un processeur, sans preciser
// qui est male de qui est femelle. Une explication peu convaincante prouve qu&#x27;il existe d&#x27;autres possibilites
// de ranger les octets des mots de 32 bits ... je propose ce sujet sans fondement aux specialistes du genre.

// Le vocable precedant est plus croustillant mais moins epique que les petits et les grands indiens.
// Le rangement 1 est appele big    endian et caracterise les processeurs SPARC de SUN, 68000 de Motorola, etc.
// Le rangement 2 est appele little endian et caracterise les processeurs Pentium d&#x27;Intel, Alpha de Compaq, etc.

// L&#x27;adjectif &quot;big&quot; est a relier au poid &quot;fort&quot; en tete de mot, notion male par excellence,
// et complementairement, l&#x27;adjectif &quot;little&quot; est a relier au poid &quot;faible&quot; en tete de mot ...

// Quand aux indiens ici present, ils font parti d&#x27;un episode des aventures de Gulliver de Swift ou
// divers personnages cherchent a savoir par quel bout on ouvre un oeuf cuit dur.
// Cette question crutiale a servi de comparaison, sous forme de boutade, a Danny Cohen dans un article
// du 1 Avril 1980, a l&#x27;autre question existentielle a propos du sexe des processeurs.
// Comme cette question a ete qualifiee d&#x27;&quot;endian&quot;, ce qualificatif est reste parmi les informaticiens
// lorsqu&#x27;ils cherchent a savoir ce qu&#x27;il faut faire quand on manipule des donnees membres entre processeurs.

// Notons le cas d&#x27;espece &quot;bi-endian&quot; ou certains processeurs peuvent fonctionner en little ou en big endian.
// Les processeurs hermaphrodites existent, par exemple le PA-RISC d&#x27;HP, MIPS de SGI, le PowerPC, etc.

// Est-ce que l&#x27;humour gaulois, des Jacky de base, peut compenser le fait de ne pas etre des anges ? Bof !

/* Specifications
   -------------- */

// Existence de 2 flags de compilation :
// _ENDIAN_LITTLE : pour les processeurs en little endian
// _ENDIAN_BIG    : pour les processeurs en big    endian

// Il est possible d&#x27;utiliser ces flags uniquement dans les cas non adresses par l&#x27;API.

// Caracteristique de l&#x27;API :
// - traiter les donnees sur 16, 32 et 64 bits
// - traiter une donnee elementaire, traiter un tableau de donnee elementaire
// - conversion statique de little vers big endian et vis versa
// - conversion dynamique en fonction d&#x27;un flag et du processeur
// - soin apporter aux performances (en particulier, toute l&#x27;API est &quot;inline&quot;)
// - la donnee passee en argument pour chaque fonction de l&#x27;API est modifiee si necessaire

// Type des donnees pour les processeurs 32 et 64 bits et quelque soit le systeme d&#x27;exploitation :
// - 16 bits : short
// - 32 bits : int
// - 64 bits : long long
// - le type long a une implementation variable, a plutot procrire

// Pour la conversion statique de big vers little endian,
// la donnee source est en big endian et
// si le processeur est big    endian, rien n&#x27;est fait, la donnee n&#x27;est donc pas modifiee
// si le processeur est little endian, la conversion du big vers little endian est effectuee
// ce cas correspond par exemple a des donnees purement SUN a relire sur n&#x27;importe quelle machine dont Windows

// Pour la conversion statique de little vers big endian,
// la donnee source est en little endian et
// si le processeur est little endian, rien n&#x27;est fait, la donnee n&#x27;est pas modifiee
// si le processeur est big    endian, la conversion du little vers big endian est effectuee
// ce cas correspond par exemple a des donnees purement Windows a relire sur n&#x27;importe quelle machine dont AIX

// Pour la conversion dynamique,
// la donnee source est en big endian si le flag vaut 1 ou en little endian si le flag vaut 0, et
// si le processeur   a     le meme sexe que la donnee, rien n&#x27;est fait, la donnee n&#x27;est pas modifiee
// si le processeur n&#x27;a pas le meme sexe, la conversion est effectuee, la donnee est donc modifiee
// la conversion dynamique ne doit etre utilisee que si l&#x27;on connait uniquement au run-time le sexe de la donnee
// sinon la conversion statique suffit et est plus efficace.

/* Fonctions de conversion big &lt;--&gt; little endian
   ============================================== */

/* Definition
   ---------- */

static char  endian__c;
static int   endian__i;
static char *endian__p;

/* Fonction de swap de 2 octets dont on a l&#x27;adresse
   ------------------------------------------------ */

#define Endian__SwapAt(adr, o1, o2) \
    endian__c=adr[o1];              \
      adr[o1]=adr[o2];              \
      adr[o2]=endian__c

/* Fonction de swap de 2 octets
   ---------------------------- */

#define Endian__Swap(datum, o1, o2) Endian__SwapAt(((char *)(&amp;(datum))), o1, o2)

/* Fonction de conversion d&#x27;un mot de 16 bits
   ------------------------------------------ */

#define Endian_16(f, datum) \
    f(datum, 0, 1)

/* Fonction de conversion d&#x27;un mot de 32 bits
   ------------------------------------------ */

#define Endian_32(f, datum) \
    f(datum, 0, 3);         \
    f(datum, 1, 2)

/* Fonction de conversion d&#x27;un mot de 64 bits
   ------------------------------------------ */

#define Endian_64(f, datum) \
    f(datum, 0, 7);         \
    f(datum, 1, 6);         \
    f(datum, 2, 5);         \
    f(datum, 3, 4)

/* Fonction de conversion d&#x27;un tableau
   ----------------------------------- */

#define Endian__Array(adr, n, b, f)                                                      \
    for (endian__i=0, endian__p=(char *)(adr); endian__i&lt;n; endian__i++, endian__p+=b) { \
        f(Endian__SwapAt, endian__p);                                                    \
    }

/* Fonction de conversion d&#x27;un tableau de mot de 16 bits
   ----------------------------------------------------- */

#define Endian_Array16(adr, n) Endian__Array(adr, n, 2, Endian_16)

/* Fonction de conversion d&#x27;un tableau de mot de 32 bits
   ----------------------------------------------------- */

#define Endian_Array32(adr, n) Endian__Array(adr, n, 4, Endian_32)

/* Fonction de conversion d&#x27;un tableau de mot de 64 bits
   ----------------------------------------------------- */

#define Endian_Array64(adr, n) Endian__Array(adr, n, 8, Endian_64)

/* Definition des flags statiques
   ============================== */

/* Definition du flag _ENDIAN_LITTLE
   --------------------------------- */

#if defined(_LINUX_SOURCE) || defined(_WINDOWS_SOURCE)
#ifndef _ENDIAN_LITTLE
#define _ENDIAN_LITTLE
#endif

/* Definition du flag _ENDIAN_BIG
   ------------------------------ */

#elif defined(_IRIX_SOURCE) || defined(_SUNOS_SOURCE) || defined(_AIX) || defined(_HPUX_SOURCE)
#ifndef _ENDIAN_BIG
#define _ENDIAN_BIG
#endif

/* Erreur de compilation si OS/processeur inconnu (aide au portage)
   ---------------------------------------------------------------- */

#else
#error &quot;Unkown Operating System for Big or Little Endian Flag Definition.&quot;
#endif

/* Conversion statique de big endian vers little endian : cas d&#x27;une machine big endian
   =================================================================================== */

#ifdef _ENDIAN_BIG

#define Endian_BigToLittle16(datum)
#define Endian_BigToLittle32(datum)
#define Endian_BigToLittle64(datum)

#define Endian_BigToLittleArray16(datum, n)
#define Endian_BigToLittleArray32(datum, n)
#define Endian_BigToLittleArray64(datum, n)

#endif

/* Conversion statique de big endian vers little endian : cas d&#x27;une machine little endian
   ====================================================================================== */

#ifdef _ENDIAN_LITTLE

/* Conversion statique de big endian vers little endian d&#x27;une donnee elementaire sur 16 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_BigToLittle16(datum) Endian_16(Endian__Swap, datum)

/* Conversion statique de big endian vers little endian d&#x27;une donnee elementaire sur 32 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_BigToLittle32(datum) Endian_32(Endian__Swap, datum)

/* Conversion statique de big endian vers little endian d&#x27;une donnee elementaire sur 64 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_BigToLittle64(datum) Endian_64(Endian__Swap, datum)

/* Conversion statique de big endian vers little endian d&#x27;un tableau de donnees elementaires sur 16 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_BigToLittleArray16(datum, n) Endian_Array16(datum, n)

/* Conversion statique de big endian vers little endian d&#x27;un tableau de donnees elementaires sur 32 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_BigToLittleArray32(datum, n) Endian_Array32(datum, n)

/* Conversion statique de big endian vers little endian d&#x27;un tableau de donnees elementaires sur 64 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_BigToLittleArray64(datum, n) Endian_Array64(datum, n)

#endif

/* Conversion statique de little endian vers big endian : cas d&#x27;une machine little endian
   ====================================================================================== */

#ifdef _ENDIAN_LITTLE

#define Endian_LittleToBig16(datum)
#define Endian_LittleToBig32(datum)
#define Endian_LittleToBig64(datum)

#define Endian_LittleToBigArray16(datum, n)
#define Endian_LittleToBigArray32(datum, n)
#define Endian_LittleToBigArray64(datum, n)

#endif

/* Conversion statique de little endian vers big endian : cas d&#x27;une machine big endian
   =================================================================================== */

#ifdef _ENDIAN_BIG

/* Conversion statique de little endian vers big endian d&#x27;une donnee elementaire sur 16 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_LittleToBig16(datum) Endian_16(Endian__Swap, datum)

/* Conversion statique de little endian vers big endian d&#x27;une donnee elementaire sur 32 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_LittleToBig32(datum) Endian_32(Endian__Swap, datum)

/* Conversion statique de little endian vers big endian d&#x27;une donnee elementaire sur 64 bits
   ----------------------------------------------------------------------------------------- */

#define Endian_LittleToBig64(datum) Endian_64(Endian__Swap, datum)

/* Conversion statique de little endian vers big endian d&#x27;un tableau de donnees elementaires sur 16 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_LittleToBigArray16(datum, n) Endian_Array16(datum, n)

/* Conversion statique de little endian vers big endian d&#x27;un tableau de donnees elementaires sur 32 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_LittleToBigArray32(datum, n) Endian_Array32(datum, n)

/* Conversion statique de little endian vers big endian d&#x27;un tableau de donnees elementaires sur 64 bits
   ----------------------------------------------------------------------------------------------------- */

#define Endian_LittleToBigArray64(datum, n) Endian_Array64(datum, n)

#endif

/* Conversion dynamique de donnee
   ============================== */

/* Conversion dynamique d&#x27;une donnee elementaire sur 16 bits
   --------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_Dynamic16(flag, datum) if (!(flag)) {Endian_16(Endian__Swap, datum);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_Dynamic16(flag, datum) if (flag)    {Endian_16(Endian__Swap, datum);}
#endif

/* Conversion dynamique d&#x27;une donnee elementaire sur 32 bits
   --------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_Dynamic32(flag, datum) if (!(flag)) {Endian_32(Endian__Swap, datum);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_Dynamic32(flag, datum) if (flag)    {Endian_32(Endian__Swap, datum);}
#endif

/* Conversion dynamique d&#x27;une donnee elementaire sur 64 bits
   --------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_Dynamic64(flag, datum) if (!(flag)) {Endian_64(Endian__Swap, datum);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_Dynamic64(flag, datum) if (flag)    {Endian_64(Endian__Swap, datum);}
#endif

/* Conversion dynamique d&#x27;un tableau de donnees elementaires sur 16 bits
   --------------------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_DynamicArray16(flag, datum, n) if (!(flag)) {Endian_Array16(datum, n);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_DynamicArray16(flag, datum, n) if (flag)    {Endian_Array16(datum, n);}
#endif

/* Conversion dynamique d&#x27;un tableau de donnees elementaires sur 32 bits
   --------------------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_DynamicArray32(flag, datum, n) if (!(flag)) {Endian_Array32(datum, n);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_DynamicArray32(flag, datum, n) if (flag)    {Endian_Array32(datum, n);}
#endif

/* Conversion dynamique d&#x27;un tableau de donnees elementaires sur 64 bits
   --------------------------------------------------------------------- */

#ifdef _ENDIAN_BIG
#define Endian_DynamicArray64(flag, datum, n) if (!(flag)) {Endian_Array64(datum, n);}
#endif

#ifdef _ENDIAN_LITTLE
#define Endian_DynamicArray64(flag, datum, n) if (flag)    {Endian_Array64(datum, n);}
#endif

#endif
</div>
    
    <div class="navigation">
        <div><a href="ArrayDesc.html">‚Üê ‰∏ä‰∏ÄÈ°µ: ArrayDesc.h</a></div>
        <div><a href="CATApplication.html">‰∏ã‰∏ÄÈ°µ: CATApplication.h ‚Üí</a></div>
    </div>
</body>
</html>