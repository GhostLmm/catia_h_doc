<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System/PublicInterfaces/CATCORBASequence.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>System/PublicInterfaces/CATCORBASequence.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATCORBABoolean.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATCORBABoolean.h</a></div>
        <div><a href="CATCORBATypes.html">‰∏ã‰∏ÄÈ°µ: CATCORBATypes.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/* -*-c++-*- */
#ifndef _CATCORBASequence_h
#define _CATCORBASequence_h
/** @CAA2Required */
/**********************************************************************/
/* DON T DIRECTLY INCLUDE THIS HEADER IN YOUR APPLICATION CODE. IT IS */
/* REQUIRED TO BUILD CAA APPLICATIONS BUT IT MAY DISAPEAR AT ANY TIME */
/**********************************************************************/


// COPYRIGHT DASSAULT SYSTEMES 2000

#include &lt;stdarg.h&gt;
#include &quot;CATBaseUnknown.h&quot;
#include &quot;CATCORBABoolean.h&quot;
#ifdef _WINDOWS_SOURCE
#define Exported __declspec(dllexport)
#define Imported __declspec(dllimport)
#else
#define Exported 
#define Imported 
#endif

//
//	X : a one word type 
//

//
//      Window source flavoring
//

/*#ifdef _WINDOWS_SOURCE
 #undef max
 #define max max
#endif*/


#define DEF_SEQ(classname, type)  			\
class Exported classname : public CATExtendable\
{							\
  CATDeclareClass;\
private :\
  unsigned long _length;\
  unsigned long _max;\
  type *   buffer;\
  boolean _release;\
  friend class classname##_marsh;\
public:							\
   classname ();				        \
   classname (unsigned long max);\
   classname (unsigned long max, unsigned long length, type * data, boolean release=FALSE);\
   classname (const classname&amp; from);\
   ~classname ();\
   classname &amp; operator= (const classname&amp; from);\
   unsigned long length() const;\
   void length(unsigned long newLength);\
   unsigned long maximum() const;\
   type&amp; operator [] (unsigned long i);\
   const type&amp; operator [] (unsigned long i) const;\
}

#define IMPL_SEQUENCE(classname,type) \
classname::classname () : _length(0), _max(0), buffer(NULL),_release(FALSE)\
{\
}\
	\
classname::classname (unsigned long max) : _length(0), _max(max), buffer(NULL),_release(FALSE)\
{	 						\
}							\
							\
classname::classname (unsigned long max, unsigned long length, type * data, boolean release) : _length(length), _max(max), buffer(NULL),_release(release)	\
   {	 						\
     if (_release &amp;&amp; (_length &gt; 0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
           buffer[i] = data[i];\
       }\
     else if (_length &gt;0)\
       buffer = data;\
   }\
\
classname::classname (const classname&amp; from) : _length(from._length), _max(from._max), buffer(NULL),_release(from._release)		\
   {	 						\
     if (_release &amp;&amp; (_length &gt; 0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
	   buffer[i] = (type) from.buffer[i];\
       }\
   }							\
							\
classname::~classname () 				\
   {	 						\
     if (_release &amp;&amp; (buffer != NULL))\
       delete [] buffer;\
   }\
\
classname &amp; classname::operator= (const classname&amp; from)\
   {	 						\
     if (_release &amp;&amp; (buffer !=NULL))\
       delete [] buffer;\
     buffer=NULL;\
     _length=from._length;\
     _max=from._max;\
     _release = (from._release);\
     if (_release &amp;&amp; (_length &gt; 0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
	   buffer[i] = (type) from.buffer[i];\
       }\
     else if (_length&gt; 0)\
       buffer = from.buffer;\
     return *this ;\
   }\
\
unsigned long classname::length() const\
   {\
     return _length ;\
   }\
							\
void classname::length(unsigned long newLength) 			\
	{							\
		if (_length != newLength) { \
			_length = newLength ; \
			if(_release &amp;&amp; buffer)  delete[] buffer; \
			if(_length &gt; 0) { \
				_release = TRUE; \
				buffer = new type[_length]; \
			} else { \
				_release = FALSE; \
				buffer = 0; \
			} \
		} \
	}							\
							\
unsigned long classname::maximum() const 				\
   {							\
     return _max ;					\
   }							\
							\
type&amp; classname::operator [] (unsigned long i) 			\
     {							\
       return buffer [i] ;					\
     }									\
								 	        \
CATImplementClass(classname , Implementation, CATBaseUnknown, CATNull)

#define DEF_LIMSEQ(classname, dimension, type)  			\
class Exported classname : public CATBaseUnknown\
{							\
  CATDeclareClass;\
private :\
  unsigned long _length;\
  static unsigned long _max;\
  type *   buffer;\
  boolean _release;\
  friend class classname##_marsh;\
public:							\
   classname ();				        \
   classname (unsigned long length, type * data, boolean release=FALSE);\
   classname (const classname&amp; from);\
   ~classname ();\
   classname &amp; operator= (const classname&amp; from);\
   unsigned long length() const;\
   void length(unsigned long newLength);\
   unsigned long maximum() const;\
   type&amp; operator [] (unsigned long i);\
   const type&amp; operator [] (unsigned long i) const;\
}

#define IMPL_LIMSEQUENCE(classname,dimension,type) \
classname::classname () : _length(0), buffer(NULL),_release(FALSE)\
{\
}\
\
classname::classname (unsigned long length, type * data, boolean release) : _length(length), buffer(NULL),_release(release)	\
   {	 						\
     buffer = new type [_length];\
     if (_release &amp;&amp; (_length &gt; 0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
           buffer[i] = data[i];\
       }\
     else if (_length&gt;0)\
       buffer = data;\
   }							\
							\
classname::classname (const classname&amp; from) : _length(from._length), buffer(NULL),_release(from._release)		\
   {	 						\
     if (_release &amp;&amp; (_length&gt;0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
	   buffer[i] = from[i];\
       }\
     else if (_length&gt;0)\
       buffer = from.buffer;\
   }\
\
classname::~classname ()\
   {\
     if (_release &amp;&amp; (buffer !=NULL))\
       delete [] buffer;\
   }							\
							\
classname &amp; classname::operator= (const classname&amp; from)\
   {	 						\
     if (_release)\
       delete [] buffer;\
     buffer=NULL;\
     _length=from._length;\
     _release = (from._release);\
     if (_release &amp;&amp; (_length&gt;0))\
       {\
         buffer = new type [_length];\
         for (unsigned long i = 0; i&lt; _length; i++)\
	   buffer[i] = from[i];\
       }\
     else if (_length&gt; 0)\
       buffer = from.buffer;\
     return *this ;\
   }							\
							\
unsigned long classname::_max= dimension ;\
							\
unsigned long classname::length() const 				\
   {							\
     return _length ;					\
   }							\
							\
void classname::length(unsigned long newLength) 			\
   {							\
     _length=newLength ;		\
   }							\
							\
unsigned long classname::maximum() const 				\
   {							\
     return _max ;					\
   }							\
							\
type&amp; classname::operator [] (unsigned long i) 			\
{\
  return ((type*) buffer) [i] ;\
}\
								 	        \
const type&amp; classname::operator [] (unsigned long i) const					\
     {									\
       if (_length&gt;=i ) \
          {                                                            	\
           if ( i != 0 )                                        	\
             {                                                         	\
             }                                                         	\
          }                                                            	\
       return ((type*) buffer) [i] ;					\
     }\
CATImplementClass(classname , Implementation, CATBaseUnknown, CATNull)

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATCORBABoolean.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATCORBABoolean.h</a></div>
        <div><a href="CATCORBATypes.html">‰∏ã‰∏ÄÈ°µ: CATCORBATypes.h ‚Üí</a></div>
    </div>
</body>
</html>