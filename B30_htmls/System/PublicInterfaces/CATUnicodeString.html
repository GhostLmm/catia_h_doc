<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System/PublicInterfaces/CATUnicodeString.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>System/PublicInterfaces/CATUnicodeString.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATUnicodeChar.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATUnicodeChar.h</a></div>
        <div><a href="CATUuid.html">‰∏ã‰∏ÄÈ°µ: CATUuid.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATUnicodeString_H
#define CATUnicodeString_H

#ifdef _WINDOWS_SOURCE  
#ifdef __NS0S3STR
/** @nodoc */
#define ExportedByNS0S3STR  __declspec(dllexport) 
#else
/** @nodoc */
#define ExportedByNS0S3STR  __declspec(dllimport) 
#endif
#else
/** @nodoc */
#define ExportedByNS0S3STR
#endif 

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */ 

#include &lt;stdlib.h&gt;
#include &quot;CATDataType.h&quot;
#include &quot;CxxSupport.h&quot;
#include &quot;CATUnicodeChar.h&quot;
#include &quot;CATI18NTypes.h&quot;
#include &quot;CATBaseUnknown.h&quot;
#include &quot;CATBSTR.h&quot;
#include &quot;CATBoolean.h&quot;

/** @nodoc */
#define CATUSFullVsHalfWidthIgnore 0x00000001

class CATInterUnicodeString ;  
class CATString ;
#ifdef _CAT_ANSI_STREAMS
/** @c++ansi aew 2004-08-02.20:05:17 [Replace forward declaration of standard streams with iosfwd.h] **/
 #include &quot;iosfwd.h&quot;     
#else //!_CAT_ANSI_STREAMS 
class istream;    
#endif //_CAT_ANSI_STREAMS

/** 
 * Class to use for NLS character strings. 
 * &lt;b&gt;Role&lt;/b&gt;:
 * CATUnicodeString (to compare to the @href CATString class) must 
 * be used whenever a character string is
 * needed, and that is either seen, entered, or manipulated by the 
 * end user. In this way, the client application is shielded from 
 * implementation details regarding language, locale, bytecoding
 * of characters, and so forth. Client applications thus become 
 * portable since they can handle character strings expressed in 
 * any language.
 * &lt;p&gt;
 * When NLS support is not required, you can use instead the
 * @href CATString class from the System framework. It does support 
 * only ISO 646, so that to supress all the problems that arise 
 * with NLS complexity. You should never use the raw char * type.
 * &lt;p&gt;
 * &lt;b&gt;Note&lt;/b&gt;: Among the methods to manipulate instances of this class, you will find below some references to the
 * Unicode standard, to UTF-8, and to UTF-16. Unicode is a standard designed and promoted by the unicode consortium, it
 * encodes characters on two bytes. CATIA NLS strings in internalized data are encoded in Unicode 3.0 (see the code
 * charts at http://www.unicode.org ). UTF-8 is a transformation format used as a file code set, in particular for CATIA
 * persistent data. UTF-16 is used in particular by XML processors, in particular by XML parsers. The ISO 10646 standard
 * is built on the top of unicode, it includes several code sets: Unicode, known here as UCS-2 (for Universal 
 * Multiple-Octet Coded Character Set 2-byte form), UTF-8, UTF-16 and so on ...
 * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: You will find also below some references to the STEP Standard. It is descibed in ISO 10133 .
 * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: You will find also below some references to the SBCS acronym. SBCS is for Single Byte Character
 * Set, and MBCS for Multi Byte Character Set. They both correspond to localized character set (specific to a given
 * country langage, at the opposite of Unicode, which describes several country character sets simutaneously). In
 * internationalization history, SBCS and MBCS are anterior to Unicode. For example, the ISO 8859-1 encoding describes
 * several west european languages. It is a SBCS encoding, meaning that a char* in this encoding had to be interpreted
 * at the byte level (each byte corresponding to one and only one character in the Code Page, which could be described 
 * graphically as a 16 per 16 table, ordered trough the 4 first bits horizontally and its 4 last bits vertical, i.e. 
 * hexa code). The IBM-932 Code Page is an example of MBCS encoding, i.e. a  char * having to be interpreted in this
 * Code Page would have to be read the following way: 
 *  . read the first byte, if the dedicated columns (see the
 *    hexa code graphic representation mentionned above),
 *    i.e. the 8,9,E and F column for IBM-932, are set
 *    to zero, the byte will be interpreted alone
 *    (latin or single-width katakana)
 *  . otherwise, i.e. if one of the 8,9,E and F column is set,
 *    the byte, to be interpreted, will have to have the next
 *    byte read (consequently, it makes two bytes together). This
 *    solutions enables to give access to the several thousands
 *    of characters that the IBM-932 describes.
 *  . and so on ...
 * &lt;p&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The methods manipulating char* should rarely be used. They may be used:
 * &lt;ul&gt;
 * &lt;li&gt;combined with the use of Unix MOTIF services&lt;/li&gt;
 * &lt;li&gt;to display debug traces on the stdout&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;
 * The best way to manipulate strings is to use the Unicode encoding, the char* has many limitations.
 * &lt;br&gt;Suppose, for example, you call the CATUnicodeString constructor from a &quot;const char*&quot; on Windows, and, during
 * execution, the given char* contains one byte, B1 in hexa, followed by the NULL byte which ends the string. Then, the 
 * constructor from a char* will behave the following way:
 * &lt;ul&gt;
 * &lt;li&gt;if the General\&quot;Settings for the current user&quot; field in the &quot;Control Panel&quot;\&quot;Regional Options&quot; window is set to
 * English, the built CATUnicodeString will contain the &quot;PLUS-MINUS SIGN&quot; character&lt;/li&gt;
 * &lt;li&gt;if it set on Japanese, the built CATUnicodeString will contain the &quot;HALFWIDTH KATAKANA LETTER A&quot; character&lt;/li&gt;
 * &lt;li&gt;if it set on Korean, the built CATUnicodeString will have the following behavior:
 * &lt;ul&gt;
 * &lt;li&gt;a call to @href CATUnicodeString#ConvertToUCChar onto the CATUnicodeString will give one CATUC2Bytes containing the 003F character 
 * (&quot;QUESTION MARK&quot;, which is the default character)&lt;/li&gt;
 * &lt;li&gt;a call to @href CATUnicodeString#ConvertToChar onto the CATUnicodeString will give a char* containing one byte, the B1 byte&lt;/li&gt;
 * &lt;/ul&gt;
 * Actually, the B1 code belongs to the range of two-bytes code representations&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;p&gt;&lt;b&gt;CAUTION&lt;/b&gt;: This class uses the current locale. If you changed the locale in your applicative code, using
 * the setlocale sytem call for example, you must manage so that, before calling a method of this class, the current
 * locale be the locale which was the current locale when CATIA was run:
 * &lt;ul&gt;
 * &lt;li&gt;a Japanese localized string is in the IBM 932 code page. The characters, in the IBM 932
 * code page, have a code representation on one or two bytes, depending the range of the first character&lt;/li&gt;
 * &lt;li&gt;The mblen system call enables, for example when parsing a japanese localized string, to precise if the current
 * string character code representation takes one or two bytes&lt;/li&gt;
 * &lt;li&gt;the CATUnicodeString constructor from a const char* calls the mblen system call&lt;/li&gt;
 * &lt;/ul&gt;
 * Consequently, if your applicative code calls the setlocale method, and you call a CATUnicodeString method without
 * having previously restore the locale to the one which was the current locale when CATIA was run, the
 * CATUnicodeString method will not be able to parse localized strings.
 * &lt;br&gt;More generally, if your applicative code changes the locale, manage so that, before calling any CAA method, the
 * current locale be the locale which was the current locale when CATIA was run. 
 */
class ExportedByNS0S3STR  CATUnicodeString  
{

   public :

	/**
	 * Constructs an empty Unicode string.
	 */
	CATUnicodeString(); 

#if defined(DS_CXX11_SUPPORT_MOVE_SEMANTIC)
    /**
     * Move constructor.
     */
    inline CATUnicodeString(CATUnicodeString &amp;&amp;iRValue);
#endif  // DS_CXX11_SUPPORT_MOVE_SEMANTIC

	/** 
	 * Copy constructor. 
	 * @param iString 
	 *   The Unicode string to copy 
	 */
	CATUnicodeString(const CATUnicodeString&amp; iString);

  
	/**
	 * Constructs a CATUnicodeString instance from a char *.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The best way to manipulate strings is to use the Unicode encoding. The use of
  * @href #BuildFromUCChar is better than the use of the current constructor. In fact, CATIA uses this method for the
  * rare conversions from the thread code page to Unicode, i.e. :
	 * &lt;ul&gt;
	 * &lt;li&gt;parsing of message catalog strings&lt;/li&gt;
	 * &lt;li&gt;interactive input of strings on Unix&lt;/li&gt;
	 * &lt;li&gt;reading strings in databases&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @param iString
	 *   The pointer to the character string
	 */
	CATUnicodeString(const char* const iString); 

	/**
	 * Constructs a CATUnicodeString instance from a char * and a 
	 * number of characters.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The best way to manipulate strings is to use the Unicode encoding. The use of
  * @href #BuildFromUCChar is better than the use of the current constructor.
	 * @param iString
	 *   The pointer to the character string
	 * @param iLength
	 *   The number of characters to be taken into account, starting at 
	 *   the first character.
	 *   &lt;b&gt;Legal values&lt;/b&gt;: Must be less than or equal to the total 
	 *   number of characters contained in &lt;tt&gt;iString&lt;/tt&gt; 
	 */
	CATUnicodeString(const char* const iString, size_t iLength); 
   

	/**
	 * Constructs a CATUnicodeString instance by repeating a given 
	 * character.
	 * @param iChar
	 *   The character to be repeated
	 * @param iRepeatCount
	 *   The number of times &lt;tt&gt;iChar&lt;/tt&gt; is to be repeated
	 */
	CATUnicodeString(const CATUnicodeChar&amp;    iChar,   
	                size_t iRepeatCount=1);
     
	/**
	 * Constructs a CATUnicodeString instance by repeating a given 
	 * character string.
	 * @param iString
	 *   The character string to be repeated
	 * @param iRepeatCount
	 *   The number of times &lt;tt&gt;iString&lt;/tt&gt; is to be repeated
	 */
	CATUnicodeString(const CATUnicodeString&amp;  iString, 
	                size_t iRepeatCount);

	~CATUnicodeString() ;         


	/**
	 * Converts an array of Unicode characters into the current 
	 * string. 
	 * &lt;p&gt;About the Unicode standard, see above.
	 * @param iUnicodeString
	 *   The table of Unicode characters
	 * @param iStringLength
	 *   The string length in unicode characters count
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;1&lt;/tt&gt; if the string has been
	 *   successfully converted, or &lt;tt&gt;-1&lt;/tt&gt; if a problem 
	 *   occured during the conversion.
	 */
	int BuildFromUCChar(const CATUC2Bytes *iUnicodeString, 
	                   int iStringLength);

	/**
	 * Converts an array of Unicode characters into the current 
	 * string. 
	 * @param iUnicodeString
	 *   The table of Unicode characters
	 * @param iNbChar
	 *   The number of Unicode characters in the table
	 * @return
	 * @return
	 *   Integer specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the string has been
	 *   successfully converted and its length equals to zero,
	 *   &lt;tt&gt;1&lt;/tt&gt; if the string has been successfully converted
	 *   and its length does not equal to zero, or &lt;tt&gt;-1&lt;/tt&gt; 
	 *   if a problem occured during the conversion.
	 */
	int BuildFromWChar(const wchar_t *iUnicodeString);
#if defined(DS_NATIVE_WCHAR_T_DEFINED)
    int BuildFromWChar(unsigned short const *iUnicodeString);
#endif  // DS_NATIVE_WCHAR_T_DEFINED

	/**
	 * Converts, formats and stores a specified integer, under control of the format parameter, into the current string.
	 * @param iIntegerValue
	 *   The integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%d&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(int iIntegerValue, const char *iCFormat=&quot;%d&quot;);

	/**
	 * Converts, formats and stores a specified unsigned integer, under control of the format parameter, into the current
	 * string.
	 * @param iUnsignedIntegerValue
	 *   The unsigned integer value
	 * @param iCFormat
	 *   The format of the unsigned integer value, defaulted to &quot;%d&quot;, according 
	 *   to the sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
    int BuildFromNum(unsigned int iIntegerValue, const char *iCFormat=&quot;%u&quot;);

	/**
	 * Converts, formats and stores a specified long integer, under control of the format parameter, into the current
	 * string.
	 * @param iLongIntegerValue
	 *   The long integer value
	 * @param iCFormat
	 *   The format of the long integer value, defaulted to &quot;%d&quot;, according to the
	 *   sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string. 
	 */
	int BuildFromNum(long iLongIntegerValue, const char *iCFormat=&quot;%d&quot;);

	/**
	 * Converts, formats and stores a specified unsigned long integer, under control of the format parameter, into the
	 * current string.
	 * @param iUnsLongIntegerValue
	 *   The unsigned long integer value
	 * @param iCFormat
	 *   The format of the unsigned long integer value, defaulted to 
	 *   &quot;%u&quot;, according to the sprintf library function base 
	 *   conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(unsigned long iUnsLongIntegerValue, 
	                const char *iCFormat=&quot;%u&quot;);

	/**
	 * Converts, formats and stores a specified double, under control of the format parameter, into the current string.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: Regarding the decimal symbol, i.e. the character separing the integer whole number portion from
	 * its decimal portion, this service consider that it is the one corresponding to the locale. For example, on Windows,
	 * if the value for the Numbers\&quot;Decimal symbol&quot; field of the &quot;Control Panel&quot;\&quot;Regional Options&quot; window is equal to
	 * the following string:
	 * &lt;pre&gt;
	 *   {
	 * &lt;/pre&gt;
	 * then, a 1.1 number given to this service will create the following @href CATUnicodeString :
	 * &lt;pre&gt;
	 *   1{1
	 * &lt;/pre&gt;
	 * @param iDoubleValue
	 *   The double value
	 * @param iCFormat
	 *   The format of the double value, defaulted to &quot;%g&quot;, according 
	 *   to the sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(double iDoubleValue, const char *iCFormat=&quot;%g&quot;);

	/**
	 * Converts, formats and stores a specified unsigned long integer, under control of the format parameter, into the
	 * current string.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: Regarding the decimal symbol, i.e. the character separing the integer whole number portion from
	 * its decimal portion, this service consider that it is the one corresponding to the locale, See 
	 * @href CATUnicodeString#BuildFromNum , overloading version with a double.
	 * @param iLongDoubleValue
	 *   The long double value
	 * @param iCFormat
	 *   The format of the long double value, defaulted to &quot;%Lg&quot;, 
	 *   according to the sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(long double iLongDoubleValue, 
	                const char *iCFormat=&quot;%Lg&quot;);    

	/**
	 * Converts, formats and stores a specified 64-bit signed long integer,
	 * under control of the format parameter, into the current string.
	 * Defined on 64-bits platforms only.
	 * @param iLong64Value
	 *   The 64-bit long integer value
	 * @param iCFormat
	 *   The format of the 64-bit long integer value, defaulted
	 *   to &quot;%I64d&quot; on 64-bit Windows, 
	 *   according to the sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(CATLONG64  iIntegerValue, const char *iCFormat=FMTLONGI64&quot;d&quot;);
	/**
	 * Converts, formats and stores a specified 64-bit unsigned long integer,
	 * under control of the format parameter, into the current string.
	 * Defined on 64-bits platforms only.
	 * @param iLong64UnsignedValue
	 *   The 64-bit unsigned long integer value
	 * @param iCFormat
	 *   The format of the 64-bit unsigned long integer value, defaulted  
	 *   to &quot;%I64u&quot; on 64-bit Windows,
	 *   according to the sprintf library function base conversions
	 * @return
	 *   Output string length
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;Other&lt;/tt&gt; if the conversion did succeed,
	 *   in which case the value will be the byte count of the
	 *   char * equivalent to the result string.
	 */
	int BuildFromNum(CATULONG64 iUnsIntegerValue, const char *iCFormat=FMTLONGI64&quot;u&quot;);
	/**
	 * Converts, formats and stores a specified input stream,
	 * into the current string.
	 * @param iInputStream
	 *   The input stream
	 * @param iSkipWhite
	 *   The flag to indicate whether white lines must be skipped (!=0) or not (=0)
	 * @return
	 *   The input stream.
	 */
	istream&amp; BuildFromStream( istream&amp; iInputStream, 
	                         int iSkipWhite = 1); // White lines skipped if != 0

	/**
	 * Converts, formats and stores a specified STEP character string,
	 * into the current string.
	 * &lt;p&gt;
	 * Refer to part 21 of STEP for details about string encoding.
	 * @param iStepString
	 *   The pointer to the Step-encoded character string
	 * @return
	 *   boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion 
	 *   succeeded, or &lt;tt&gt;-1&lt;/tt&gt; if the conversion did not succeed.
	 */
	int  BuildFromSTEP(const char *iStepString);
  
	/**
	 * Converts, formats and stores a specified UTF-8 encoded
	 * character string (about UTF-8, see above), into the current 
	 * string.
	 * @param iUTF8Data
	 *   The pointer to the UTF-8 encoded character string
	 * @param iByteCount
	 *   The length of &lt;tt&gt;iUTF8Data&lt;/tt&gt; in bytes
	 * @return
	 *   boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion 
	 *   succeeded, or &lt;tt&gt;negative value&lt;/tt&gt; if the conversion did 
	 *   not succeed.
	 */
	int  BuildFromUTF8(const char *iUTF8Data, size_t iByteCount);

	 /**
	 * Converts, formats and stores a specified UTF-16 encoded
	 * character string (about UTF-16, see above), into the current 
	 * string.
	 * @param iUTF16Data
	 *   The pointer to the UTF-16 encoded character string
	 * @param iUnsignedShortCount
	 *   The length of &lt;tt&gt;iUTF16Data&lt;/tt&gt; in byte pairs count
	 * @return
	 *   boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;1&lt;/tt&gt; if the conversion 
	 *   succeeded, or &lt;tt&gt;negative value&lt;/tt&gt; if the conversion did 
	 *   not succeed.
	 */
	int  BuildFromUTF16(const unsigned short *iUTF16Data, size_t iUnsignedShortCount);

	/**
	 * Recycles an existing CATUnicodeString instance from a BSTR-encoded character
	 * string.
	 * A BSTR is a Basic string, or binary string, ie a pointer to a wide
	 * character string.
	 * @param iBSTR
	 *   The pointer to the BSTR-wide character string
	 * @return
	 *   boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion 
	 *   succeeded, or &lt;tt&gt;negative value&lt;/tt&gt; if the conversion did 
	 *   not succeed.
	 */
	int  BuildFromBSTR(const CATBSTR &amp;iBSTR);

	// (Re)Initializing an instance (empties it)
	// Deprecated
	/** @nodoc */
	void Reset(); 

	//----------
	// Operators
	//----------

	// Assignment
	/**
	 * Assignment operator from a char *.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The best way to manipulate strings is to use the Unicode encoding. The use of the 
	 * @href #BuildFromUCChar method is better than the use of the current operator.
	 * @param iString
	 *   The string to be copied
	 * @return  
	 *   The string resulting from the assignment
	 */
	CATUnicodeString &amp;operator =(const char    *iString);

	/**
	 * Assignment operator from a CATUnicodeString instance.
	 * @param iString
	 *   The provided string
	 * @return  
	 *   The string resulting from the assignment
	 */
    CATUnicodeString &amp;operator =(const CATUnicodeString &amp;iString);
    
#if defined(DS_CXX11_SUPPORT_MOVE_SEMANTIC)
    /**
     * Move assignment operator.
     */
    inline CATUnicodeString &amp;operator=(CATUnicodeString &amp;&amp;iRValue);
#endif  // DS_CXX11_SUPPORT_MOVE_SEMANTIC

	// Comparison
	//               CAUTION: the locale is taken into account when comparing.
	//               As a consequence, comparing two instances with different
	//               locales can lead to non-significant results.         
	/**
	 * Equality operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator == ( const CATUnicodeString &amp;iString ) 
	                                                      const ;
	/**
	 * Inequality operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator != ( const CATUnicodeString &amp;iString ) 
	                                                      const ;
	/**
	 * Less-than operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator &lt;  ( const CATUnicodeString &amp;iString ) 
	                                                      const ;

	/**
	 * Less-than or equal operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator &lt;= ( const CATUnicodeString &amp;iString ) 
	                                                      const ;

	/**
	 * Greater-than or equal operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator &gt;= ( const CATUnicodeString &amp;iString ) 
	                                                      const ;

	/**
	 * Greater-than operator.
	 * @param iString
	 *   The string to compare to the current one
	 * @return 
	 *   boolean
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0: False&lt;/tt&gt; 
	 *   the condition is not fullfilled, or &lt;tt&gt;Other: True&lt;/tt&gt; 
	 *   if the condition is fullfilled.
	 */
	int operator &gt;  ( const CATUnicodeString &amp;iString ) 
	                                                      const ;

	/**
	 * Returns the character at the specified index.
	 * An index ranges from 0 to the string length - 1. 
	 * Bound checks are performed.
	 * @param iIndex
	 *   The index of the character to extract
	 */
	CATUnicodeChar operator[](size_t iIndex) const;  
    
	//-----------------
	// Pseudooperators
	//-----------------

	/**
	 * Compares CATUnicodeString instances.
	 * @return
	 *   2 if the strings are identical, 1 if only case differences are
	 *   found (&lt;tt&gt;&quot;Hello&quot; == &quot;hello&quot;&lt;/tt&gt;), and 0 otherwise.
	 */
	int Compare(const CATUnicodeString &amp;iString) const;

	/**
	 * Compares CATUnicodeString instances in a non locale specific way.
	 * The SortCompare method differs from the operators &gt; (and &lt;) in that the comparison is 
	 * not affected by locale, whereas the manner of operators &gt; (and &lt;) comparisons is determined
	 * by the LC_COLLATE category of the current locale. 
	 * @return
	 *   &lt; 0 if the current string is less than iStringToCompare.
	 *   0 if the strings are identical.
	 *   &gt; 0 if the current string is greater than iStringToCompare.
	 */
	int SortCompare(const CATUnicodeString &amp;iStringToCompare) const;

         // 
	 /** @nodoc */
	int SortCompare(const CATUnicodeString &amp;iStringToCompare , int iFlags) const;

	// Concatenation
	/**
	 * Concatenates CATUnicodeString instances.
	 * The string passed as a parameter is appended to the current string.
	 * For example:
	 * &lt;pre&gt;
	 * CATUnicodeString Hello(&quot;Hello&quot;);
	 * CATUnicodeString Goodbye(&quot;Goodbye&quot;);
	 * Hello.Append(Goodbye);      // Hello now contains &quot;HelloGoodbye&quot;
	 * &lt;/pre&gt;
	 */
	CATUnicodeString&amp; Append( 
	                   const CATUnicodeString &amp;iString );

	// Capitalization
	/**
	 * Converts all of the lower characters in this String to upper 
	 * case.
	 */
   void ToUpper(); 

	/**
	 * Converts all of the upper characters in this String to lower 
	 * case.
	 */
	void ToLower();

	// Substring extraction
	/**
	 * Returns a new string that is a substring of this string.
	 * @param iSubStringFirstIndex
	 *   The first character to be extracted
	 * @param iNbCharsToExtract
	 *   The number of characters to be extracted
	 */
	CATUnicodeString SubString ( int  iSubStringFirstIndex, 
	                            int  iSubStringCharCount)const ;

   //------------------
   // Format conversion
   //------------------

	/**
	 * Read character data, supposed to describe an integer
	 * in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param oIntegerValue
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%d&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(int           *oIntegerValue, 
	                const char *iCFormat=&quot;%d&quot;)   const;

	/**
	 * Read character data, supposed to describe an unsigned 
	 * integer in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param oUnsIntegerValue
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%u&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(unsigned int *oUnsIntegerValue, 
	                const char *iCFormat=&quot;%u&quot;) const;

	/**
	 * Read character data, supposed to describe a long integer
	 * in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param olongIntegerValue
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%d&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(long          *olongIntegerValue, 
	                const char *iCFormat=&quot;%d&quot;)  const;

	/**
	 * Read character data, supposed to describe an unsigned long 
	 * integer in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param oUnslongIntegerValue
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%u&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(unsigned long *oUnslongIntegerValue, 
	                const char *iCFormat=&quot;%u&quot;) const;

	/**
	 * Read character data, supposed to describe a 64-bit long integer
	 * in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param olongIntegerValue
	 *   The resulting 64-bit long integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%I64d&quot; on 64-bit Windows, 
	 *   according to the sprintf library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(CATLONG64          *olongIntegerValue, 
	                const char *iCFormat=FMTLONGI64&quot;d&quot;)  const;

	/**
	 * Read character data, supposed to describe a 64-bit unsigned long 
	 * integer in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * @param oUnslongIntegerValue
	 *   The resulting 64-bit unsigned long integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%I64u&quot; on 64-bit Windows
	 *   according to the sprintf library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(CATULONG64 *oUnslongIntegerValue, 
	                const char *iCFormat=FMTLONGI64&quot;u&quot;) const;

	/**
	 * Read character data, supposed to describe an double in an 
	 * alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output 
	 * parameter.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: Regarding the decimal symbol, i.e. the character separing the integer whole number portion from
	 * its decimal portion, this service consider that it is the one corresponding to the locale. For example, on Windows,
	 * if the value for the Numbers\&quot;Decimal symbol&quot; field of the &quot;Control Panel&quot;\&quot;Regional Options&quot; window is equal to
	 * the following string:
	 * &lt;pre&gt;
	 *   {
	 * &lt;/pre&gt;
	 * then, so that the current method give the correct value, a 1.1 number must be stored the following way in the
	 * instance:
	 * &lt;pre&gt;
	 *   1{1
	 * &lt;/pre&gt;
	 * @param oDouble
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%le&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(double        *oDouble, 
	                const char *iCFormat=&quot;%le&quot;)  const;

	/**
	 * Read character data, supposed to describe an long double in an alphanumerical form, interpret it according to
	 * a format, and store the converted result into the output parameter.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: Regarding the decimal symbol, i.e. the character separing the integer whole number portion from
	 * its decimal portion, this service consider that it is the one corresponding to the locale, See 
	 * @href CATUnicodeString#ConvertToNum , overloading version with a double.
	 * @param oLongDouble
	 *   The resulting integer value
	 * @param iCFormat
	 *   The format of the integer value, defaulted to &quot;%le&quot;, according to the sprintf
	 *   library function base conversions
	 * @return
	 *   Boolean specifying the success or not of the action
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; if the conversion didn&#x27;t
	 *   succeed, or &lt;tt&gt;1&lt;/tt&gt; if the conversion did succeed.
	 */
	int ConvertToNum(long double   *oLongDouble, 
	                const char *iCFormat=&quot;%le&quot;)  const;
 
	/**
	 * Convert the current string into a STEP character string.
	 * @param oStepString
	 *   The resulting STEP string
	 */
	void ConvertToSTEP( char *oStepString) const;

	/**
	 * Convert the current string into a UTF-8 character string.
	 * @param oUTF8String
	 *   The resulting UTF-8 string
	 *   It should be allocated as a table of 
	 *   4*(this-&gt;GetLengthInChar()) elements
	 * @param oByteCount
	 *   String length in byte count
	 */
	void ConvertToUTF8( char *oUTF8String, size_t *oByteCount) const; 


	 /**
	 * Convert the current string into a UTF-16 character string.
	 * @param oUTF16Data
	 *   The resulting UTF-16 string
	 *   It should be allocated as a table of 
	 *   4*(this-&gt;GetLengthInChar()) bytes
	 * @param oUnsignedShortCount
	 *   String length in unsigned short count
	 */
	void ConvertToUTF16(unsigned short *oUTF16String, size_t *oUnsignedShortCount) const;
  
	/**
	 * Convert the current string into a BSTR (OLE basic string).
	 * @param oBSTR
	 *   The resulting BSTR string
	 */
	void ConvertToBSTR( CATBSTR *oBSTR) const;

	// If the CATUnicodeString was created using the constructor from a &quot;const char* const&quot;, and the input char* was invalid
	// (i.e. it contained bytes which didn&#x27;t correspond to effective characters in the current locale), the current method
	// returns the same invalid char* that the one which was given to the constructor.
	//  For example, in a korean session, if the following char* was given to the constructor:
	//    0xB1 0x00 ,
	// (which does not correspond to an effective character in korean, since a 0xB1 byte requires another byte after to form
	// a character) the method will return:
	//    0xB1 0x00
	/**
	 * Converts the string to a char *.&lt;/br&gt;
	 * &lt;b&gt;Role&lt;/b&gt;: Converts the current string to a char* in the thread locale code page. The use of this service
	 * corresponds to strings for which all characters belong to the character set of the thread locale code page.
  * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;: The length of the returned string is given by @href #GetLengthInByte.
  * If the string has been created using @href #BuildFromUCChar , @href #BuildFromWChar , @href #BuildFromUTF8 ,
  * @href #BuildFromSTEP , @href #BuildFromUTF16 or @href #BuildFromBSTR , and a character of the string does not
  * exist in the thread locale code page, the character will be replaced, in the returned C string, by the following
  * coded representation:
  * &lt;pre&gt;
  * +-------------------------+------------+------------+------------+------------+
  * ! thread locale code page !  Windows   !     AIX    !    HP-UX   !    SunOS   !
  * +-------------------------+------------+------------+------------+------------+
  * +-------------------------+------------+------------+------------+------------+
  * !        ISO 8859-1       !     3F     !     1A     !     1A     !     3F     !
  * +-------------------------+------------+------------+------------+------------+
  * !        ISO 8859-2       !     3F     !     1A     !     1A     !     3F     !
  * +-------------------------+------------+------------+------------+------------+
  * !        ISO 8859-5       !     3F     !     1A     !     1A     !     3F     !
  * +-------------------------+------------+------------+------------+------------+
  * !        IBM 943          !     3F     ! 7F or FCFC !     FCFC   !     3F     !
  * +-------------------------+------------+------------+------------+------------+
  * !        EUC KR           !     3F     ! 1A or AFFE !     FFFF   !    3F3F    !
  * +-------------------------+------------+------------+------------+------------+
  * !        EUC TW           !     3F     ! 1A or FDFE !     FEFE   !    3F3F    !
  * +-------------------------+------------+------------+------------+------------+
  * !        EUC CN           !     3F     ! 1A or A1A1 !     FFFF   !    3F3F    !
  * +-------------------------+------------+------------+------------+------------+
  * &lt;/pre&gt;
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The best way to manipulate strings is to use the Unicode encoding. The use of the following method: 
  * &lt;pre&gt;  operator const CATUC2Bytes*() const;&lt;/pre&gt; is better than the use of the current operator. In fact, CATIA
  * uses the current method for the rare conversions from Unicode to the thread code page, i.e. :
	 * &lt;ul&gt;
	 * &lt;li&gt;the display of message strings in dialog windows on Unix&lt;/li&gt;
	 * &lt;li&gt;the edition of strings on Unix&lt;/li&gt;
	 * &lt;li&gt;output traces&lt;/li&gt;
	 * &lt;li&gt;storing strings in databases&lt;/li&gt;
	 * &lt;/ul&gt;
	 * @return 
	 *   The char*
	 */
	const char* ConvertToChar() const;

	// Deprecated since the implicit use of the cast is too dangerous
	// (very often the users don&#x27;t know how to use it)
	/** @nodoc */
	operator  const char *  () const ;

	// If the CATUnicodeString was created using the constructor from a &quot;const char* const&quot;, and the input char* was invalid
	// (i.e. it contained bytes which didn&#x27;t correspond to effective characters in the current locale), the CATUC2Bytes*
	// returned by the current method has the following value:
	//   - on Windows: pointer to a nul CATUC2Bytes
	//   - on Unix:    pointer to a non representative CATUC2Bytes
	//  For example, in a korean session, if the following char* was given to the constructor:
	//    0xB1 0x00 ,
	// (which does not correspond to an effective character in korean, since a 0xB1 byte requires another byte after to form
	// a character) the method will return a pointer to a nul CATUC2Bytes on Windows and a pointer to a non representative
	// CATUC2Bytes on Unix
	/** @nodoc */
	const CATUC2Bytes *ConvertToUCChar() const;

	// If the CATUnicodeString was created using the constructor from a &quot;const char* const&quot;, and the input char* was invalid
	// (i.e. it contained bytes which didn&#x27;t correspond to effective characters in the current locale), the CATUC2Bytes*
	// returned by the current method has the following value:
	//   - on Windows: pointer to a nul CATUC2Bytes
	//   - on Unix:    pointer to a non representative CATUC2Bytes
	//  For example, in a korean session, if the following char* was given to the constructor:
	//    0xB1 0x00 ,
	// (which does not correspond to an effective character in korean, since a 0xB1 byte requires another byte after to form
	// a character) the method will return a pointer to a nul CATUC2Bytes on Windows and a pointer to a non representative
	// CATUC2Bytes on Unix
	/**
	 * Converts the current string to a CATUC2Bytes character encoded 
	 * string.
	 * The length of the returned string is given by @href #GetLengthInChar.
	 * @return
	 *   The resulting CATUC2Bytes string
	 */
	operator  const CATUC2Bytes *  () const ;

	// If the CATUnicodeString was created using the constructor from a &quot;const char* const&quot;, and the input char* was invalid
	// (i.e. it contained bytes which didn&#x27;t correspond to effective characters in the current locale), the wchar_t*
	// returned by the current method has the following value:
	//   - on Windows: pointer to a nul wchar_t
	//   - on Unix:    pointer to a non representative wchar_t
	//  For example, in a korean session, if the following char* was given to the constructor:
	//    0xB1 0x00 ,
	// (which does not correspond to an effective character in korean, since a 0xB1 byte requires another byte after to form
	// a character) the method will return a pointer to a nul wchar_t on Windows and a pointer to a non representative
	// wchar_t on Unix
	/**
	 * Converts the current string to a wchar_t character encoded 
	 * string.
	 * @return
	 *   The resulting wchar_t string
	 */
	void ConvertToWChar ( wchar_t *oString ) const;
#if defined(DS_NATIVE_WCHAR_T_DEFINED)
    void ConvertToWChar ( unsigned short *oString ) const;
#endif  // DS_NATIVE_WCHAR_T_DEFINED
 
	//--------------------
	// String manipulation
	//--------------------

	/**
	 * Extends or truncates the current string.
	 * @param iCharCountToReach
	 *   The number of characters to be assigned to the current string
	 * @param iFillingChar
	 *   The character that will be added at the end of the
	 *   current string so that to map the required length
	 * @param iTruncationAllowed
	 *   The flag allowing the truncation or refusing it.
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;0&lt;/tt&gt; to forbid truncation,
	 *   or &lt;tt&gt;Other&lt;/tt&gt; to allow the possible truncation.
	 */
	void        Resize(int                   iCharCountToReach,
	                  const CATUnicodeChar&amp; iFillingChar, 
	                  int                   iTruncationAllowed);         

	/**
	 * Extends or truncates the current string.
	 * Same as the preceeding version, except that truncation is
	 * forced to be allowed.
	 * @param iCharCountToReach
	 *   The number of characters to be assigned to the current string
	 * @param iFillingChar
	 *   The character that will be added at the end of the
	 *   current string so that to map the required length
	 */
	inline void Resize(int                   iCharCountToReach, 
	                  const CATUnicodeChar&amp; iFillingChar) 
	 {Resize(iCharCountToReach, iFillingChar, 1);}

	/**
	 * Extends or truncates the current string.
	 * Same as the preceeding version, except that the filling
	 * character is forced to be set to the space character.
	 * @param iCharCountToReach
	 *   The number of characters to be assigned to the current string
	 */
	inline void Resize(int            iCharCountToReach)
	 {Resize(iCharCountToReach, &#x27; &#x27;, 1);}
     
	/**
	 * Replace the first occurence of the given substring by the
	 * other given substring.
	 * @param iLookedForString
	 *   The substring whose first occurence must be replaced
	 * @param iSubstitutionString
	 *   The string to substitute to the previous one
	 * @return 
	 *   Location of the input substring occurence.
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 
	 *   &lt;tt&gt;-1: Not found&lt;/tt&gt; 
	 *   &lt;tt&gt;Other: Location index, from 0 to the current CATString
	 *   length minus 1&lt;/tt&gt; 
	 */  
	int  ReplaceSubString(const CATUnicodeString &amp;iLookedForString, 
	                const CATUnicodeString &amp;iSubstitutionString);

	/**
	 * Modify the current CATUnicodeString, supressing a given part of it
	 * and putting instead a given replacement substring.
	 * @param iModificationStartingPosition
	 *   The modification starting position
	 * @param iModificationCharCount
	 *   The modification char count
	 * @param iReplacementString
	 *   The replacement string
	 */  
	void ReplaceSubString(int   iModificationStartingPosition,
	                  int   iModificationCharCount,
	                  const CATUnicodeString &amp;iReplacementString);

	/**
	 * Modify the current CATUnicodeString, supressing a given part of it
	 * and putting instead a given replacement substring.
	 * @param iModificationStartingPosition
	 *   The modification starting position
	 * @param iModificationCharCount
	 *   The modification char count
	 * @param iReplacementString
	 *   The replacement string
	 * @param iReplacementStringParametering
	 *   The replacement string parametering.
	 *   Enables to specify not to take the replacement string as is, 
	 *   but transformed first by a resizing action. 
	 *   This tuning specification is the character count of the
	 *   real CATUnicodeString that will be used for the substitution, 
	 *   i.e. the CATUnicodeString resized through the space filling
	 *   character. 
	 */  
	void ReplaceSubString(int   iModificationStartingPosition,
	               int   iModificationCharCount,
	               const CATUnicodeString &amp;iReplacementString, 
	               int   iReplacementStringParametering) ; 

	/**
	 * Modify the current CATUnicodeString, replacing all the occurences of the specified substring
	 * with another substring.
	 * @param iToReplace
	 * The substring to replace
	 * @param iReplacement
	 * The replacement substring
	 */
	 void ReplaceAll(
	   const CATUnicodeString&amp; iToReplace,
	   const CATUnicodeString&amp; iReplacement);

	/**
	 * Modify the current CATUnicodeString, supressing a given part 
	 * of it.
	 * @param iModificationStartingPosition
	 *   The modification starting position
	 * @param iModificationCharCount
	 *   The modification char count
	 */    
	void Remove(int iModificationStartingPosition, 
	           int iModificationCharCount=1) ;

	/**
	 * Modify the current CATUnicodeString, inserting a given 
	 * substring at the middle of it.
	 * @param iInsertionStartingPosition
	 *   The insertion starting position
	 * @param iStringToInsert
	 *   The string to insert into the current CATString
	 */   
	void Insert(int iInsertionStartingPosition, 
	           const CATUnicodeString &amp;iStringToInsert) ;

   //-----------------
   // String stripping
   //-----------------

	/** 
	 * Strip mode.
	 * &lt;b&gt;Role&lt;/b&gt;: Stripping is the process consisting
	 * of removing a given character occurences from a given
	 * string. Once the character specified , you can, as you want, 
	 * use one of the following options:
	 * @param CATStripModeLeading
	 *   Remove all the consecutive occurences of the  
	 *   character from the beginning of the string 
	 *   (of course it supposes that the first character of the 
	 *   string is the specified character, if it is not the case, 
	 *   nothing is done).
	 * @param CATStripModeTrailing
	 *   Remove all the consecutive occurences from the end
	 *   of the string (It means that the first 
	 *   character of the string is really the specified 
	 *   character).
	 * @param CATStripModeBoth
	 *   Remove all the consecutive occurences both from the 
	 *   beginning of the string and from the end (this option cumulates
	 *   the two preceeding options, it does not affects the 
	 *   intermediate consecutive occurences).
	 * @param CATStripModeAll
	 *   Removes all the occurences of the character
	 *   from the string. 
	 * &lt;p&gt;
	 * Warning : CATStripMode is also defined in CATInternalString.cpp
	 */
	enum CATStripMode {CATStripModeLeading =  0x1, 
	                  CATStripModeTrailing = 0x2, 
	                  CATStripModeBoth =     0x3, 
	                  CATStripModeAll =      0x4};

	/** 
	 * Returns a new stripped CATUnicodeString.
	 * &lt;b&gt;Role&lt;/b&gt;: Removes the specified character occurences from a 
	 * given string. Note that this method returns a new stripped string but does
	 * not modify the current CATUnicodeString.
	 * @param iMode
	 *   Option parameterizing the action.
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 
	 *   &lt;tt&gt;CATStripModeLeading&lt;/tt&gt; Removes all the consecutive 
	 *   occurences of the given character from the beginning of the 
	 *   given string (of course it supposes that the first character 
	 *   of the string is the delivered character, if it is not the 
	 *   case, nothing is done).
	 *   &lt;tt&gt;CATStripModeTrailing&lt;/tt&gt; Removes all the consecutive 
	 *   occurences of the given character from the end of the string 
	 *   (the same way, it means that the first character of the 
	 *   delivered string is really the delivered character).
	 *   &lt;tt&gt;CATStripModeBoth&lt;/tt&gt; Removes all the consecutive 
	 *   occurences of the given character both from the beginning 
	 *   of the string and from the end (this option cumulates the 
	 *   two preceeding options, it does not affects the intermediate 
	 *   consecutive occurences).
	 *   &lt;tt&gt;CATStripModeAll&lt;/tt&gt; Removes all the occurences of the 
	 *   given character from the string. 
	 * &lt;p&gt;
	 * @param iCharacter
	 *   The specified character whose occurences are to be removed
	 *   from the current CATUnicodeString.
	 */
	CATUnicodeString Strip(
	           CATUnicodeString::CATStripMode iMode, 
	           const CATUnicodeChar&amp; iCharacter) const;
 
	/** 
	 * Returns a new stripped CATUnicodeString.
	 * &lt;b&gt;Role&lt;/b&gt;: Removes the space character occurences from a 
	 * given string. Note that this method returns a new stripped string but does
	 * not modify the current CATUnicodeString.
	 * @param iMode
	 *   See above
	 */
	inline CATUnicodeString Strip(
	           CATUnicodeString::CATStripMode iMode) const
	 { return Strip(iMode, &#x27; &#x27;);}
   
	/** 
	 * Returns a new stripped CATUnicodeString.
	 * &lt;b&gt;Role&lt;/b&gt;: Removes the space character occurences from a 
	 * given string using the CATStripModeLeading mode (see above).
	 * Note that this method returns a new stripped string but does
	 * not modify the current CATUnicodeString.
	 */
	inline CATUnicodeString Strip() const
	 { return Strip(CATStripModeLeading, &#x27; &#x27;);}

   //----------------
   // String analysis
   //----------------

	/** 
	 * Get the length of the CATUnicodeString, as unicode char count.
	 * &lt;b&gt;Role&lt;/b&gt;: Get the length as unicode char count.
	 * This method returns the length of the string returned by @href #ConvertToUCChar.
	 * @return 
	 *   Character count.
	 */
	int GetLengthInChar() const;

	/** 
	 * Get the length of the CATUnicodeString, as byte count.
	 * &lt;b&gt;Role&lt;/b&gt;: Get the length as byte count.
	 * This method returns the length of the string returned by @href #ConvertToChar.
	 * @return 
	 *   Byte count.
	 */
	int GetLengthInByte() const;
   
	/** 
	 * Search mode.
	 * &lt;b&gt;Role&lt;/b&gt;: The search mode is the direction to which
	 * you search the specified substring in the current string.
	 * @param CATSearchModeForward
	 *   Starting from the specified current string character index,
	 *   the search will go forward to search the specified substring.
	 * @param CATSearchModeBackward
	 *   Starting from the specified current string character index,
	 *   the search will go backward to search the specified 
	 *   substring.
	 */
	enum CATSearchMode {CATSearchModeForward  = 0x1,  
	                   CATSearchModeBackward = 0x2}; 

	/**
	 * Search the first occurence of the specified substring in the 
	 * current string.
	 * &lt;b&gt;Role&lt;/b&gt;: Search the first occurence of the specified 
	 * substring in the current string, from a specified character 
	 * index, the search following the specified direction.
	 * @param iLookedForSubString
	 *   The character string to search for
	 * @param iSearchBeginning
	 *   The character index localizing the search beginning
	 * @param iSearchMode
	 *   Direction to which you search the specified substring in the 
	 *   current string.
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;CATSearchModeForward&lt;/tt&gt; if, 
	 *   starting from the specified current string character index,
	 *   the search will go forward to search the specified substring,
	 *   or &lt;tt&gt;CATSearchModeBackward&lt;/tt&gt; in the other direction.
	 *   Note that in CATSearchModeBackward mode, the &lt;tt&gt;
	 *   iSearchBeginning&lt;/tt&gt; index corresponds to a count of characters
	 *   from the end of the string, not the beginning. 
	 *   &lt;br&gt;For instance:
	 * &lt;pre&gt;
	 * CATUnicodeString s = &quot;012345678901test6789&quot;;
	 * s.SearchSubString(&quot;test&quot;, 4, CATUnicodeString::CATSearchModeBackward)) returns 12
	 * &lt;/pre&gt;
	 * whereas
	 * &lt;pre&gt;
	 * s.SearchSubString(&quot;test&quot;, 5, CATUnicodeString::CATSearchModeBackward)) returns -1
	 * &lt;/pre&gt;
	 * @return 
	 *   Location of the substring.
	 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: 
	 *   &lt;tt&gt;-1: Not found&lt;/tt&gt; 
	 *   &lt;tt&gt;Other: Location index, from 0 to the current CATString
	 *   length minus 1&lt;/tt&gt; 
	 * 
	 */
	int SearchSubString(const CATUnicodeString &amp;iLookedForSubString , 
	      int iSearchBeginning = 0,
	  CATUnicodeString::CATSearchMode iSearchMode = 
	      CATSearchModeForward) const ;

   //----------------------
   // Hash Table management
   //----------------------

	//  Returns a hashcode for this string.
	//  There is no garantee about unicity.
	/** @nodoc */
   unsigned ComputeHashKey() const; // The returned value can be used as an entry 
                                    // in hash tables provided by Collections
                                    // framework

	// Deprecated because of homogenization with the collection
	// terminology. The Append method should be used.
	/** @nodoc */
	CATUnicodeString &amp; operator += ( 
	      const CATUnicodeString &amp; iString );

	/**
	 * Character concatenation assignment operator.
	 * @param iChar
	 *   The character to append to the current string
	 * @return 
	 *   The class resulting from the concatenation
	 */
	CATUnicodeString &amp; operator += ( 
	      const CATUnicodeChar &amp; iChar );

	// Deprecated because of homogenization with the collections
	// terminology. The Append method should be used.
	/** @nodoc */
	CATUnicodeString operator + (
	      const CATUnicodeString &amp;iString) const ;

	/**
	 * String concatenation operator.
	 * &lt;br&gt;&lt;b&gt;CAUTION&lt;/b&gt;: The best way to manipulate strings is to use the Unicode encoding. The use of the 
	 * @href CATUnicodeString#Append method (const CATUnicodeString overriding version) is better than the use of the
	 * current operator.
	 * @param iString
	 *   The string to append to the current one
	 * @return 
	 *   The class resulting from the concatenation
	 */
	CATUnicodeString operator + (
	      const char *iString) const ;

	/**
	 * String concatenation operator.
	 * @param iCString
	 *   The char *
	 * @param iString
	 *   The CATUnicodeString string
	 * @return 
	 *   The CATUnicodeString resulting from the concatenation
	 */
	ExportedByNS0S3STR friend CATUnicodeString operator + (
	      const char* iCString, const CATUnicodeString&amp; iString);

	/** @nodoc */
	CATBoolean WildMatch(
				const CATUnicodeString&amp; iPattern, 
        const CATUnicodeChar&amp; iWildCardChar,
        const CATUnicodeChar&amp; iEscapeChar);

	//  Deprecated since the implicit use of the cast is too dangerous
	//  (very often the users don&#x27;t know how to use it)
	//
	// If the CATUnicodeString was created using the constructor from a &quot;const char* const&quot;, and the input char* was invalid
	// (i.e. it contained bytes which didn&#x27;t correspond to effective characters in the current locale), the current method
	// returns the same invalid char* that the one which was given to the constructor.
	//  For example, in a korean session, if the following char* was given to the constructor:
	//    0xB1 0x00 ,
	// (which does not correspond to an effective character in korean, since a 0xB1 byte requires another byte after to form
	// a character) the method will return:
	//    0xB1 0x00
	/** @nodoc */
	const char  *  CastToCharPtr() const; 

	// Deprecated since the GetLengthInChar can be used
	/** @nodoc */ 
	int IsNull() const;

	// Deprecated since the SearchSubString can be used
	/** @nodoc */
	int FindPosition(const CATUnicodeString &amp;iLookedForSubString, 
	                 int iSearchBeginning = 0) const ;

	//  Deprecated since the homogenization to the &quot;Build&quot; terminology
	/** @nodoc */
    int ConvertNumToString( int iIntegerValue, const char *iCFormat=&quot;%d&quot; );

	//  Deprecated since the homogenization to the &quot;Build&quot; terminology
	/** @nodoc */
	int ConvertNumToString( long iLongIntegerValue, 
                            const char *iCFormat=&quot;%d&quot; );

	//  Deprecated since the homogenization to the &quot;Build&quot; terminology
	/** @nodoc */
	int ConvertNumToString( unsigned long iUnsLongIntegerValue, 
                            const char *iCFormat=&quot;%u&quot;  );
	//  Deprecated since the homogenization to the &quot;Build&quot; terminology
	/** @nodoc */
	int ConvertNumToString( double iDoubleValue, 
                            const char *iCFormat=&quot;%g&quot; );
	//  Deprecated since the homogenization to the &quot;Build&quot; terminology
	/** @nodoc */
	int ConvertNumToString( long double iLongDoubleValue, 
                            const char *iCFormat=&quot;%Lg&quot;);
	// Deprecated 
	/** @nodoc */
	 int operator == ( const char *iString ) const ;
	// Deprecated 
	/** @nodoc */
	 int operator != ( const char *iString ) const ; 
	/** @nodoc */
	int Marshalling ( int ibd, int iinternalused);
	/** @nodoc */ 
	CATUnicodeString*  Unmarshalling (
	              int ibd, CATUnicodeString *istr, 
	              int iinternalused);
  
	/** @nodoc */ 
	static const CLSID &amp; ClassId();    
  
   private:

	CATInterUnicodeString  * _StringRef ;
	
	void _AllocNewRefString(
				int iCharLength, 
				CATBoolean iMakeCopy = FALSE, 
				CATBoolean iMakeDeepCopy = FALSE,
				CATBoolean iComputeBestLength = FALSE);
	
	void _UpdateCharView();
	
	void _BuildFromChar(const char* ipsz, int iLength = -1);

};

/**
 * Inline definitions.
 */
#if defined(DS_CXX11_SUPPORT_MOVE_SEMANTIC)
inline CATUnicodeString::CATUnicodeString(CATUnicodeString &amp;&amp;iRValue)
{
    _StringRef = iRValue._StringRef;
    iRValue._StringRef = NULL;
}
inline CATUnicodeString&amp; CATUnicodeString::operator=(CATUnicodeString &amp;&amp;iRValue)
{
    CATInterUnicodeString *l_pTmp = _StringRef;
    _StringRef = iRValue._StringRef;
    iRValue._StringRef = l_pTmp;
    return *this;
}
#endif  // DS_CXX11_SUPPORT_MOVE_SEMANTIC

#endif

</div>
    
    <div class="navigation">
        <div><a href="CATUnicodeChar.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATUnicodeChar.h</a></div>
        <div><a href="CATUuid.html">‰∏ã‰∏ÄÈ°µ: CATUuid.h ‚Üí</a></div>
    </div>
</body>
</html>