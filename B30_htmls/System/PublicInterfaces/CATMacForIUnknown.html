<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>System/PublicInterfaces/CATMacForIUnknown.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>System/PublicInterfaces/CATMacForIUnknown.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATListPV.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATListPV.h</a></div>
        <div><a href="CATMacForTie.html">‰∏ã‰∏ÄÈ°µ: CATMacForTie.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef __CATMacForIUnknown
#define __CATMacForIUnknown

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */

#include &lt;stdio.h&gt;
#include &quot;JS0CORBA.h&quot;
#include &quot;CATFillDictionary.h&quot;
#include &quot;CATMetaClass.h&quot;

#ifdef _WINDOWS_SOURCE
/**
 * @nodoc
 */
#define Exported __declspec(dllexport)
/**
 * @nodoc
 */
#define Imported __declspec(dllimport)
#else
/**
 * @nodoc
 */
#define Exported 
/**
 * @nodoc
 */
#define Imported 
#endif


#ifndef _MK_FWNAME_
/**
 * @nodoc
 */
#define CATLicenseOptionId NULL
#else
/**
 * @nodoc
 */
#define _guillemets_prec(arg) #arg
/**
 * @nodoc
 */
#define _guillemets(arg) _guillemets_prec(arg)
/**
 * @nodoc
 */
#define CATLicenseOptionId _guillemets(_MK_FWNAME_)
#endif


/**
 * @nodoc
 * internal macros used to create extensions
 */
#define MacCreateImplementation(Class)					\
return(NULL);
/**
 * @nodoc
 */
#define MacCreateDataExtension(Class)					\
return(new Class);
/**
 * @nodoc
 */
#define MacCreateCodeExtension(Class)					\
MacCreateDataExtension(Class)
/**
 * @nodoc
 */
#define MacCreateCacheExtension(Class)					\
MacCreateDataExtension(Class)
/**
 * @nodoc
 */
#define MacCreateTransientExtension(Class)					\
MacCreateDataExtension(Class)


/**
 * @nodoc
 */
ExportedByJS0CORBA CATBaseUnknown *QueryMacQI(const CATBaseUnknown*,const IID&amp;);

/**
 * @nodoc
 * Calls QueryInterface in a more concise form and checks that the returned
 * pointer is compatible with the requested interface.
 * @param interfac
 *   Interface name
 * @param object
 *   Pointer to the object or to the interface for which &lt;tt&gt;interfac&lt;/tt&gt;
 *   is requested
 * @return The pointer to the requested interface.
 */
#define CATMacQI(interfac,object)					\
((interfac *)QueryMacQI((const CATBaseUnknown *)((object)-&gt;GetImpl()),	\
   		        interfac::ClassId()))

/**
 * @nodoc
 * Returns the pointer to the implementation.
 * To be used only in an extension code.
 * @param impl
 *   Implementation class name
 */
#define CATMacGetImpl(impl)	((impl *)GetImpl())


/**
 * Macro used to declare a BOA.
 * &lt;b&gt;Role&lt;/b&gt;: Declares a class that implements an interface when this class
 * derives from the interface class. This is known as the basic
 * object adaptor (BOA). Use this macro in the source (.cpp) file
 * of the class that implements the interface.
 * @param interfac
 *   Interface name
 * @param extension
 *   Class name which implements the interface
 */
#define CATImplementBOA(interfac,extension)                             \
extern &quot;C&quot; Exported IUnknown *						\
		CreateBOA##interfac##extension(CATBaseUnknown *pt,	\
					       CATBaseUnknown *delegue)	\
{                                                                       \
   return(ToCreateBOA(pt,delegue,extension::MetaObject(),IID_##interfac,\
   		      extension::CreateItself));			\
}                                                                       \
                                                                        \
static CATFillDictionary Dico##interfac##extension			\
			(extension::MetaObject(),interfac::MetaObject(),\
			(void *)CreateBOA##interfac##extension)


/**
 * @nodoc
 * Declares an extension class.
 * &lt;b&gt;Role&lt;/b&gt;: Declares a class as an extension of an implementation class
 * @param extension
 *   Class name which implements the extension
 */
#define CATImplementExtension(extension)    	                        \
extern &quot;C&quot; Exported IUnknown *						\
		CreateEXT##extension(CATBaseUnknown *pt,		\
				     CATBaseUnknown *delegue)		\
{                                                                       \
   return(ToCreateBOA(pt,delegue,extension::MetaObject(),		\
   		      extension::ClassId(),extension::CreateItself));	\
}                                                                       \
                                                                        \
static CATFillDictionary DicoEXT##extension				\
		(extension::MetaObject(),extension::MetaObject(),	\
		(void *)CreateEXT##extension)


/**
 * Declares an implementation or extension class.
 * &lt;b&gt;Role&lt;/b&gt;: Declares that the current class is either
 * an implementation or an extension class.
 * The class must derive from @href CATBaseUnknown.
 * Use this macro in the class header file in conjunction with @href CATImplementClass
 * in the class source (.cpp) file.
 * End it with a semicolon.
 */
#define CATDeclareClass							\
									\
private :								\
   static CATMetaClass *meta_object;					\
public :								\
   virtual CATMetaClass *  __stdcall GetMetaObject() const;		\
   virtual const char *              IsA() const;			\
   virtual int                       IsAKindOf(const char *) const;	\
   static CATMetaClass *   __stdcall MetaObject();			\
   static const CLSID &amp;    __stdcall ClassId();				\
   static const char *     __stdcall ClassName();			\
   static CATBaseUnknown *CreateItself()


/**
 * @nodoc
 */
#define ToCreateMetaObject(Class,Typeofclass,Basemeta,Impmeta)		\
meta_object = fct_RetrieveMetaObject(#Class,Typeofclass,		\
				     Basemeta::MetaObject(),#Impmeta,CATLicenseOptionId,sizeof(Class))


/**
 * Begins an extension definition sequence.
 * &lt;b&gt;Role&lt;/b&gt;: Begins a macro sequence for &lt;tt&gt;Class&lt;/tt&gt; to declare that it implements
 * interfaces as an extension of the &lt;tt&gt;Impmeta&lt;/tt&gt; class.
 * Replaces the @href CATImplementClass macro when &lt;tt&gt;Class&lt;/tt&gt; extends several
 * implementation classes.
 * To be used in conjunction with the @href CATAddClassExtension macro to declare other
 * extended implementation classes and 
 * @href CATEndImplementClass macro to end the extension declaration sequence.
 * Use this macro in the &lt;tt&gt;Class&lt;/tt&gt; source (.cpp) file.
 * Do not end it with a semicolon.
 * @param Class
 *   The current extension class
 * @param Typeofclass
 *   The extension type
 *   &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: it can be set to &lt;tt&gt;DataExtension&lt;/tt&gt;,
 *   &lt;tt&gt;CodeExtension&lt;/tt&gt;, &lt;tt&gt;CacheExtension&lt;/tt&gt; or &lt;tt&gt;TransientExtension&lt;/tt&gt;
 * @param Basemeta
 *   The class from which &lt;tt&gt;Class&lt;/tt&gt; CNext-derives.
 *   &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;: must be set to @href CATBaseUnknown or &lt;tt&gt;CATNull&lt;/tt&gt;
 * @param Impmeta
 *   The implementation class for which &lt;tt&gt;Class&lt;/tt&gt; is an extension
 */
#define CATBeginImplementClass(Class,Typeofclass,Basemeta,Impmeta)	\
									\
CATMetaClass * __stdcall Class::GetMetaObject() const			\
{									\
   return(meta_object?meta_object:MetaObject());			\
}									\
									\
const CLSID &amp; __stdcall Class::ClassId()				\
{									\
   return(meta_object?meta_object-&gt;GetClassId():MetaObject()-&gt;GetClassId()); \
}									\
const char * __stdcall Class::ClassName()				\
{									\
   return(meta_object?meta_object-&gt;IsA():MetaObject()-&gt;IsA());		\
}									\
const char *Class::IsA() const						\
{									\
   return(meta_object?meta_object-&gt;IsA():MetaObject()-&gt;IsA());		\
}									\
int Class::IsAKindOf(const char *ident) const				\
{									\
   return(meta_object?meta_object-&gt;IsAKindOf(ident):MetaObject()-&gt;IsAKindOf(ident)); \
}									\
									\
CATBaseUnknown *Class::CreateItself()					\
{									\
   MacCreate##Typeofclass(Class)					\
}									\
									\
CATMetaClass * __stdcall Class::MetaObject()				\
{									\
   /* function that finds a meta-object */				\
   ExportedByJS0CORBA CATMetaClass *fct_FindMetaObject(const char *);	\
									\
   /* function that creates a meta-object */				\
   ExportedByJS0CORBA CATMetaClass *fct_RetrieveMetaObject(const char *,\
               TypeOfClass, CATMetaClass *, const char *, const char *,long);\
									\
   if (!meta_object)							\
   {									\
      ToCreateMetaObject(Class,Typeofclass,Basemeta,Impmeta)


/**
 * Ends an extension declaration sequence.
 * &lt;b&gt;Role&lt;/b&gt;: Ends the declaration sequence for the &lt;tt&gt;Class&lt;/tt&gt; class which implements
 * interfaces as an extension of several other implementation classes.
 * To be used in conjunction with @href CATBeginImplementClass macro to begin
 * the extension declaration sequence and
 * @href CATAddClassExtension macro to declare other
 * extended implementation classes.
 * Use this macro in the &lt;tt&gt;Class&lt;/tt&gt; source (.cpp) file.
 * Do not end it with a semicolon.
 * @param Class
 *   The current extension class
 */
#define CATEndImplementClass(Class)					\
   }									\
   return(meta_object);							\
}									\
									\
CATMetaClass *Class::meta_object = NULL


/**
 * Continues an extension declaration sequence.
 * &lt;b&gt;Role&lt;/b&gt;: Declares that the current class is an extension of the &lt;tt&gt;impl&lt;/tt&gt; class.
 * To be used in conjunction with the @href CATBeginImplementClass macro to begin
 * the extension declaration sequence and
 * @href CATEndImplementClass macro to end it.
 * Use this macro in the class source (.cpp) file.
 * Do not end it with a semicolon.
 * @param impl
 *   The implementation class for which the current class is an extension
 */
#define CATAddClassExtension(impl)					\
meta_object-&gt;SetExtensionOf(fct_FindMetaObject(#impl))


/**
 * Declares an implementation or extension class.
 * &lt;b&gt;Role&lt;/b&gt;: Declares that the current class is either
 * an implementation or an extension class.
 * The class must derive from CATBaseUnknown.
 * Use this macro in the class source (.cpp) file in conjunction with @href CATDeclareClass
 * in the class header file.
 * End it with a semicolon.
 * @param Class
 *   The name of the class
 * @param Typeofclass
 *   The class type.
 *   &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;: it can be set to &lt;tt&gt;Implementation&lt;/tt&gt;, &lt;tt&gt;DataExtension&lt;/tt&gt;,
 *   &lt;tt&gt;CodeExtension&lt;/tt&gt;, &lt;tt&gt;CacheExtension&lt;/tt&gt; or &lt;tt&gt;TransientExtension&lt;/tt&gt;
 * @param Basemeta
 *   The class from which &lt;tt&gt;Class&lt;/tt&gt; CNext-derives.
 *   &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;: it makes sense for implementation classes only.
 *   Set it to the name of the CNext base class for an implementation, and to
 *   @href CATBaseUnknown or &lt;tt&gt;CATNull&lt;/tt&gt; for the three extension types
 * @param Impmeta
 *   The class for which &lt;tt&gt;Class&lt;/tt&gt; is an extension.
 *   &lt;br&gt;&lt;b&gt;Legal values:&lt;/b&gt;: it makes sense for extension classes only.
 *   Set it to the implementation class name for the three extension types,
 *   and to &lt;tt&gt;CATNull&lt;/tt&gt; for an implementation
 */
#define CATImplementClass(Class,Typeofclass,Basemeta,Impmeta)		\
CATBeginImplementClass(Class,Typeofclass,Basemeta,Impmeta);		\
CATEndImplementClass(Class)


/**
 * @nodoc
 * Declares that the current class is a default extension that implements an
 * interface.
 * Use this macro in the source (.cpp) file of the class.
 * @param Class
 *   Name of the class that implements an interface
 * @param Typeofclass
 *   Type of the class: this type can be DataExtension,
 *   CodeExtension, CacheExtension or TransientExtension
 * @param Basemeta
 *   Class from which &lt;tt&gt;Class&lt;/tt&gt; derives
 * @param Impmeta
 *   Class from which &lt;tt&gt;Class&lt;/tt&gt; is an extension. Set it to &lt;tt&gt;CATNull&lt;/tt&gt;
 *   if this is not the case
 */
#define CATImplementDefault(Class,Typeofclass,Basemeta,Impmeta)		\
CATBeginImplementClass(Class,Typeofclass,Basemeta,Impmeta);		\
meta_object-&gt;SetDefault(1);						\
CATEndImplementClass(Class)


/**
 * @nodoc
 * Adds externally a supported implementation to a TIE extension
 * for a given interface.
 */
#define CATSupportImplementation(extension,impl,interf)			\
extern &quot;C&quot; Imported IUnknown *CreateTIE##interf##extension		\
		       (const CATBaseUnknown *, const CATBaseUnknown *);\
static CATFillDictionary _Dico##impl##extension##interf(		\
		extension::MetaObject(),				\
		interf::MetaObject(),#impl,				\
		(void *)CreateTIE##interf##extension)


/**
 * @nodoc
 * Adds externally a supported implementation to a BOA extension
 * for a given interface.
 */
#define CATSupportImplementationForBOA(extension,impl,interf)			\
extern &quot;C&quot; Imported IUnknown *CreateBOA##interf##extension(const CATBaseUnknown *, const CATBaseUnknown *); \
static CATFillDictionary _Dico##impl##extension##interf(		\
		extension::MetaObject(),				\
		interf::MetaObject(),#impl,				\
		(void *)CreateBOA##interf##extension)


/**
 * Declares an interface class.
 * &lt;b&gt;Role&lt;/b&gt;: Declares that the current class is an interface.
 * Use this macro in the class header file in conjunction with @href CATImplementInterface
 * in the class source (.cpp) file.
 * End it with a semicolon.
 */
#define CATDeclareInterface						\
									\
private :								\
   static CATMetaClass *meta_object;					\
public :                                                                \
   static CATMetaClass * __stdcall MetaObject();			\
   static const IID &amp;    __stdcall ClassId();				\
   static const char *   __stdcall ClassName()

/**
 * @nodoc
 */
#define CATBeginImplementInterface(Class, Basemeta, Alias)		\
									\
CATMetaClass * __stdcall Class::MetaObject()				\
{									\
   if (!meta_object)							\
   {									\
     meta_object = new CATMetaClass(&amp;IID_##Class,#Alias,		\
				     Basemeta::MetaObject(),NULL,	\
				     Interfaces)

/**
 * @nodoc
 */
#define CATEndImplementInterface(Class, Basemeta, Alias)		\
									\
     AddDictionary(&amp;IID_##Class,&amp;CLSID_CATMetaClass,			\
	  	   #Alias,&quot;MetaObject&quot;,NULL,(void *)meta_object);	\
     meta_object-&gt;SetFWname(CATLicenseOptionId);			\
   }									\
   return(meta_object);							\
}									\
									\
const IID &amp;  __stdcall Class::ClassId()					\
{									\
   return(meta_object?meta_object-&gt;GetClassId():MetaObject()-&gt;GetClassId()); \
}									\
const char * __stdcall Class::ClassName()				\
{									\
   return(meta_object?meta_object-&gt;IsA():MetaObject()-&gt;IsA());		\
}									\
									\
CATMetaClass *Class::meta_object = NULL;				\
									\
static CATFillDictionary DicoMeta##Class(IID_##Class,CLSID_CATMetaClass,\
						(void *)Class::MetaObject())


/**
 * Declares an interface class.
 * &lt;b&gt;Role&lt;/b&gt;: Declares that the current class is an interface class.
 * Use this macro in the class source (.cpp) file in conjunction with @href CATDeclareInterface.
 * in the class header file.
 * End it with a semicolon.
 * @param Class
 *   Interface class name
 * @param Basemeta
 *   Interface class from which &lt;tt&gt;Class&lt;/tt&gt; derives 
 */
#define CATImplementInterface(Class, Basemeta)				\
CATBeginImplementInterface(Class,Basemeta,Class);			\
CATEndImplementInterface(Class,Basemeta,Class)


/**
 * @nodoc
 * Declares that the current class is a licensed interface class.
 * Use this macro in the source (.cpp) file of the class.
 * @param Class
 *   Interface class name
 * @param Basemeta
 *   Interface class from which &lt;tt&gt;Class&lt;/tt&gt; derives 
 */
#define CATImplementLicensedInterface(Class, Basemeta)			\
CATBeginImplementInterface(Class,Basemeta,Class);			\
meta_object-&gt;SetAuth(0);						\
CATEndImplementInterface(Class,Basemeta,Class)


/**
 * @nodoc
 * Declares that the current class is an interface class.
 * Declares also an alias associated to the interface.
 * Use this macro in the source (.cpp) file of the class.
 * @param Class
 *   Interface class name
 * @param Basemeta
 *   Interface class from which &lt;tt&gt;Class&lt;/tt&gt; derives 
 * @param Alias
 *   Alias name of the interface
 */
#define CATImplementNamedInterface(Class, Basemeta, Alias)		\
CATBeginImplementInterface(Class,Basemeta,Class);			\
meta_object-&gt;SetAlias(#Alias);						\
CATEndImplementInterface(Class,Basemeta,Class)


/**
 * @nodoc
 * Declares that the current class is a licensed interface class.
 * Declares also an alias associated to the interface.
 * Use this macro in the source (.cpp) file of the class.
 * @param Class
 *   Interface class name
 * @param Basemeta
 *   Interface class from which &lt;tt&gt;Class&lt;/tt&gt; derives 
 * @param Alias
 *   Alias name of the interface
 */
#define CATImplementNamedLicensedInterface(Class, Basemeta, Alias)	\
CATBeginImplementInterface(Class,Basemeta,Class);			\
meta_object-&gt;SetAuth(0);						\
meta_object-&gt;SetAlias(#Alias);						\
CATEndImplementInterface(Class,Basemeta,Class)


/**
 * @nodoc
 * Declares a condition function which is run before creating the object instance
 * implementing an interface.
 * @param implementation
 *   Class  which implments &lt;tt&gt;interfac&lt;/tt&gt;
 * @param interfac
 *   Interface name
 * @param condition
 *   Condition function
 */
#define CATImplementCondition(implementation,interfac,condition)	\
									\
static CATFillDictionary DicoConditionFor##implementation##interfac	\
	  		(#implementation,#interfac,NULL,(void *)condition)


#ifdef _WINDOWS_SOURCE

/**
 * @nodoc
 */
#define CATDeclareAffect(interfac)					   \
									   \
interfac##_var &amp; __stdcall operator=(const CATBaseUnknown *base);
/**
 * @nodoc
 */
#define CATImplementAffect(interfac)					   \
									   \
interfac##_var &amp; __stdcall interfac##_var::operator=			   \
					(const CATBaseUnknown *base)	   \
{									   \
   CastTo((IUnknown *)base,IID_##interfac);			   	   \
   return(*this);							   \
}
/**
 * @nodoc
 */
#define CATImplementConv(interfac)					   \
return((interfac *)CATBaseUnknown_var::GetPointer());

#else

#if defined(_HPUX_SOURCE) || defined(_LINUX_SOURCE) || (defined(_AIX_SOURCE) &amp;&amp; (__xlC__ &gt;= 0x0500)) || (defined(_SUNOS_SOURCE) &amp;&amp; (defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &gt; 0x420)))
/**
 * @nodoc
 */
#define CATDeclareAffect(interfac)					   \
									   \
interfac##_var &amp; __stdcall operator=(const CATBaseUnknown *base);
#else
/**
 * @nodoc
 */
#define CATDeclareAffect(interfac)
#endif
/**
 * @nodoc
 */
#if defined(_HPUX_SOURCE) || defined(_LINUX_SOURCE) || (defined(_AIX_SOURCE) &amp;&amp; (__xlC__ &gt;= 0x0500)) || (defined(_SUNOS_SOURCE) &amp;&amp; (defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &gt; 0x420)))
/**
 * @nodoc
 */
#define CATImplementAffect(interfac)					   \
									   \
interfac##_var &amp; __stdcall interfac##_var::operator=			   \
					(const CATBaseUnknown *base)	   \
{									   \
   CastTo((IUnknown *)base,IID_##interfac);			   	   \
   return(*this);							   \
}
#else
/**
 * @nodoc
 */
#define CATImplementAffect(interfac)
#endif
/**
 * @nodoc
 */
#define CATImplementConv(interfac)					   \
return((interfac *)CATBaseUnknown_var::operator CATBaseUnknown *());

#endif

#if defined(_WINDOWS_SOURCE) || defined(_HPUX_SOURCE) || defined(_LINUX_SOURCE) || (defined(_AIX_SOURCE) &amp;&amp; (__xlC__ &gt;= 0x0500)) || (defined(_SUNOS_SOURCE) &amp;&amp; (defined(__SUNPRO_CC) &amp;&amp; (__SUNPRO_CC &gt; 0x420)))

/** @nodoc */
#define CATDeclareInlineAffect(interfac) \
inline interfac##_var &amp; __stdcall operator=(const CATBaseUnknown *base);

/** @nodoc */
#define CATImplementInlineAffect(interfac) \
inline interfac##_var &amp; __stdcall interfac##_var::operator=(const CATBaseUnknown *base) \
{ \
   __CastTo((IUnknown *)base); \
   return(*this); \
}

#else

/** @nodoc */
#define CATDeclareInlineAffect(interfac)
/** @nodoc */
#define CATImplementInlineAffect(interfac)

#endif

/**
 * Declares a handler.
 * &lt;b&gt;Role&lt;/b&gt;: Declares a handler, or smart pointer, for an interface,
 * in the interface header file.
 * @param interfac
 *   Interface name
 * @param baseclass
 *   Class from which the interface class derives.
 */
#define CATDeclareHandler(interfac,baseclass)                                                      \
                                                                                                   \
class interfac##_var : public baseclass##_var                                                      \
{                                                                                                  \
   private:                                                                                        \
      Exported void __stdcall __CastTo(IUnknown*pt);                                               \
   public:                                                                                         \
      inline interfac##_var();                                                                     \
      inline interfac##_var(CATBaseUnknown *base);                                                 \
      inline interfac##_var(interfac *base);                                                       \
      inline interfac##_var(const interfac##_var &amp;base);                                           \
      inline interfac##_var(const CATBaseUnknown_var &amp;base);                                       \
      inline interfac * __stdcall operator-&gt;() const;                                              \
      inline __stdcall operator interfac *() const;                                                \
      inline interfac##_var&amp; __stdcall operator=(const CATBaseUnknown_var &amp;base);                  \
      CATDeclareInlineAffect(interfac)                                                             \
};                                                                                                 \
                                                                                                   \
inline interfac##_var::interfac##_var():baseclass##_var()                                          \
{}                                                                                                 \
inline interfac##_var::interfac##_var(CATBaseUnknown *base) : baseclass##_var()                    \
{                                                                                                  \
    __CastTo(base);                                                                                \
}                                                                                                  \
inline interfac##_var::interfac##_var(interfac *base):baseclass##_var((baseclass *)base)           \
{}                                                                                                 \
inline interfac##_var::interfac##_var(const interfac##_var &amp;base):baseclass##_var((baseclass*)base) \
{                                                                                                  \
    __CastTo((CATBaseUnknown *)base);                                                              \
}                                                                                                  \
inline interfac##_var::interfac##_var(const CATBaseUnknown_var &amp;base): baseclass##_var()           \
{                                                                                                  \
    __CastTo((IUnknown *)base);                                                                    \
}                                                                                                  \
inline interfac * __stdcall interfac##_var::operator-&gt;() const                                     \
{                                                                                                  \
    return((interfac *)CATBaseUnknown_var::operator-&gt;());                                          \
}                                                                                                  \
inline __stdcall interfac##_var::operator interfac *() const                                       \
{                                                                                                  \
    CATImplementConv(interfac);                                                                    \
}                                                                                                  \
inline interfac##_var&amp; __stdcall interfac##_var::operator=(const CATBaseUnknown_var &amp;base)         \
{                                                                                                  \
    __CastTo((IUnknown *)base);                                                                    \
    return(*this);                                                                                 \
}                                                                                                  \
CATImplementInlineAffect(interfac)                                                                 \
                                                                                                   \
typedef interfac *interfac##_ptr

/**
 * Define a hanlder.
 * &lt;b&gt;Role&lt;/b&gt;: Declares a handler, or smart pointer, for an interface,
 * in the interface source (.cpp) file.
 * @param interfac
 *   Interface name
 * @param baseclass
 *   Class from which the interface class derives.
 */
#define CATImplementHandler(interfac,baseclass) \
	void interfac##_var::__CastTo(IUnknown*pt) \
	{ \
		CastTo(pt,IID_##interfac); \
	}; 


/**
 * @nodoc
 */
#define CATUuidOf(InterfaceName) IID_##InterfaceName

/**
 * @nodoc
 */
#define CATClassNameOf(InterfaceName) ClassName_##InterfaceName

/**
 * @nodoc
 */
#define CATMetaObjectOf(InterfaceName) MetaObject_##InterfaceName

/**
 * @nodoc
 * Declare an inlined IID.
 */
#define CATDefineIID(InterfaceName, BaseMeta, u1, u2, u3, u4, u5, u6, u7, u8, u9, u10, u11)     \
        extern &quot;C&quot; const IID CATUuidOf(InterfaceName) = { /*u1-u2-u3-u4-u5u6u7u8u9u10u11*/      \
                 u1,                                                                            \
                 u2,                                                                            \
                 u3,                                                                            \
                 {u4, u5, u6, u7, u8, u9, u10, u11}                                             \
        };                                                                                      \
	const char*   InterfaceName::CATClassNameOf(InterfaceName)  = #InterfaceName;           \
        CATMetaClass* InterfaceName::CATMetaObjectOf(InterfaceName) = NULL;                     \
	CATMetaClass* InterfaceName::RetrieveMetaObject(void) {                                 \
            CATMetaClass* CATGetInterfaceMetaClass(const IID&amp;, const char*, CATMetaClass*);    \
            return CATMetaObjectOf(InterfaceName) ? CATMetaObjectOf(InterfaceName) : (CATMetaObjectOf(InterfaceName) = CATGetInterfaceMetaClass(CATUuidOf(InterfaceName), #InterfaceName, BaseMeta::MetaObject())); \
        };


/**
 * @nodoc
 * Declare an interface class.
 */
#define CATDefineInterface(InterfaceName)                           \
    private:                                                        \
        static const char*   CATClassNameOf(InterfaceName);         \
        static CATMetaClass* CATMetaObjectOf(InterfaceName);        \
	static CATMetaClass* RetrieveMetaObject(void);              \
    public:                                                         \
        static inline CATMetaClass* __stdcall MetaObject() {        \
            /*return CATMetaObjectOf(InterfaceName);*/              \
			return RetrieveMetaObject();                \
        };                                                          \
        static inline const IID&amp; __stdcall ClassId(void) {          \
            /*extern &quot;C&quot; const IID CATUuidOf(InterfaceName);*/      \
            return CATUuidOf(InterfaceName);                        \
        };                                                          \
        static inline const char* __stdcall ClassName(void) {       \
            return InterfaceName::CATClassNameOf(InterfaceName);    \
        };              

/**
 * @nodoc
 * Declare a handler.
 */
#define	CATDefineHandler(Interface, Base)                                                    \
class Interface##_var :	public Base##_var {	                                             \
private:                                                                                     \
  inline void	__stdcall __CastTo(IUnknown*pt);                                             \
public:                                                                                      \
  inline Interface##_var();                                                                  \
  inline Interface##_var(CATBaseUnknown *base);                                              \
  inline Interface##_var(Interface *base);                                                   \
  inline Interface##_var(const Interface##_var &amp;base);                                       \
  inline Interface##_var(const CATBaseUnknown_var&amp; base);                                    \
  inline Interface* __stdcall	operator-&gt;() const;                                          \
  inline __stdcall operator Interface*() const;                                              \
  inline Interface##_var&amp;	__stdcall operator=(const CATBaseUnknown_var&amp; base);         \
  inline Interface##_var&amp; __stdcall operator=(const CATBaseUnknown *base);                   \
};                                                                                           \
                                                                                             \
inline void __stdcall Interface##_var::__CastTo(IUnknown*pt)                                 \
{                                                                                            \
  CastTo(pt, CATUuidOf(Interface));                                                          \
}                                                                                            \
inline Interface##_var::Interface##_var():Base##_var()                                       \
{}                                                                                           \
inline Interface##_var::Interface##_var(CATBaseUnknown *base):Base##_var()                   \
{                                                                                            \
  __CastTo(base);                                                                            \
}                                                                                            \
inline Interface##_var::Interface##_var(Interface *base):Base##_var((Base*) base)            \
{                                                                                            \
}                                                                                            \
inline Interface##_var::Interface##_var(const Interface##_var &amp;base):Base##_var((Base*) base)\
{                                                                                            \
  __CastTo((CATBaseUnknown*) base);                                                          \
}                                                                                            \
inline Interface##_var::Interface##_var(const CATBaseUnknown_var&amp; base):Base##_var()         \
{                                                                                            \
  __CastTo((IUnknown*) base);                                                                \
}                                                                                            \
inline Interface* __stdcall Interface##_var::operator-&gt;() const                              \
{                                                                                            \
  return (Interface*) CATBaseUnknown_var::operator-&gt;();                                      \
}                                                                                            \
inline __stdcall Interface##_var::operator Interface*() const                                \
{                                                                                            \
  return (Interface*) CATBaseUnknown_var::operator CATBaseUnknown*();                        \
}                                                                                            \
inline Interface##_var&amp;	__stdcall Interface##_var::operator=(const CATBaseUnknown_var&amp; base) \
{                                                                                            \
  __CastTo((IUnknown*) base); return (*this);                                                \
}                                                                                            \
inline Interface##_var&amp; __stdcall Interface##_var::operator=(const CATBaseUnknown *base)     \
{                                                                                            \
  __CastTo((IUnknown*) base); return(*this);                                                 \
}                                                                                            \
                                                                                             \
typedef	Interface *Interface##_ptr

#endif // __CATMacForIUnknown
</div>
    
    <div class="navigation">
        <div><a href="CATListPV.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATListPV.h</a></div>
        <div><a href="CATMacForTie.html">‰∏ã‰∏ÄÈ°µ: CATMacForTie.h ‚Üí</a></div>
    </div>
</body>
</html>