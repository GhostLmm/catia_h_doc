<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATSketcherUseItf/PublicInterfaces/IDMCurve2D.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CATSketcherUseItf/PublicInterfaces/IDMCurve2D.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="IDMCircle2D.html">‚Üê ‰∏ä‰∏ÄÈ°µ: IDMCircle2D.h</a></div>
        <div><a href="IDMEllipse2D.html">‰∏ã‰∏ÄÈ°µ: IDMEllipse2D.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">/* -*-c++-*- */
#ifndef IDMCurve2D_h
#define IDMCurve2D_h

// COPYRIGHT DASSAULT SYSTEMES 1999

/**
 * @CAA2Level L1
 * @CAA2Usage U3
 */

#include &quot;CATBaseUnknown.h&quot;
#include &quot;CATBooleanDef.h&quot;
#include &quot;CATSketcherUseItf.h&quot;

/**
 * OLE for Design and Modeling 2D Curve Definition.
 * &lt;b&gt;Role&lt;/b&gt;: This interface is the 2D counterpart of IDMCurve. It serves to
 * provide the Client with the information related to the geometric content of
 * the object that is applicable to 2D curves of all types. When this interface 
 * occurs on an EdgeUse object, all the arguments returned are within the 
 * context of the associated IDMEdgeUse, respectively (eg: the flow direction 
 * is that of the EdgeUse object).&lt;br&gt;
 * The curve may have discontinuities. In which case, an evaluation request at 
 * such locations on the curve may either yield a failure or, at best, an 
 * approximation of the requested quantity. For example -- a request to evaluate 
 * the curvature at a discontinuity may result in the Server returning a failure 
 * code. Whereas, a request to evaluate a tangent at a discontinuity may result 
 * in the Server returning an average of the &#x27;before&#x27; and &#x27;after&#x27; tangents at 
 * that point. This interface does not attempt to provide the detailed information 
 * at the discontinuity. This is left as the task of some other interface that may 
 * be supported by the object. However, this interface does provide sufficient 
 * information for a Client to learn that this curve may give problems that arise 
 * from such situations.
 */

#ifndef LOCAL_DEFINITION_FOR_IID
extern ExportedByCATSketcherUseItf IID IID_IDMCurve2D;
#else
extern &quot;C&quot; const IID IID_IDMCurve2D;
#endif

class ExportedByCATSketcherUseItf IDMCurve2D : public CATBaseUnknown
{
  CATDeclareInterface;

public:                                      

/**
 * There is a specific type associated with the curve geometry. This method 
 * returns the REFIID (GUID) of the interface that represents this type. The 
 * interfaces of the special types of the curve are defined elsewhere in this 
 * document. Examples of the type of curves are -- circle, ellipse, line, 
 * polyline, B-spline, etc. These specialized interfaces return the data that 
 * make up the underlying curve geometry.
 * It is possible that the Server decides not to expose it&#x27;s underlying specific 
 * type. This may largely be due to the fact that the type is undocumented and 
 * proprietary. In this case, IID_IUnknown may be returned. 
 * @param &lt;tt&gt;CATClassId &amp;pRefIID&lt;/tt&gt;
 * [out] Outputs the REFIID of the specific geometry interface. IID_IUnknown 
 * may be output if a REFIID equivalent to the underlying specific type does 
 * not exist.
 */
  virtual HRESULT GetCurveType (GUID *pRefIID) = 0;

/**
 * The range box (also known as bounding box) is axially-aligned within the local 
 * coordinate system of the Server. The range box returned bounds the curve.
 * @param &lt;tt&gt;double *pMinPoint&lt;/tt&gt;
 * [out] Outputs the minimum x,y point of the range box.
 * @param &lt;tt&gt;double *pMaxPoint&lt;/tt&gt;
 * [out] Outputs the maximum x,y point of the range box.
 */
  virtual HRESULT GetRangeBox (double *pMinPoint,double *pMaxPoint) = 0;

/**
 * This method returns the end-points of the curve. The start point and the end 
 * point are decided with  respect to the logical flow imposed on the curve by 
 * the object.
 * @param &lt;tt&gt;double *pStartPoint&lt;/tt&gt;
 * [out] Outputs the start point of the curve.
 * @param &lt;tt&gt;double *pEndPoint&lt;/tt&gt;
 * [out] Outputs the end point of the curve.
 */
  virtual HRESULT GetEndPoints (double *pStartPoint,double *pEndPoint) = 0;

/**
 * This method returns the parametric extents of the curve. This is the parametric 
 * equivalent of the end-points.
 * @param &lt;tt&gt;double *pStartParam&lt;/tt&gt;
 * [out] Outputs the parameter associated with the start point of the curve.
 * @param &lt;tt&gt;double *pEndParam&lt;/tt&gt;
 * [out] Outputs the parameter associated with the end point of the curve.
 */
  virtual HRESULT GetParamExtents (double *pStartParam,double *pEndParam) = 0;

/**
 * Given an array of 2D points lying near the curve, in the local coordinate system 
 * (X, Y) of the curve,  this method computes the parameter on the curve that 
 * corresponds to them. It also returns the maximum deviation from the ideal that 
 * this computation may have involved. This can be regarded as the tolerance that 
 * the Server used in calculating the parameter.
 * It is possible that there are more than one possible parameters for a given point
 * that satisfy this criterion or perhaps infinitely many (e.g.: if the centre of 
 * the circle is input). But this method will return just one such solution. A status 
 * indicator is output for each point evaluated, which tells the caller if there was 
 * any ambiguity. The caller should attempt to provide the input points ON or VERY 
 * NEAR the curve to prevent such ambiguity from arising.
 * The Client can provide initial guess parametric points, if these are known. This 
 * would speed up the computation in several cases. If such a guess is not known, the 
 * argument should be passed in as NULL. If the Client decides to provide a guess, it 
 * should do so for ALL the points or none at all.
 * @param &lt;tt&gt;ULONG nParams&lt;/tt&gt;
 * [in] Inputs the number of points to be evaluated.
 * @param &lt;tt&gt;double *pPoints&lt;/tt&gt;
 * [in] Inputs the array of 2D points lying close to the curve.
 * @param &lt;tt&gt;double *pGuessParams&lt;/tt&gt;
 * [in] Inputs array of parameters that are the initial guesses from the caller. Can be NULL if not
 * known. Array, if passed in, must correspond to the &lt;tt&gt;pPoints&lt;/tt&gt; array.
 * @param &lt;tt&gt;double *pMaxDeviations&lt;/tt&gt;
 * [out] Outputs the array of maximum deviation that has been allowed from the true point. Can be
 * &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array to be allocated by the caller to hold nPoints doubles.
 * @param &lt;tt&gt;double *pParams&lt;/tt&gt;
 * [out] Outputs the array of computed parameters. Array to be allocated by the caller to hold nPoints
 * parameters.
 * @param &lt;tt&gt;DWORD * pFlags&lt;/tt&gt;
 * [in] Outputs the array of computed parameters. Array to be allocated by the caller to hold &lt;tt&gt;nPoints&lt;/tt&gt;
 * parameters. Outputs the array of flags indicating if there was any ambiguity about the computation.
 * Can be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, if passed in, must be able to hold &lt;tt&gt;nPoints&lt;/tt&gt; &lt;tt&gt;DWORD&lt;/tt&gt;s.
 * Possible values of the flag are:
 * &lt;dl&gt;
 * &lt;dt&gt; &lt;tt&gt;0&lt;/tt&gt;    &lt;dd&gt; the parameter is unique.
 * &lt;dt&gt; &lt;tt&gt;1&lt;/tt&gt;    &lt;dd&gt; there are distinctly many solutions.
 * &lt;dt&gt; &lt;tt&gt;2&lt;/tt&gt;    &lt;dd&gt; there are infinitely many solutions.
 * &lt;/dl&gt;
 */
  virtual HRESULT GetParamAtPoint (ULONG nParams,double *pPoints,double *pGuessParams,double *pMaxDeviations,double *pParams,DWORD * pFlags) = 0;

/**
 * Given an array of parameters on the curve, this method computes the corresponding 2D 
 * space points (X, Y) in the curve&#x27;s local coordinate system.
 * @param &lt;tt&gt;ULONG nParams&lt;/tt&gt;
 * [in] Inputs the number of parameters to be evaluated.
 * @param &lt;tt&gt;double *pParams&lt;/tt&gt;
 * [in] Inputs the array of parameters to be evaluated.
 * @param &lt;tt&gt;double *pPoints&lt;/tt&gt;
 * [out] Outputs the array of computed 2D space points. Array must be able to hold &lt;tt&gt;nParams&lt;/tt&gt;
 * 2D points.
 */
  virtual HRESULT GetPointAtParam (ULONG nParams,double *pParams,double *pPoints) = 0;

/**
 * Given an array of parameter values on the curve, this method computes the unit-vector 
 * tangent at each of the points. The tangent is alway pointed in the direction of the 
 * logical flow of the curve. If no inherent logical flow can be assigned, the direction 
 * is the direction of increasing parameterization.
 * &lt;b&gt;NOTE:&lt;/b&gt;
 * If an input parameter lies at a discontinuity in the curve (eg: at the cusp-forming, 
 * multiple knot on a B-Spline curve), there may not be a unique tangent to output. The 
 * Server outputs an average tangent, rather than fail. The computation is the average of 
 * the unique &#x27;before&#x27; and &#x27;after&#x27; tangent at that point. &#x27;Before&#x27; being the limit of the 
 * tangent as one approaches the discontinuity and &#x27;after&#x27; being the limit as one departs 
 * it. See also the GetContinuity and GetPointAtParam methods of this interface -- these 
 * enable the client to learn more about curve continuity.
 * @param &lt;tt&gt;ULONG nParams&lt;/tt&gt;
 * [in] Inputs the number of parameters to be evaluated.
 * @param &lt;tt&gt;double * pParams&lt;/tt&gt;
 * [in] Inputs the array of parameters to be evaluated.
 * @param &lt;tt&gt;double * pTangents&lt;/tt&gt;
 * [out] Outputs the array of unit tangent vectors in the logical flow direction. 
 * Array to be allocated by the caller to hold nParams 2D vectors.
 */
  virtual HRESULT GetTangent (ULONG nParams,double *pParams,double *pTangents) = 0;

/**
 * Given an array of  parameters on the curve, this method computes the curvature of the 
 * curve at that point. It outputs the curvature direction as the unit-vector to the centre
 * of curvature. Curvature returned is always positive.&lt;br&gt;
 * &lt;b&gt;NOTE:&lt;/b&gt;
 * Curvature direction and value at a point on a curve are defined by the osculating circle 
 * that passes through the point. The osculating circle is the limit of circles that pass 
 * through the point and two points on the curve close to the given point.&lt;br&gt;
 * The curvature direction is the direction of the vector from the point to the centre of 
 * the osculating circle. The curvature direction is always orthogonal to the tangent. 
 * Radius of curvature is 1/curvature. The value of curvature can be 0, indicating an 
 * infinite radius of curvature (line).&lt;br&gt;
 * &lt;b&gt;NOTE:&lt;/b&gt;
 * If an input parametric point lies at a discontinuity in the curve (eg: at the cusp-forming, 
 * multiple knot-line on a B-Spline curve), the curvature is undefined and no approximations 
 * make sense. In this case, the method will fail. Even if one of the points to be evaluated 
 * fails, the method returns a failure code. See also the GetContinuity and GetPointAtParam 
 * methods of this interface -- these enable the Client to learn more about curve continuity.
 * @param &lt;tt&gt;ULONG nParams&lt;/tt&gt;
 * [in] Inputs the number of parameters to be evaluated.
 * @param &lt;tt&gt;double *pParams&lt;/tt&gt;
 * [in] Inputs the array of parameters at which to evaluate the curvatures.
 * @param &lt;tt&gt;double *pDirections&lt;/tt&gt;
 * [out] Outputs the array of unit vectors pointing toward the centre of curvature. Can 
 * be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, if passed in, must be able to hold nParams 2D vectors.
 * @param &lt;tt&gt;double *pCurvatures&lt;/tt&gt;
 * [out] Outputs the array of positive curvature values. The value returned may be 0, if 
 * the radius of curvature is infinite. Can be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, if passed in, must 
 * be allocated by the caller to hold nParams doubles.
 */
  virtual HRESULT GetCurvature (ULONG nParams,double *pParams,double *pDirections,double *pCurvatures) = 0;

/**
 * Given an array of parameters on the curve, this method evaluates the derivatives of the curve 
 * at these points. The derivatives upto the third order can be output. The caller can choose to 
 * not obtain any of the derivatives by simply specifying a &lt;tt&gt;NULL&lt;/tt&gt; in place of the corresponding 
 * output argument.&lt;br&gt;
 * The derivatives are computed with respect to the raw curve geometry and without regard to the 
 * logical direction imposed by, say, the EdgeUse or any object that supports this interface. A 
 * Client can thus choose to operate in the raw geometry mode if it so wishes. Information as to 
 * whether the parametric sense of this underlying curve is opposed to the logical sense is 
 * available from this object&#x27;s topology interface, if one exists, and can be applied at will to 
 * the resulting computations from this method. But Clients are encouraged to use the other methods 
 * of this interface that return &quot;sensed&quot; information directly, whenever applicable.&lt;br&gt;
 * &lt;b&gt;NOTE:&lt;/b&gt;
 * If an input parameter lies at a discontinuity in the curve (eg: at the cusp-forming, multiple 
 * knot-line on a B-Spline curve), some or all of the derivatives may be undefined and no 
 * approximations make sense in the semantics of this method. In this case, the method will fail. 
 * Even if one of the parameters fail to evaluate a requested output, the method returns a failure 
 * code. See also the GetContinuity and GetPointAtParam methods of this interface -- these enable 
 * the Client to learn more about curve continuity.
 * @param &lt;tt&gt;ULONG nParams&lt;/tt&gt;
 * [in] Inputs the number of parameters to be evaluated.
 * @param &lt;tt&gt;double *pParams&lt;/tt&gt;
 * [in] Inputs the array of parameters at which to evaluate the curve.
 * @param &lt;tt&gt;double *pFirstDerivs&lt;/tt&gt;
 * [out] Inputs the array of parameters at which to evaluate the curve. Outputs the array of first
 * derivatives. Can be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, if passed in, must be allocated by the caller
 * to hold &lt;tt&gt;nParams&lt;/tt&gt; 2D vectors.
 * @param &lt;tt&gt;double *pSecondDerivs&lt;/tt&gt;
 * [out] Outputs the array of second derivatives. Can be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, 
 * if passed in, must be allocated by the caller to hold &lt;tt&gt;nParams&lt;/tt&gt; 2D vectors.
 * @param &lt;tt&gt;double *pThirdDerivs&lt;/tt&gt;
 * [out] Outputs the array of third derivatives. Can be &lt;tt&gt;NULL&lt;/tt&gt; if not required. Array, 
 * if passed in, must be allocated by the caller to hold &lt;tt&gt;nParams&lt;/tt&gt; 2D vectors.
 */
  virtual HRESULT GetDerivatives (ULONG nParams,double *pParams,double *pFirstDerivs,double *pSecondDerivs,double *pThirdDerivs) = 0;

/**
 * This method outputs the parameter at a given length, measured along the curve,  starting from 
 * a given parameter. The direction of measurement is always in the direction of the logical flow 
 * of the curve. If no inherent logical flow can be assigned, the direction is the direction of 
 * increasing parameterization.&lt;br&gt;
 * If the input starting parameter is out of the bounds of the curve&#x27;s parametric range, the 
 * function &#x27;snaps&#x27; the value to the closest end point, before performing any computation. If the 
 * length being measured exceeds the bounds of the curve, the end point parameter is returned.
 * @param &lt;tt&gt;double FromParam&lt;/tt&gt;
 * [in] Inputs the parameter from which the Length needs to be measured.
 * @param &lt;tt&gt;double Length&lt;/tt&gt;
 * [out] Inputs the length of the curve to ne measured from pFromParam in the logical flow 
 * direction of the curve.
 * @param &lt;tt&gt;double *pParam&lt;/tt&gt;
 * [out] Outputs the computed parameter.
 */
  virtual HRESULT GetParamAtLength (double FromParam,double Length,double *pParam) = 0;

/**
 * This method outputs the length, measured along the curve,  from a given parameter to a given 
 * parameter.&lt;br&gt;
 * If either of the input parameters are out of the bounds of the curve&#x27;s parametric range, the 
 * function &#x27;snaps&#x27; the value to the closest end point, before performing the computation.
 * @param &lt;tt&gt;double FromParam&lt;/tt&gt;
 * [in] Inputs the parameter from which the length is to be measured.
 * @param &lt;tt&gt;double ToParam&lt;/tt&gt;
 * [in] Inputs the parameter to which the length is to be measured.
 * @param &lt;tt&gt;double *pLength&lt;/tt&gt;
 * [out] Outputs the length between the parameters.
 */
  virtual HRESULT GetLengthAtParam (double FromParam,double ToParam,double *pLength) = 0;

/**
 * This method returns the highest level of geometric continuity, the curve possesses. For example, 
 * if the curve is G1 continuous everywhere, but not G2 continuous at a specific location, this 
 * method returns the level as 1, indicating a G1 continuous curve.&lt;br&gt;
 * Typically, a curve will not bother to count itself as any higher than G3 continuous even if 
 * it is continuously differentiable beyond the 3rd derivative. Methods in this interface deal 
 * with derivatives only as high as the third. Moreover, if the Server cannot determine or finds 
 * it difficult to determine its true, highest continuity rating, it will return a lower level of 
 * which it is certain.
 * @param &lt;tt&gt;DWORD *nLevel&lt;/tt&gt;
 * [out] Outputs the maximum geometric continuity level, the Server can be certain this curve 
 * possesses.
 */
  virtual HRESULT GetContinuity (DWORD *nLevel) = 0;

/**
 * Typically, a curve&#x27;s parametric space can be expected to be finite. That is, there is a one-to-one,
 * unique mapping between a point in the parametric space to a point in the 2D space. But in several 
 * situations a Server might find it best to implement a curve with a parameter space that does not 
 * conform to this rule. Parametric spaces with periodicity is the case in point. This method returns 
 * information to the Client, indicating any such periodicity that might exist.&lt;br&gt;
 * In the case of curves that degenerate to a point, the entire parametric space maps to the same 
 * 2D point. Such a singularity, if it exists, is indicated by an output Boolean flag.
 * &lt;b&gt;NOTE:&lt;/b&gt;
 * A curve regarded as periodic will have the end-points of its primary parametric range, map to 
 * identical points in model space AND have the derivatives match up. The parameter space of such a 
 * curve can now be considered as infinite, formed by repeating the primary range, indefinitely. 
 * The length of the primary range is called the period of the curve. The curve continues to be 
 * defined for all values in this infinite space by reducing a given parameter modulo the period 
 * into this primary range. This method will return the period (0 if the parameter space is not 
 * periodic) and the origin of the primary periodic range (typically, 0).
 * HRESULT GetParamAnomaly (double pPeriodicity [2], boolean* pIsSingular)
 *   pPeriodicity	
 *   pIsSingular	Outputs TRUE if the parametric space is singular and the entire range maps to the 
 *               same point.
 * @param &lt;tt&gt;double *pPeriodicity&lt;/tt&gt;
 * [out] Outputs the period in the first element of the array, when the curve is periodic.
 * The value will be identically 0 if the curve is non-periodic. The second element contains the origin
 * of the primary periodic range.
 * @param &lt;tt&gt;boolean *pIsSingular&lt;/tt&gt;
 * [out] Outputs &lt;tt&gt;TRUE&lt;/tt&gt; if the parametric space is singular and the entire range maps to the 
 * same point.
 */
  virtual HRESULT GetParamAnomaly (double *pPeriodicity,boolean *pIsSingular) = 0;

/**
 * This method returns high-level geometric property information that characterizes this curve-based 
 * object. The DWORD returned consists of properties that this object exhibits. The properties are 
 * selected out of the &lt;tt&gt;enum DMCVGEOMETRYFORM&lt;/tt&gt;.
 * @param &lt;tt&gt;DWORD *pForm&lt;/tt&gt;
 * [out] Outputs the union of the properties the Client might encounter on the object. The 
 * properties are selected from the &lt;tt&gt;enum DMCVGEOMETRYFORM&lt;/tt&gt;.
 */
  virtual HRESULT GetGeometryForm (DWORD *pForm) = 0;

};

CATDeclareHandler(IDMCurve2D,CATBaseUnknown);

#endif
</div>
    
    <div class="navigation">
        <div><a href="IDMCircle2D.html">‚Üê ‰∏ä‰∏ÄÈ°µ: IDMCircle2D.h</a></div>
        <div><a href="IDMEllipse2D.html">‰∏ã‰∏ÄÈ°µ: IDMEllipse2D.h ‚Üí</a></div>
    </div>
</body>
</html>