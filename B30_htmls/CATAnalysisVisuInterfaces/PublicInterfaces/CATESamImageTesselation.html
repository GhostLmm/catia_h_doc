<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATAnalysisVisuInterfaces/PublicInterfaces/CATESamImageTesselation.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CATAnalysisVisuInterfaces/PublicInterfaces/CATESamImageTesselation.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATESamImageOwner.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATESamImageOwner.h</a></div>
        <div><a href="CATISPMProcess.html">‰∏ã‰∏ÄÈ°µ: CATISPMProcess.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATESamImageTesselation_h 
#define CATESamImageTesselation_h

//=============================================================================
// COPYRIGHT DASSAULT SYSTEMES 2002
//=============================================================================

/**
 * @CAA2Level L0 
 * @CAA2Usage U2 
 */

#include &quot;CATISamImageTesselation.h&quot;

// System prereqs
#include &quot;CATString.h&quot;
#include &quot;CATBoolean.h&quot;

// CATAnalysisVisuInterfaces prereqs
#include &quot;CATSamVisuImpl.h&quot;
struct CATSamElementVisuState;
class CATAnalysisExplicitTopology;

// AnalysisMeshingModel prereqs
#include &quot;CATIMSHConnectivity.h&quot;

// CATAnalysisBase prereqs
class CATAnalysisExplicitElement;
class CATAnalysisExplicitTopologyServices;

/**
 * Adapter for the implementation of CATISamImageTesselation interface.
 * @see CATISamImageTesselation
 */

class ExportedByCATSamVisuImpl CATESamImageTesselation : public CATISamImageTesselation
{
  public:
  
    /**
     * Default constructor.
     */
    CATESamImageTesselation();

    /**
     * Destructor.
     */
    virtual ~CATESamImageTesselation();    

    /**
     * Retrieves the nodes of elements.
     *
     * @param oNodesOfElementsPtr
     *   The start index for each element in oNodesOfElements.
     * @param oNodesOfElements
     *   The nodes number for each element.
     */
    HRESULT GetNodesOfElements(const int* &amp;oNodesOfElementsPtr, const int* &amp;oNodesOfElements);

    /**
     * Retrieves the nodes coordinates.
     *
     * @param oNodesCoordinates
     *   The coordinates of each nodes.
     */
    HRESULT GetNodesCoordinates(const float* &amp;oNodesCoordinates);

    /**
     * Retrieves the maximum sizes of the different kinds of data needed for visualization.
     * &lt;b&gt;Role&lt;/b&gt;: Retrieve the maximum sizes. These sizes are needed to dimension the
     * arrays that will later be filled by the @href #TesselateElement method.
     *
     * @param iElementNumber
     *   The internal number of the finite element to tesselate.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param oNbVertices
     *   The number of floats needed to store the coordinates of the vertices.
     * @param oNbEdges
     *   The number of vertice needed to represent the edges of the element.
     *   It should be a multiple of 2.
     * @param oNbTriangles
     *   The number of single triangles needed to represent the element.
     * @param oNbStripTriangles
     *   The number of triangle strips needed to represent the element.
     * @param oNbStripIndices
     *   The number of vertice of each triangle strip.
     * @param oNbFanTriangles
     *   The number of triangle fans needed to represent the element.
     * @param oNbFanIndices
     *   The number of vertice of each triangle fan.
     */
    virtual HRESULT GetTessSizes ( const int iElementNumber,
      const CATSamElementVisuState &amp; iFaceState ,
      int &amp; oNbVertices , int &amp; oNbEdgeIndices , int &amp; oNbTriangles ,
      int &amp; oNbStripTriangles , int &amp; oNbStripIndices ,
      int &amp; oNbFanTriangles , int &amp; oNbFanIndices );
  
    /**
     * Fills the tesselation arrays.
     *
     * @param iElementNumber
     *   The internal number of the finite element to tesselate.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param iTexture
     *   An array containing one value (between 0.f and 1.f) per node of the element. 
     *   If there is no value on the element, it is set to NULL pointer.
     * @param iTextureMode
     *   If set to TRUE, the values are local to the element (nodes on element values) else that are
     *   nodes on values.
     * @param ioVertices
     *   An array to be filled with the vertice coordinates: XYZXYZXYZ...
     * @param oVerticesArraySize
     *   The number of coordinates actually copied into the ioVertices array.
     * @param ioNormals
     *   An array to be filled with normals coordinates It is organized like &lt;tt&gt;iVertices&lt;/tt&gt; : one vertex has exactly
     *   one normal at the same field entry.
     * @param ioEdgeIndices
     *    Array used to store the edges vertices. Each field contains a
     *    vertex index, in the oVertices array.  As, we find, in the
     *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   ---------------
     *                  | ioEdgeIndices |
     *                   ---------------
     *                  |      i00      |   } first edge defined by the first
     *                  |      i01      |   } two indices
     *                  |       .       |
     *                  |       .       |
     *                  |       .       |   
     *                  |      in0      |   } last edge defined by the last
     *                  |      in1      |   } two indices.
     *                   ---------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the face j-th edge first vertex
     *    wich coordinates are X = oVertices[ij0], Y = oVertices[ij0 + 1] and Z = oVertices[ij0 + 2], and
     *    which normal coordinates are Nx = oNormals[ij0], Ny = oNormals[ij0 + 1] and Nz = oNormals[ij0 + 2].
     * @param oNbEdges
     *    The number of edge indices actually filled. Should be a multiple of two.
     * @param ioTriangleIndices
     *   This array is used to store the single triangles vertices. Each of its field represents
     *   a vertex index in the &lt;tt&gt;ioVertices&lt;/tt&gt; array.
     *   As we find, in the &lt;tt&gt;ioVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *   vertex, the indices used to designate the vertices are multiples of three.
     *   So, the first three indices of the &lt;tt&gt;ioTriangleIndices&lt;/tt&gt; array, are the three vertices indices
     *   of the first single triangle.
     *   &lt;pre&gt;
     *
     *                 ------------------       
     *                | ioTriangleIndices|
     *                 ------------------
     *                |       i00        |   }
     *                |       i01        |   } triangle 0 defined by index i00, i01 and i02
     *                |       i02        |   }
     *                |        .         |
     *                |        .         |
     *                |       ij0        |   }
     *                |       ij1        |   } triangle j defined by index ij0, ij1 and ij2. 
     *                |       ij2        |   }
     *                |        .         |
     *                |        .         |
     *                 ------------------
     *
     *   &lt;/pre&gt;
     *   For example, index ij0 enables access to the face j-th single triangle first vertex,
     *   which coordinates are X = iVertices[ij0], Y = iVertices[ij0 + 1] and Z = iVertices[ij0 + 2], and
     *   which normal has coordinates Nx = iNormals[ij0], Ny = iNormals[ij0 + 1] and Nz = iNormals[ij0 + 2].
     * @param oNbTriangles
     *    The number of single triangles actually filled.
     * @param ioTriangleStripIndices
     *    Array used to store the triangles strips vertices. Each field contains a
     *    vertex index, in the &lt;tt&gt;ioVertices&lt;/tt&gt; array.  As, we find, in the
     *    ioVertices array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   -----------------------
     *                  | ioTriangleStripIndices|
     *                   -----------------------
     *                  |          i00          |   }
     *                  |          i01          |   } first triangle strip defined
     *                  |           .           |   } by the first n1 indices
     *                  |           .           |   }
     *                  |          i0n1         |   }
     *                  |           .           |
     *                  |           .           |
     *                  |           .           |   
     *                  |          ij0          |   }
     *                  |          ij1          |   }
     *                  |           .           |   } triangle strip j
     *                  |           .           |   } with nj vertices
     *                  |          ijnj         |   }
     *                   -----------------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the j-th strip first vertex 
     *    wich coordinates are X = ioVertices[ij0], Y = ioVertices[ij0 + 1] and Z = ioVertices[ij0 + 2], and
     *    which normal coordinates are Nx = ioNormals[ij0], Ny = ioNormals[ij0 + 1] and Nz = ioNormals[ij0 + 2].
     * @param oNbTriangleStrips
     *    The number of triangles strips actually filled.
     * @param ioNbVerticesPerTriangleStrip
     *    Array containing the number of vertices for each triangle strip.
     *    The number of values of this array is equal to &lt;tt&gt;oNbTriangleStrip&lt;/tt&gt;. For example, the first strip
     *    is made with &lt;tt&gt;ioNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
     *    &lt;pre&gt;
     *                -----------------------------
     *               |ioNbVerticesPerTriangleStrip |
     *                -----------------------------
     *               |             n1              |
     *               |             .               |
     *               |             .               |   m = Number of triangle strips(oNbTriangleStrip)
     *               |             nm              |   nm = number of vertices of the m-th strip. (ioNbVertexPerTriangleStrip[m]
     *                -----------------------------    
     *
     *   &lt;/pre&gt;
     * @param ioTriangleFanIndices
     *    Array used to store the triangle fans vertices. Each field contains a
     *    vertex index, in the oVertices array.  As, we find, in the
     *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   ----------------------
     *                  | ioTriangleFanIndices |
     *                   ----------------------
     *                  |          i00         |   }
     *                  |          i01         |   } first triangle fan defined
     *                  |           .          |   } by the first n1 indices
     *                  |           .          |   }
     *                  |          i0n1        |   }
     *                  |           .          |
     *                  |           .          |
     *                  |           .          |   
     *                  |          ij0         |   }
     *                  |          ij1         |   }
     *                  |           .          |   } triangle fan j
     *                  |           .          |   } with nj vertices
     *                  |          ijnj        |   }
     *                   ----------------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the face j-th fan first vertex
     *    wich coordinates are X = oVertices[ij0], Y = oVertices[ij0 + 1] and Z = oVertices[ij0 + 2], and
     *    which normal coordinates are Nx = oNormals[ij0], Ny = oNormals[ij0 + 1] and Nz = oNormals[ij0 + 2].
     *    Each ij0, j in [0, jn], represents the j-th fan center.
     * @param oNbTriangleFans
     *    The number of triangle fans actually filled.
     * @param ioNbVerticesPerTriangleFan
     *    Array containing the number of vertices for each face triangles fan.
     *    The size of this array is equal to &lt;tt&gt;oNbTriangleFan&lt;/tt&gt;. For example, the first fan
     *    is made with &lt;tt&gt;ioNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
     *    &lt;pre&gt;
     *                -----------------------------
     *               | ioNbVerticesPerTriangleFan  |
     *                ----------------------------
     *               |             n1              |
     *               |             .               |
     *               |             .               |   m = Number of triangle fans(oNbTriangleFan)
     *               |             nm              |   nm = number of vertices of the m-th fan. (ioNbVertexPerTriangleFan[m]
     *                -----------------------------    
     *
     *   &lt;/pre&gt;
     */
    virtual HRESULT TesselateElement ( const int iElementNumber,
      const CATSamElementVisuState &amp; iFaceState ,
      const float *  iTexture , CATBoolean iTextureMode ,
      int * ioVertices ,  int &amp; ioVerticesArraySize, float * ioNormals ,
      int * ioEdgeIndices, int &amp; oNbEdges, 
      int * ioTriangleIndices, int &amp; oNbTriangles,
      int * ioTriangleStripIndices, int &amp; oNbTriangleStrips, int * ioNbVerticesPerTriangleStrip, 
      int * ioTriangleFanIndices, int &amp; oNbTriangleFans, int * ioNbVerticesPerTriangleFan );

    /**
     * Retrieves the maximum sizes of the different kinds of data needed for cutting visualization.
     * &lt;b&gt;Role&lt;/b&gt;: Retrieve the maximum sizes. These sizes are needed to dimension the
     * arrays that will later be filled by the @href #CutElement method.
     *
     * @param iElementNumber
     *   The internal number of the finite element to cut.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param iNodesDistToPlan
     *   The distance to the cutting plane for each node.
     * @param oNbVertices
     *   The number of floats needed to store the coordinates of the vertices.
     * @param oNbPoints
     *   The number of vertice needed to represent the points of the cut result.
     * @param oNbEdges
     *   The number of vertice needed to represent the edges of the cut result.
     *   It should be a multiple of 2.
     * @param oNbTriangles
     *   The number of single triangles needed to represent the cut result.
     * @param oNbFanTriangles
     *   The number of triangle fans needed to represent the cut result.
     * @param oNbFanIndices
     *   The number of vertice of each triangle fan.
     */
    virtual HRESULT GetCutSizes( const int iElementNumber,
      const float * iNodesDistToPlan,
      int &amp;oNbVertices, int &amp;oNbPoints , int &amp;oNbEdges , 
      int &amp;oNbTriangles, int &amp;oNbFanTriangles, int &amp;oNbFanIndices);
  
    /**
     * Fills the cut tesselation arrays.
     *
     * @param iElementNumber
     *   The internal number of the finite element to cut.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param iAnchorPoint
     *   The origin of the cutting plane.
     * @param iNormalDirection
     *   The normal direction of the cutting plane.
     * @param iNodesCoordinates
     *   The coordinates for all the nodes: XYZXYZXYZ...
     * @param iNodesDistToPlan
     *   The distance to the cutting plane for each node.
     */
    virtual HRESULT CutElement( const int iElementNumber,
      const CATString&amp; iPosition, const int iNbPositions, const int * iPositions, 
      const float iAnchorPoint[3], const float iNormalDirection[3],
      const float * iNodesCoordinates, const float * iNodesDistToPlan,
      const float * iTexture, CATBoolean iTextureMode,
      float * ioVertices, float * ioVerticesTexture, int &amp; ioVerticesArraySize,
      int * ioPointIndices , int &amp; oNbPoints , 
      int * ioEdgeIndices, int &amp; oNbEdges, 
      int * ioTriangleIndices, int &amp; oNbTriangles,
      int * ioTriangleFanIndices, int &amp; oNbTriangleFans, int * ioNbVerticesPerTriangleFan );

    /**
     * @nodoc .
     */ 
    HRESULT Init ();

    /**
     * @nodoc .
     */ 
    void Dispose ();

    /**
     * @nodoc .
     */ 
    virtual void GetEdgesDiscretisation(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float DeformCoeff,
            float *&amp;Edges, int &amp;NbEdgePoints);

    /**
     * @nodoc .
     */ 
    virtual void GetNodesDiscretisation(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float DeformCoeff,
            int &amp;NbNodes, int *&amp;NodesNumber, float *&amp;Coordinates, int AbsoluteOrRelative=0);

    /**
     * @nodoc .
     */ 
    virtual void GetCenterOfFace ( int FaceNumber, const int *NodesOfElement,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float *CenterCoordinates, float *CenterDisplacement);

    /**
     * @nodoc .
     */ 
    virtual void GetCenterOfEdge ( int EdgeNumber , const int * NodesOfElement ,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float *CenterCoordinates, float *CenterDisplacement);

    /**
     * @nodoc .
     */ 
    virtual HRESULT GetNormalOfFace ( int FaceNumber , const int *NodesOfElement,
            int NbNodesOfElement, const float *NodesCoordinates,
            float *Normal);

    /**
     * @nodoc .
     */ 
    virtual void GetNormalOfEdge ( int EdgeNumber , const int * NodesOfElement ,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * Normal );

    /**
     * @nodoc .
     */ 
    virtual char GetVisualizationState(const CATSamElementVisuState &amp;FaceState);

    /**
     * @nodoc .
     */ 
    virtual void GetVisualizedNodes(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement,
            int *ShownNodes, int &amp;NbShownNodes, int AbsoluteOrRelative=0);

    /**
     * @nodoc .
     */ 
    virtual void ComputePosition( const int *NodesOfElement, int NbNodesOfElement,
            const float *NodesCoordinates, float * const NodesDisplacement,
            int NbPositions, float * const UVW,
            float *XYZPositions, float *XYZDisplacements);

    /**
     * @nodoc .
     */ 
    HRESULT SetWorkingTopology (const CATAnalysisExplicitTopology* iTopology);

    /**
     * @nodoc .
     */ 
    HRESULT ResetWorkingTopology ( );
  
  protected:
    
    /**
     * Constructors. No implementation provided. Just declared to avoid that 
     * someone could build this class.
     */
    CATESamImageTesselation (const CATESamImageTesselation &amp;);
    CATESamImageTesselation &amp; operator = (const CATESamImageTesselation &amp;);

    /**
     * @nodoc .
     */ 
    static HRESULT ComputeSection (const CATString&amp; iPosition, const int iNbPositions, const int * iPositions, 
      const int *iNodesOfElement, const int iNbNodesOfElement,
      const int *iNodesOfFaces, const int * iPtNodesOfFaces,
      const float iAnchorPoint[3], const float iNormalDirection[3],
      const float * iNodesCoordinates, const float * iNodesDistToPlan,
      const float * iTexture, int iTextureMode,
      const int *iNodesOfEdges, const int * iPtNodesOfEdges,
      const int *iNodesOfEdgesSegments, const int iNbNodesOfEdgesSegments,
      float * ioVertices, float * ioVerticesTexture, int &amp;ioVerticesArraySize,
      int &amp;ioNbPoints , int * ioPointIndices,
      int &amp;ioNbEdges , int * ioEdgeIndices , 
      int &amp;ioNbTriangles, int * ioTriangleIndices,
      int &amp;ioNbFanTriangles, int * ioTriangleFanIndices, int * ioNbVertexPerTriangleFan);
    
    /**
     * @nodoc .
     */ 
    inline static short CATSamSign ( float x , float eps )
    {
      return ( x &gt; eps ) ? 1 : ( ( x &lt; -eps ) ? -1 : 0 );
    }

    /**
     * @nodoc .
     */ 
    inline CATIMSHConnectivity * GetMSHConnectivity()
    {
      if ( !_MSHConnectivity )
      {
        CATBaseUnknown * impl = GetImpl();
        if ( !impl ) return NULL;
        
        impl -&gt; QueryInterface ( CATIMSHConnectivity::ClassId (), (void **) &amp;_MSHConnectivity );
      }
      return _MSHConnectivity;
    }


    short  _Dim;
    int    _NbNodes;
    int    _NbEdges;
    int    _NbFaces;
    
    short  _VisuMask;
    short  _VisuEdgeMask;
    
    const int * _PtNodesOfFaces;
    const int * _NodesOfFaces;
    const int * _PtNodesOfEdges;
    const int * _NodesOfEdges;
    const int * _PtEdgesOfFaces;
    const int * _EdgesOfFaces;
    const int * _OrientOfEdges;
    
    const int   * _NodesOfElementsPtr;
    const int   * _NodesOfElements;
    const float * _NodesCoordinates;

    int *  _NodesOfEdgesSegments;
    int    _NbNodesOfEdgesSegments;
    
    int *  _NbEdgesNodesForFacesState;
    int *  _EdgesNodesForFacesState;
    int ** _PtOnEdgesNodesForFacesState;
    
    int *  _NbNodesForFacesState;
    int *  _NodesForFacesState;
    int ** _PtOnNodesForFacesState;

  private:

    CATBoolean            _InitDone; 

    CATAnalysisExplicitTopologyServices * _ExplicitTopologyServices;
    CATIMSHConnectivity * _MSHConnectivity;    
};
#endif
</div>
    
    <div class="navigation">
        <div><a href="CATESamImageOwner.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATESamImageOwner.h</a></div>
        <div><a href="CATISPMProcess.html">‰∏ã‰∏ÄÈ°µ: CATISPMProcess.h ‚Üí</a></div>
    </div>
</body>
</html>