<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CATAnalysisVisuInterfaces/PublicInterfaces/CATISamImageTesselation.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>CATAnalysisVisuInterfaces/PublicInterfaces/CATISamImageTesselation.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATISamImageSelectedEntity.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATISamImageSelectedEntity.h</a></div>
        <div><a href="CATISamLayoutOperator.html">‰∏ã‰∏ÄÈ°µ: CATISamLayoutOperator.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATISamImageTesselation_H
#define CATISamImageTesselation_H

//=============================================================================
// COPYRIGHT DASSAULT SYSTEMES 2002
//=============================================================================

/**
* @CAA2Level L0
* @CAA2Usage U4 CATESamImageTesselation
*/

#include &quot;CATBaseUnknown.h&quot;

#include &quot;CATBooleanDef.h&quot;
#include &quot;CATString.h&quot;
struct CATSamElementVisuState;
class CATAnalysisExplicitTopology;

/** @nodoc */
#define CATSamElementFacesState CATSamElementVisuState

#include &quot;CATSamVisuUUID.h&quot;

extern &quot;C&quot; const IID IID_CATISamImageTesselation;

/**
 * Interface providing a finite element tesselation for results and section visualization.
 *
 * &lt;b&gt;Role&lt;/b&gt;: This interface provides all necessary tesselation
 * data to produce a three dimensional view of a finite element.
 * The tesselation data is also used by the interference checker.
 * &lt;p&gt;
 * Basically the visualization is built in two passes: the first one
 * collects sizes used to dimension arrays that are filled in the
 * second pass.
 * &lt;p&gt;&lt;b&gt;BOA information&lt;/b&gt;: this interface can be implemented
 * using the BOA (Basic Object Adapter).
 * To know more about the BOA, refer to the CAA Encyclopedia home page. 
 * Click Middleware at the bottom left, then click the Object Modeler tab page.
 * Several articles deal with the BOA.&lt;/p&gt;
 */

class ExportedByCATSamVisuUUID CATISamImageTesselation : public CATBaseUnknown
{
    CATDeclareInterface;
  
  public :

    /**
     * Retrieves the maximum sizes of the different kinds of data needed for visualization.
     * &lt;b&gt;Role&lt;/b&gt;: Retrieve the maximum sizes. These sizes are needed to dimension the
     * arrays that will later be filled by the @href #TesselateElement method.
     *
     * @param iElementnumber
     *   The internal number of the finite element to tesselate.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param oNbVertices
     *   The number of floats needed to store the coordinates of the vertices.
     * @param oNbEdges
     *   The number of vertice needed to represent the edges of the element.
     *   It should be a multiple of 2.
     * @param oNbTriangles
     *   The number of single triangles needed to represent the element.
     * @param oNbStripTriangles
     *   The number of triangle strips needed to represent the element.
     * @param oNbStripIndices
     *   The number of vertice of each triangle strip.
     * @param oNbFanTriangles
     *   The number of triangle fans needed to represent the element.
     * @param oNbFanIndices
     *   The number of vertice of each triangle fan.
     */
    virtual HRESULT GetTessSizes ( const int iElementNumber,
      const CATSamElementVisuState &amp; iFaceState ,
      int &amp; oNbVertices , int &amp; oNbEdges , int &amp; oNbTriangles ,
      int &amp; oNbStripTriangles , int &amp; oNbStripIndices ,
      int &amp; oNbFanTriangles , int &amp; oNbFanIndices ) = 0;

    /**
     * Fills the tesselation arrays.
     *
     * @param iElementNumber
     *   The internal number of the finite element to tesselate.
     * @param iFaceState
     *   Visualization status for each face of the element.
     * @param iTexture
     *   An array containing one value (between 0.f and 1.f) per node of the element. 
     *   If there is no value on the element, it is set to NULL pointer.
     * @param iTextureMode
     *   If set to TRUE, the values are local to the element (nodes on element values) else that are
     *   nodes on values.
     * @param ioVertices
     *   An array to be filled with the vertice coordinates: XYZXYZXYZ...
     * @param oVerticesArraySize
     *   The number of coordinates actually copied into the ioVertices array.
     * @param ioNormals
     *   An array to be filled with normals coordinates It is organized like &lt;tt&gt;iVertices&lt;/tt&gt; : one vertex has exactly
     *   one normal at the same field entry.
     * @param ioEdgeIndices
     *    Array used to store the edges vertices. Each field contains a
     *    vertex index, in the oVertices array.  As, we find, in the
     *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   ---------------
     *                  | ioEdgeIndices |
     *                   ---------------
     *                  |      i00      |   } first edge defined by the first
     *                  |      i01      |   } two indices
     *                  |       .       |
     *                  |       .       |
     *                  |       .       |   
     *                  |      in0      |   } last edge defined by the last
     *                  |      in1      |   } two indices.
     *                   ---------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the face j-th edge first vertex
     *    wich coordinates are X = oVertices[ij0], Y = oVertices[ij0 + 1] and Z = oVertices[ij0 + 2], and
     *    which normal coordinates are Nx = oNormals[ij0], Ny = oNormals[ij0 + 1] and Nz = oNormals[ij0 + 2].
     * @param oNbEdges
     *    The number of edge indices actually filled. Should be a multiple of two.
     * @param ioTriangleIndices
     *   This array is used to store the single triangles vertices. Each of its field represents
     *   a vertex index in the &lt;tt&gt;ioVertices&lt;/tt&gt; array.
     *   As we find, in the &lt;tt&gt;ioVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *   vertex, the indices used to designate the vertices are multiples of three.
     *   So, the first three indices of the &lt;tt&gt;ioTriangleIndices&lt;/tt&gt; array, are the three vertices indices
     *   of the first single triangle.
     *   &lt;pre&gt;
     *
     *                 ------------------       
     *                | ioTriangleIndices|
     *                 ------------------
     *                |       i00        |   }
     *                |       i01        |   } triangle 0 defined by index i00, i01 and i02
     *                |       i02        |   }
     *                |        .         |
     *                |        .         |
     *                |       ij0        |   }
     *                |       ij1        |   } triangle j defined by index ij0, ij1 and ij2. 
     *                |       ij2        |   }
     *                |        .         |
     *                |        .         |
     *                 ------------------
     *
     *   &lt;/pre&gt;
     *   For example, index ij0 enables access to the face j-th single triangle first vertex,
     *   which coordinates are X = iVertices[ij0], Y = iVertices[ij0 + 1] and Z = iVertices[ij0 + 2], and
     *   which normal has coordinates Nx = iNormals[ij0], Ny = iNormals[ij0 + 1] and Nz = iNormals[ij0 + 2].
     * @param oNbTriangles
     *    The number of single triangles actually filled.
     * @param ioTriangleStripIndices
     *    Array used to store the triangles strips vertices. Each field contains a
     *    vertex index, in the &lt;tt&gt;ioVertices&lt;/tt&gt; array.  As, we find, in the
     *    ioVertices array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   -----------------------
     *                  | ioTriangleStripIndices|
     *                   -----------------------
     *                  |          i00          |   }
     *                  |          i01          |   } first triangle strip defined
     *                  |           .           |   } by the first n1 indices
     *                  |           .           |   }
     *                  |          i0n1         |   }
     *                  |           .           |
     *                  |           .           |
     *                  |           .           |   
     *                  |          ij0          |   }
     *                  |          ij1          |   }
     *                  |           .           |   } triangle strip j
     *                  |           .           |   } with nj vertices
     *                  |          ijnj         |   }
     *                   -----------------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the j-th strip first vertex 
     *    wich coordinates are X = ioVertices[ij0], Y = ioVertices[ij0 + 1] and Z = ioVertices[ij0 + 2], and
     *    which normal coordinates are Nx = ioNormals[ij0], Ny = ioNormals[ij0 + 1] and Nz = ioNormals[ij0 + 2].
     * @param oNbTriangleStrips
     *    The number of triangles strips actually filled.
     * @param ioNbVerticesPerTriangleStrip
     *    Array containing the number of vertices for each triangle strip.
     *    The number of values of this array is equal to &lt;tt&gt;oNbTriangleStrip&lt;/tt&gt;. For example, the first strip
     *    is made with &lt;tt&gt;ioNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
     *    &lt;pre&gt;
     *                -----------------------------
     *               |ioNbVerticesPerTriangleStrip |
     *                -----------------------------
     *               |             n1              |
     *               |             .               |
     *               |             .               |   m = Number of triangle strips(oNbTriangleStrip)
     *               |             nm              |   nm = number of vertices of the m-th strip. (ioNbVertexPerTriangleStrip[m]
     *                -----------------------------    
     *
     *   &lt;/pre&gt;
     * @param ioTriangleFanIndices
     *    Array used to store the triangle fans vertices. Each field contains a
     *    vertex index, in the oVertices array.  As, we find, in the
     *    &lt;tt&gt;oVertices&lt;/tt&gt; array, the XYZ coordinates for each
     *    vertex, the indices used to designate the vertices are multiples of three.
     *    &lt;pre&gt;
     *
     *
     *                   ----------------------
     *                  | ioTriangleFanIndices |
     *                   ----------------------
     *                  |          i00         |   }
     *                  |          i01         |   } first triangle fan defined
     *                  |           .          |   } by the first n1 indices
     *                  |           .          |   }
     *                  |          i0n1        |   }
     *                  |           .          |
     *                  |           .          |
     *                  |           .          |   
     *                  |          ij0         |   }
     *                  |          ij1         |   }
     *                  |           .          |   } triangle fan j
     *                  |           .          |   } with nj vertices
     *                  |          ijnj        |   }
     *                   ----------------------
     *
     *
     *    &lt;/pre&gt; 
     *    For example, index ij0 allows to access to the face j-th fan first vertex
     *    wich coordinates are X = oVertices[ij0], Y = oVertices[ij0 + 1] and Z = oVertices[ij0 + 2], and
     *    which normal coordinates are Nx = oNormals[ij0], Ny = oNormals[ij0 + 1] and Nz = oNormals[ij0 + 2].
     *    Each ij0, j in [0, jn], represents the j-th fan center.
     * @param oNbTriangleFans
     *    The number of triangle fans actually filled.
     * @param ioNbVerticesPerTriangleFan
     *    Array containing the number of vertices for each face triangles fan.
     *    The size of this array is equal to &lt;tt&gt;oNbTriangleFan&lt;/tt&gt;. For example, the first fan
     *    is made with &lt;tt&gt;ioNbVertexPerTriangleStrip[0]&lt;/tt&gt; vertices.
     *    &lt;pre&gt;
     *                -----------------------------
     *               | ioNbVerticesPerTriangleFan  |
     *                ----------------------------
     *               |             n1              |
     *               |             .               |
     *               |             .               |   m = Number of triangle fans(oNbTriangleFan)
     *               |             nm              |   nm = number of vertices of the m-th fan. (ioNbVertexPerTriangleFan[m]
     *                -----------------------------    
     *
     *   &lt;/pre&gt;
     */
    virtual HRESULT TesselateElement ( const int iElementNumber,
      const CATSamElementVisuState &amp; iFaceState ,
      const float *  iTexture , CATBoolean iTextureMode ,
      int * ioVertices ,  int &amp; ioVerticesArraySize, float * ioNormals ,
      int * ioEdgeIndices, int &amp; oNbEdges, 
      int * ioTriangleIndices, int &amp; oNbTriangles,
      int * ioTriangleStripIndices, int &amp; oNbTriangleStrips, int * ioNbVerticesPerTriangleStrip, 
      int * ioTriangleFanIndices, int &amp; oNbTriangleFans, int * ioNbVerticesPerTriangleFan ) = 0;

    /**
     * Retrieves the maximum sizes of the different kinds of data needed for cutting visualization.
     * &lt;b&gt;Role&lt;/b&gt;: Retrieve the maximum sizes. These sizes are needed to dimension the
     * arrays that will later be filled by the @href #CutElement method.
     *
     * @param iElementNumber
     *   The internal number of the finite element to cut.
     * @param iNodesDistToPlan
     *   The distance to the cutting plane for each node.
     * @param oNbVertices
     *   The number of floats needed to store the coordinates of the vertices.
     * @param oNbPoints
     *   The number of vertice needed to represent the points of the cut result.
     * @param oNbEdges
     *   The number of vertice needed to represent the edges of the cut result.
     *   It should be a multiple of 2.
     * @param oNbTriangles
     *   The number of single triangles needed to represent the cut result.
     * @param oNbFanTriangles
     *   The number of triangle fans needed to represent the cut result.
     * @param oNbFanIndices
     *   The number of vertice of each triangle fan.
     */
    virtual HRESULT GetCutSizes ( const int iElementNumber,
      const float * iNodesDistToPlan, 
      int &amp;oNbVertices, int &amp;oNbPoints, int &amp;oNbEdges , 
      int &amp;oNbTriangles, int &amp;oNbFanTriangles, int &amp;oNbFanIndices) = 0;
  
    /**
     * Fills the cut tesselation arrays.
     *
     * @param iElementNumber
     *   The internal number of the finite element to cut.
     * @param iPosition
     *   The position in the element
     * @param iNbPositions
     *   The number of Positions.
     * @param iPositions
     *   A pointer to the Positions List.
     * @param iAnchorPoint
     *   The origin of the cutting plane.
     * @param iNormalDirection
     *   The normal direction of the cutting plane.
     * @param iNodesCoordinates
     *   The coordinates for all the nodes: XYZXYZXYZ...
     * @param iNodesDistToPlan
     *   The distance to the cutting plane for each node.
     */
    virtual HRESULT CutElement ( const int iElementNumber,
      const CATString&amp; iPosition, const int iNbPositions, const int * iPositions, 
      const float iAnchorPoint[3], const float iNormalDirection[3],
      const float * iNodesCoordinates, const float * iNodesDistToPlan,
      const float * iTexture, CATBoolean iTextureMode,
      float * ioVertices, float * ioVerticesTexture, int &amp; ioVerticesArraySize,
      int * ioPointIndices , int &amp; oNbPoints , 
      int * ioEdgeIndices, int &amp; oNbEdges, 
      int * ioTriangleIndices, int &amp; oNbTriangles,
      int * ioTriangleFanIndices, int &amp; oNbTriangleFans, int * ioNbVerticesPerTriangleFan ) = 0;

    /**
     * @nodoc .
     */ 
    virtual HRESULT Init () = 0;

    /**
     * @nodoc .
     */ 
    virtual void Dispose () = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetEdgesDiscretisation(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement, const float * NodesCoordinates,
            float * const NodesDisplacement, float DeformCoeff,
            float *&amp;Edges, int &amp;NbEdges) = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetNodesDiscretisation(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float DeformCoeff,
            int &amp;NbNodes, int *&amp;NodesNumber, float *&amp;Coordinates, int AbsoluteOrRelative=0) = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetCenterOfFace ( int FaceNumber, const int *NodesOfElement,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float *CenterCoordinates, float *CenterDisplacement) = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetCenterOfEdge ( int EdgeNumber , const int * NodesOfElement ,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * const NodesDisplacement, float *CenterCoordinates, float *CenterDisplacement) = 0;

    /**
     * @nodoc .
     */ 
    virtual HRESULT GetNormalOfFace ( int FaceNumber , const int *NodesOfElement,
            int NbNodesOfElement, const float *NodesCoordinates,
            float *Normal) = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetNormalOfEdge ( int EdgeNumber , const int * NodesOfElement ,
            int NbNodesOfElement, const float *NodesCoordinates,
            float * Normal ) = 0;

    /**
     * @nodoc .
     */ 
    virtual char GetVisualizationState(const CATSamElementVisuState &amp;FaceState) = 0;

    /**
     * @nodoc .
     */ 
    virtual void GetVisualizedNodes(const CATSamElementVisuState &amp;FaceState,
            const int *NodesOfElement, int NbNodesOfElement,
            int *ShownNodes, int &amp;NbShownNodes, int AbsoluteOrRelative=0) = 0;

    /**
     * @nodoc .
     */ 
    virtual void ComputePosition( const int *NodesOfElement, int NbNodesOfElement,
            const float *NodesCoordinates, float * const NodesDisplacement,
            int NbPositions, float * const UVW,
            float *XYZPositions, float *XYZDisplacements) = 0;

    /**
     * @nodoc .
     */ 
    virtual HRESULT SetWorkingTopology (const CATAnalysisExplicitTopology * iTopology) = 0;

    /**
     * @nodoc .
     */ 
    virtual HRESULT ResetWorkingTopology ( ) = 0;
  
};
CATDeclareHandler(CATISamImageTesselation, CATBaseUnknown);

#endif

</div>
    
    <div class="navigation">
        <div><a href="CATISamImageSelectedEntity.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATISamImageSelectedEntity.h</a></div>
        <div><a href="CATISamLayoutOperator.html">‰∏ã‰∏ÄÈ°µ: CATISamLayoutOperator.h ‚Üí</a></div>
    </div>
</body>
</html>