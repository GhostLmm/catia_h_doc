<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AdvancedMathematics/PublicInterfaces/CATMathPolynomXY.h</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin: 15px 0;
            padding: 10px;
            background-color: #ecf0f1;
            border-radius: 5px;
        }
        .navigation a {
            color: #2980b9;
            text-decoration: none;
            padding: 5px 10px;
            background-color: white;
            border-radius: 3px;
            border: 1px solid #bdc3c7;
        }
        .navigation a:hover {
            background-color: #3498db;
            color: white;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            border: 1px solid #bdc3c7;
            white-space: pre-wrap;
            font-size: 14px;
            line-height: 1.4;
            overflow-x: auto;
        }
        .back-to-index {
            text-align: center;
            margin: 15px 0;
        }
        .back-to-index a {
            color: #27ae60;
            text-decoration: none;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>AdvancedMathematics/PublicInterfaces/CATMathPolynomXY.h</h1>
    </div>
    
    <div class="navigation">
        <div><a href="CATMathPolynomX.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATMathPolynomX.h</a></div>
        <div><a href="CATMathSetOfPointsND.html">‰∏ã‰∏ÄÈ°µ: CATMathSetOfPointsND.h ‚Üí</a></div>
    </div>
    
    <div class="back-to-index">
        <a href="index.html">üìÅ ËøîÂõûÁõÆÂΩï</a>
    </div>
    
    <div class="content">#ifndef CATMathPolynomXY_H
#define CATMathPolynomXY_H
// COPYRIGHT DASSAULT SYSTEMES  1999
/**
 * @CAA2Level L1
 * @CAA2Usage U1
 */ 
#include &quot;CATIACGMLevel.h&quot;

#include &quot;YN000FUN.h&quot;
#include &quot;CATMathFoundationXY.h&quot;
#include &quot;CATMathInterval.h&quot;
#include &quot;CATMathPolynomX.h&quot;
#include &quot;CATMathDef.h&quot;

#include &quot;CATTolerance.h&quot;

#ifdef CATIACGMV5R21
#include &quot;CATMathInline.h&quot;
#endif

class CATMathIntervalND;
class CATMathStream;
class CATMathAttrScaleOption;

#ifndef CATIACGMV5R21
// activated R19, deactivated R21 to save memory for massive degree 3 polynom use
#define CATPolynomXYR19NbStaticCoeff 36
#endif

#if defined(_WINDOWS_SOURCE) &amp;&amp; defined(_M_IX86)
/** @nodoc */
#define CATMUTABLE mutable
#else
#define CATMUTABLE
#endif

/**
 * Class defining the real polynom of two variables.
 */
class ExportedByYN000FUN CATMathPolynomXY : public CATMathFoundationXY
{
 public:
  
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //            C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;

  //-----------------------------------------------------------------
  // Constructors
  //-----------------------------------------------------------------
  /**
    * Copy constructor.
    */
  CATMathPolynomXY(const CATMathPolynomXY &amp; iToCopy);
 
   /**
    * Constructs a CATMathPolynomXY from a double entry array.
    * @param iDegX
    * The degree in the first variable
    * @param iDegY
    * The degree in the second variable.
    * @param iCoeff
    * The double entry array such that: 
    * &lt;br&gt;&lt;tt&gt;pol=Sum_{i=0..iDegX, j=0..iDegY}  iCoeff[i][j] X^i Y^j&lt;/tt&gt;.
     * @param iShiftX, iShiftY
     * Internal use.
    */
  CATMathPolynomXY(const CATLONG32 iDegX, const CATLONG32 iDegY, double **iCoeff, 
                   const double iShiftX=0., const double iShiftY=0.);
   /**
    * Constructs a CATMathPolynomXY from an array.
    * @param iDegX
    * The degree in the first variable
    * @param iDegY
    * The degree in the second variable.
    * @param iCoeff
    * The array such that: 
    * &lt;br&gt;&lt;tt&gt;pol=Sum_{i=0..iDegX, j=0..iDegY}  iCoeff[i*(degY+1)+j] X^i Y^j&lt;/tt&gt;.
    */
  CATMathPolynomXY(const CATLONG32 iDegX = 0, const CATLONG32 iDegY = 0, 
                   const double *iCoeff = 0,
                   const double iShiftX=0., const double iShiftY=0.);
  virtual ~CATMathPolynomXY();


  //-----------------------------------------------------------------
  // Set Global
  //-----------------------------------------------------------------
  /**
   * Modifies the coefficients of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
     * @param iDegX
    * The degree in the first variable
    * @param iDegY
    * The degree in the second variable.
    * @param iCoef
    * The double entry array such that: 
    * &lt;br&gt;&lt;tt&gt;pol=Sum_{i=0..iDegX, j=0..iDegY}  iCoeff[i][j] X^i Y^j&lt;/tt&gt;.
   */
  void SetCoefficients(const CATLONG32 iDegX, const CATLONG32 iDegY, double **iCoef);

      /**
    * Modifies the coefficients of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
    * @param iDegX
    * The degree in the first variable
    * @param iDegY
    * The degree in the second variable.
    * @param iCoef
    * The array such that: 
    * &lt;br&gt;&lt;tt&gt;pol=Sum_{i=0..iDegX, j=0..iDegY}  iCoef[i*(degY+1)+j] X^i Y^j&lt;/tt&gt;.
    */
  void SetCoefficients(const CATLONG32 iDegX = 0, const CATLONG32 iDegY = 0,
                       const double *iCoef = 0);
  //-----------------------------------------------------------------
  // Information methods
  //-----------------------------------------------------------------
#ifdef CATIACGMV5R21
  /**
    * From V5R21, returns the degree in the first variable.
    * @return
    * The degree.
    */

  INLINE CATLONG32 GetDegreeX() const;
#else
  /**
    * Up to V5R20, returns the degree in the first variable.
    * @return
    * The degree.
    */

  CATLONG32 GetDegreeX() const;
#endif



#ifdef CATIACGMV5R21
   /**
    * From V5R21, returns the degree in the second variable.
    * @return
    * The degree.
    */
  INLINE CATLONG32 GetDegreeY() const;
#else
   /**
    * Up to V5R20, returns the degree in the second variable.
    * @return
    * The degree.
    */
  CATLONG32 GetDegreeY() const;
#endif

  /**
  * Tests whether &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY derives from a class (given by its name).
  * @param iClassId
  * The name of the class.
  * @return
  * The result of the test.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; if &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is a kind of &lt;tt&gt;iClassId&lt;/tt&gt;,
  * &lt;tt&gt;FALSE&lt;/tt&gt; otherwise.
  */
  CATBoolean IsAKindOf(const CATMathClassId iClassId) const;

#ifdef CATIACGMV5R21
  /**
  * Tests if &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY derives from a class (given by a numerical value).
  * @param iType
  * The numerical value representing the class type.
  * @return
  * The result of the test.
  * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; if &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is a type of &lt;tt&gt;iType&lt;/tt&gt;,
  * &lt;tt&gt;FALSE&lt;/tt&gt; otherwise.
  */
  CATBoolean IsATypeOf(const CATMathFunctionXYTypeId iType) const;
#endif

      /**
 * Tests whether an evaluator is available for &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param iOption
 * The type of evalution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt; &lt;dt&gt;OptionEval   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the function
 * &lt;dt&gt;OptionEvalFirstDeriv   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the first derivative of the function
 * &lt;dt&gt;OptionEvalSecondDeriv&lt;/dt&gt;  &lt;dd&gt;  evaluation of the second derivative of the function
 * &lt;dt&gt;OptionEvalThirdDeriv&lt;/dt&gt;  &lt;dd&gt;  evaluation of the third derivative of the function
 * &lt;/dl&gt;
 * @return
 * The result of the test.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;: &lt;tt&gt;TRUE&lt;/tt&gt; if the evaluation is available for &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY,
 * &lt;tt&gt;FALSE&lt;/tt&gt; otherwise.
 */
  CATBoolean IsOption(const CATMathOption iOption) const;

   /**
 * Returns the class name of &lt;tt&gt;this&lt;/tt&gt;  CATMathPolynomXY.
 * @return
 * A pointer to the name &lt;tt&gt;CATMathPolynomX&lt;/tt&gt;.
 */
  CATMathClassId IsA() const;

/**
 * Returns the coefficients of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @return
 * The array of the coefficients. As part of &lt;tt&gt;this&lt;/tt&gt;, it must not be deallocated.
 */
  const double * GetCoefficients() const;

  //-----------------------------------------------------------------
  // Evaluators on doubles
  //-----------------------------------------------------------------
/** 
 * Evaluates &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The result of the evaluation.
 */
  virtual double Eval(const double &amp; iX, const double &amp; iY) const;

   /** 
 * Evaluates the first partial derivative with respect to the first variable of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the first partial derivative with respect to the first variable.
 */
  virtual double EvalFirstDerivX(const double &amp; iX, const double &amp;iY) const;
   /** 
 * Evaluates the first partial derivative with respect to the second variable of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the first partial derivative with respect to the second variable.
 */
  virtual double EvalFirstDerivY(const double &amp; iX, const double &amp; iY) const;

    /** 
 * Evaluates the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the second partial derivative.
 */
  virtual double EvalSecondDerivX2(const double &amp; iX, const double &amp; iY) const;
    /** 
 * Evaluates the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the second partial derivative.
 */
  virtual double EvalSecondDerivXY(const double &amp; iX, const double &amp; iY) const;
      /** 
 * Evaluates the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the second partial derivative.
 */
  virtual double EvalSecondDerivY2(const double &amp; iX, const double &amp; iY) const;
  
   /** 
 * Evaluates the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the third partial derivative.
 */
  virtual double EvalThirdDerivX3(const double &amp; iX, const double &amp; iY) const;
   /** 
 * Evaluates the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the third partial derivative.
 */
  virtual double EvalThirdDerivX2Y(const double &amp; iX, const double &amp; iY) const;
   /** 
 * Evaluates the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the third partial derivative.
 */
  virtual double EvalThirdDerivXY2(const double &amp; iX, const double &amp; iY) const;
   /** 
 * Evaluates the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @return
 * The value of the third partial derivative.
 */
  virtual double EvalThirdDerivY3(const double &amp; iX, const double &amp; iY) const;

 /** 
 * Evaluates simultaneously the value, and all the first, second and third partial derivatives
 * of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param oF
 * The value of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFx
 * The value of the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY. 
 * @param oFy
 * The value of the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY. 
 * @param oFx2
 * The value of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFxy
 * The value of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFy2
 * The value of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFx3
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFx2y
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFxy2
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFy3
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 */
  virtual void EvalUpToThirdDeriv(const double iX, const double iY,
                                 double &amp; oF, double &amp; oFx,  double &amp; oFy,
                          double &amp; oFx2, double &amp; oFxy, double &amp; oFy2,
                          double &amp; oFx3, double &amp; oFx2y, double &amp; oFxy2, double &amp; oFy3) const; 
 /** 
 * Evaluates simultaneously all third partial derivatives
 * of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY .
 * @param iX
 * The value of the first variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param iY
 * The value of the second variable where &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY is evaluated.
 * @param oFx3
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFx2y
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFxy2
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param oFy3
 * The value of the third partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 */
  virtual void EvalAllThirdDerivs(const double iX, const double iY, double &amp; oFx3, double &amp; oFx2y, double &amp; oFxy2, double &amp; oFy3) const;
 /**
 * Simultaneously evaluates &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY or/and its partial derivatives.
 * &lt;br&gt;&lt;b&gt;Precondition&lt;/b&gt;:The output arrays
 * must have been previously allocated if you asked for the corresponding evaluation.
 * @param iOptions
 * The type of evalution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt; &lt;dt&gt;OptionEval   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the function
 * &lt;dt&gt;OptionEvalFirstDeriv   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the first derivatives of the function
 * &lt;dt&gt;OptionEvalSecondDeriv&lt;/dt&gt;  &lt;dd&gt;  evaluation of the second derivatives of the function
 * &lt;/dl&gt;
 * @param ioF
 * A pointer to the value of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param ioFx
 * A pointer to the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY. 
 * @param ioFy
 * A pointer to the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY. 
 * @param ioFx2
 * A pointer to the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param ioFxy
 * A pointer to the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param ioFy2
 * A pointer to the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 */
   virtual void Eval(const double iX, const double iY, 
                     const CATMathOption iOptions,
                     double * ioF,
                     double * ioFx =0, double * ioFy=0,
                     double * ioFx2=0, double *ioFxy=0, double *ioFy2=0) const;
   
 /**
 * Simultaneously evaluates &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY or/and its partial derivatives 
 * on a regular grid of points.
 * &lt;br&gt;&lt;b&gt;Precondition&lt;/b&gt;: The output arrays
 * must have been previously allocated if you asked for the corresponding evaluation.
 * &lt;tt&gt;oF[Ny*i+j]&lt;/tt&gt; contains the evaluation of &lt;tt&gt;this&lt;/tt&gt; at &lt;tt&gt;(x_i,y_j)&lt;/tt&gt;.
 * @param iDomain
 * The 2D-interval of definition of the grid &lt;tt&gt;[xStart,xEnd] x [yStart,yEnd]&lt;/tt&gt;. 
 * @param iNbPoints
 * The array of 2 longs, stating the number of points of the grid in each direction &lt;tt&gt;x&lt;/tt&gt;
 * and &lt;tt&gt;y&lt;/tt&gt;. If &lt;tt&gt;iNbPoints[0]=1&lt;/tt&gt; and &lt;tt&gt;iNbPoints[1]=1&lt;/tt&gt;, there is only one
 * evaluation made at the parameter &lt;tt&gt;(xStart,xStart)&lt;/tt&gt;
 * @param iOptions
 * The type of evalution.
 * &lt;br&gt;&lt;b&gt;Legal values&lt;/b&gt;:
 * &lt;dl&gt; &lt;dt&gt;OptionEval   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the function
 * &lt;dt&gt;OptionEvalFirstDeriv   &lt;/dt&gt;  &lt;dd&gt;  evaluation of the first derivatives of the function
 * &lt;dt&gt;OptionEvalSecondDeriv&lt;/dt&gt;  &lt;dd&gt;  evaluation of the second derivatives of the function
 * &lt;/dl&gt;
 * @param ioF
 * The array of the evaluations of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY.
 * @param ioFx
 * The array of the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY at the grid points. 
 * @param ioFy
 * The array of the first partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY at the grid points. 
 * @param ioFx2
 * The array of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY at the grid points.
 * @param ioFxy
 * The array of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY at the grid points.
 * @param ioFy2
 * The array of the second partial derivative of &lt;tt&gt;this&lt;/tt&gt; CATMathPolynomXY at the grid points.
 */ 
   virtual void Eval(const CATMathIntervalND &amp; iDomain, const CATLONG32 * NbPoints,
                     const CATMathOption iOptions,
                     double * ioF,
                     double * ioFx =0, double * ioFy=0,
                     double * ioFx2=0, double * ioFxy=0, double * ioFy2=0) const;












  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
  //
  //               N O N - C A A             M E T H O D S
  //
  //&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
   /** @nodoc */
  CATCGMNewClassArrayDeclare;


    /**
   * @nodoc
   * Modifies the Shift value.
   */
   void SetShiftX (const double iShiftX=0.);
    /**
   * @nodoc
   * Modifies the Shift value.
   */

   void SetShiftY (const double iShiftY=0.);
    /**
   * @nodoc
   * Modifies the Shift value.
   */

   void SetShiftXY (const double iShiftX=0., const double iShiftY=0. );
  /**
   * @nodoc
   * Perform the formal shift to set the Shift value to 0.
   */
  void CancelShifts ();


   /** @nodoc */
  int GetDirectComponents(const int iSizeOfComponents, const CATMathFunctionGeneral **ioComponents) const;
   /** @nodoc */
  CATMathFunctionXY * Duplicate() const;
   /** @nodoc */
  CATMathFunctionXY * DeepDuplicate() const ;
#if defined ( CATIACGMR216CAA )
   /** @nodoc */
  CATMathFunctionXY * DeepDuplicateWithTol(const CATTolerance *ipTolObject) const ;
#endif
  //-----------------------------------------------------------------
  // Stream 
  //-----------------------------------------------------------------
#if defined ( CATIACGMV5R21 )
   /**
	* @nodoc
	*/
   virtual short GetStreamDomainType(char ioDomain[3]) const;
#else
   /**
	* @nodoc
	*/
   virtual short GetStreamType() const;
#endif
   /** @nodoc */
  void Stream( CATMathStream&amp; Str, const char iLabelReserved[] = &quot;&quot; ) const;

   /** @nodoc */
  virtual size_t  GetStaticMemoryBytes() const;   

   /** @nodoc */
  virtual size_t  GetDynamicMemoryBytes() const;   

  /** @nodoc */
  virtual CATBoolean _IsStreamable( const CATCGMStreamVersion iTargetVersion, CATBoolean &amp; ioReversible ) const;


    /**
   * @nodoc
   * Returns the Shift value.
   */
  double GetShiftX () const;

    /**
   * @nodoc
   * Modifies the Shift value.
   */
  double GetShiftY () const;


 private:
 /** @nodoc */
  CATLONG32 _degreeX, _degreeY;
 /** @nodoc */
  double * _coeff;
 /** @nodoc */
#ifndef CATIACGMV5R21
  //unused
  CATMUTABLE CATINTPTR *_CoeffAlloc;
#endif
 /** @nodoc */
  double _ShiftX, _ShiftY ;
  #ifdef CATPolynomXYR19NbStaticCoeff
  double _staticcoeff_nodirectaccess[CATPolynomXYR19NbStaticCoeff];
  #endif

 public:



  //-----------------------------------------------------------------
  // Evaluators on intervals
  //-----------------------------------------------------------------
   /** @nodoc */
   virtual CATMathInterval Eval(const CATMathInterval &amp; Du,
     const CATMathInterval &amp; Dv, const CATTolerance &amp; iTolObject=CATGetDefaultTolerance()) const;

   /** @nodoc */
  virtual CATMathInterval EvalFirstDerivX(const CATMathInterval &amp; Du,
                                          const CATMathInterval &amp; Dv) const;
   /** @nodoc */
  virtual CATMathInterval EvalFirstDerivY(const CATMathInterval &amp; Du,
                                          const CATMathInterval &amp; Dv) const;  
   /** @nodoc */
  virtual CATMathInterval EvalSecondDerivX2(const CATMathInterval &amp; Du,
                                            const CATMathInterval &amp; Dv) const;
   /** @nodoc */
  virtual CATMathInterval EvalSecondDerivXY(const CATMathInterval &amp; Du,
                                            const CATMathInterval &amp; Dv) const;  
   /** @nodoc */
  virtual CATMathInterval EvalSecondDerivY2(const CATMathInterval &amp; Du,
                                            const CATMathInterval &amp; Dv) const;  
  
  /** @nodoc */
  virtual void Eval(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv,
    const CATMathOption iOptions,CATMathInterval * f,CATMathInterval * fx , 
    CATMathInterval * fy,CATMathInterval * fx2, CATMathInterval * fxy, 
    CATMathInterval * fy2, const CATTolerance &amp; iTolObject=CATGetDefaultTolerance()) const;

  // Compute a quite good interval containing the image of (Du,Dv), thanks to chebychev transformation
   
  /** @nodoc */
  virtual CATMathInterval ComputeOptimalImage(const CATMathInterval          &amp; Du           , 
                                              const CATMathInterval          &amp; Dv           ,
                                              const CATTolerance             &amp; iTolObject   = CATGetDefaultTolerance(),
#ifdef CATMathFunctionXYR24Interface
                                                    CATMathAttrScaleOption  *  iScaleOption = NULL,
                                                    CATSoftwareConfiguration*  iConfig      = NULL
#else
                                                    CATMathAttrScaleOption  *  iScaleOption = NULL
#endif
                                             ) const;
 /** @nodoc */
  virtual CATMathInterval ComputeImageByChebychev(const CATMathInterval &amp; ix, const CATMathInterval &amp; iy, const CATTolerance &amp; iTolObject=CATGetDefaultTolerance()) const;

 

  /**
  * @nodoc
  *
  * MultiEvaluator of f and its derivative on a non regular grid :
  * Evaluation of 
  *                F[i*xNbPoints+j] = Eval(xPoints[i],yPoints[j]), ...
  */
  virtual void EvalGrid(CATLONG32 xNbPoints, const double * xPoints, CATLONG32 yNbPoints, const double * yPoints,
    const CATMathOption iOptions,
    double * ioF,
    double * ioFx =0, double * ioFy=0) const;

  /** @nodoc */
  virtual CATMathPolynomXY ProductXXtoXY(const CATMathPolynomX &amp; PX, const CATMathPolynomX &amp; PY) const;


  //-----------------------------------------------------------------
  // Formal Treatment of polynoms (friend functions)
  // WARNING : all these functions return pointers, the corresponding
  //           objects must be DELETED afterwards.
  //-----------------------------------------------------------------
  // polynomial of one variable q(y)=p(x,y) for x fixed
   /** @nodoc */
  CATMathFunctionX * CreateIsoparX(const double &amp; x) const;
  // polynomial of one variable q(x)=p(x,y) for y fixed
   /** @nodoc */
  CATMathFunctionX * CreateIsoparY(const double &amp; y) const;


  // formal derivation with respect to one variable
   /** @nodoc */
  CATMathFunctionXY * CreateDerivX() const;
   /** @nodoc */
  CATMathFunctionXY * CreateDerivY() const;


  // sum with a double : pol + alpha
   /** @nodoc */
friend ExportedByYN000FUN CATMathPolynomXY * 
   Sum(const CATMathPolynomXY * pol, const double &amp; alpha);
  // sum of two polynomials : pol1 + pol2
/** @nodoc */
friend ExportedByYN000FUN CATMathPolynomXY * 
   Sum(const CATMathPolynomXY * pol1, const CATMathPolynomXY * pol2);

  // product by a double : alpha * pol
/** @nodoc */
friend ExportedByYN000FUN CATMathPolynomXY * 
   Product(const CATMathPolynomXY * pol, const double &amp; alpha);

  // linear combination : alpha * pol1 + beta * pol2
/** @nodoc */
friend ExportedByYN000FUN CATMathPolynomXY * 
   Combination(const CATMathPolynomXY * pol1, const CATMathPolynomXY * pol2,
               const double &amp; alpha, const double &amp; beta);
  // linear combination : alpha * pol1 + beta * pol2 + gamma * pol3  
/** @nodoc */
friend ExportedByYN000FUN CATMathPolynomXY * 
   Combination(const CATMathPolynomXY * pol1,
               const CATMathPolynomXY * pol2,
               const CATMathPolynomXY * pol3,
               const double &amp; alpha,
               const double &amp; beta,
               const double &amp; gamma);
  
  // overloading &lt;&lt;
/** @nodoc */ 
friend ExportedByYN000FUN ostream &amp; 
   operator &lt;&lt; (ostream&amp; os, CATMathPolynomXY &amp; p);
//
//- Overloaded operators
//
/** @nodoc */
  CATMathPolynomXY &amp; operator = (const CATMathPolynomXY &amp; p);
/** @nodoc */
  friend ExportedByYN000FUN void operator +=
    (CATMathPolynomXY &amp; p, const CATMathPolynomXY &amp; q);
   /** @nodoc */
  friend ExportedByYN000FUN void operator +=
    (CATMathPolynomXY &amp; p, const double &amp; a);
   /** @nodoc */
  friend ExportedByYN000FUN void operator -=
    (CATMathPolynomXY &amp; p, const CATMathPolynomXY &amp; q);
   /** @nodoc */
  friend ExportedByYN000FUN void operator -=
    (CATMathPolynomXY &amp; p, const double &amp; a);
   /** @nodoc */
  friend ExportedByYN000FUN void operator *=
    (CATMathPolynomXY &amp; p, const double &amp; a);
   /** @nodoc */ /* private; no export */
  friend void OperatorPlusEgalMoinsEgal_Private
    (CATMathPolynomXY &amp; p, const CATMathPolynomXY &amp; q, double SigneOperation) ;


//protected:
   /** @nodoc */
  virtual CATMathFunctionXY * FormalCombination(const CATLONG32 iN, 
                                                const CATMathFunctionXY ** iFunc,
                                                const double * iCoef, 
                                                const double iConstant) const;

private:

  CATMathInterval EvalIntervalSymX(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalIntervalPosX(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalIntervalNegX(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;

  CATMathInterval EvalFirstDerivXHiDegrees(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalFirstDerivXHiDegreesSub1(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const;
  CATMathInterval EvalFirstDerivXHiDegreesSub2(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivXHiDegreesSub3(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 

  CATMathInterval EvalFirstDerivXHiDegreesSym(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalFirstDerivXHiDegreesSymSub1(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivXHiDegreesSymSub2(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivXHiDegreesSymSub3(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 


  CATMathInterval EvalFirstDerivYHiDegrees(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalFirstDerivYHiDegreesSub1(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const;
  CATMathInterval EvalFirstDerivYHiDegreesSub2(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivYHiDegreesSub3(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 

  CATMathInterval EvalFirstDerivYHiDegreesSym(const CATMathInterval &amp; iDu, const CATMathInterval &amp; iDv) const;
  CATMathInterval EvalFirstDerivYHiDegreesSymSub1(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivYHiDegreesSymSub2(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 
  CATMathInterval EvalFirstDerivYHiDegreesSymSub3(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv) const; 



  void EvalFirstDeriv(const double u, const double v, double &amp; fx, double &amp; fy) const;
  void EvalAndFirstDeriv(const double u, const double v,
                         double &amp; f, double &amp; fx, double &amp; fy) const;
  
  void EvalAndFirstAndSecondDeriv(const double u, const double v,
                                  double &amp; f, double &amp; fx, double &amp; fy,
                                  double &amp; fx2, double &amp; fxy, double &amp; fy2) const;

  void GridEval
     (const double uStart, const double uEnd, const double uDelta,
      const double vStart, const double vEnd, const double vDelta,
      const CATLONG32 Nu, const CATLONG32 Nv,
      double * f) const;

  void GridEvalFirstDeriv
     (const double uStart, const double uEnd, const double uDelta,
      const double vStart, const double vEnd, const double vDelta,
      const CATLONG32 Nu, const CATLONG32 Nv,
      double * fx, double * fy) const;

  void GridEvalAndFirstDeriv
     (const double uStart, const double uEnd, const double uDelta,
      const double vStart, const double vEnd, const double vDelta,
      const CATLONG32 Nu, const CATLONG32 Nv,
      double * f, double * fx, double * fy) const;

  void GridEvalAndFirstAndSecondDeriv
     (const double uStart, const double uEnd, const double uDelta,
      const double vStart, const double vEnd, const double vDelta,
      const CATLONG32 Nu, const CATLONG32 Nv,
      double * f, double * fx, double * fy, 
      double * fx2, double * fxy, double * fy2) const;
  
  void EvalAndFirstDeriv(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv,
                         CATMathInterval &amp; f, CATMathInterval &amp; fx, CATMathInterval &amp; fy) const;
  
  void EvalAndFirstAndSecondDeriv(const CATMathInterval &amp; Du, const CATMathInterval &amp; Dv,
                                  CATMathInterval &amp; f, CATMathInterval &amp; fx, CATMathInterval &amp; fy,
                                  CATMathInterval &amp; fx2, CATMathInterval &amp; fxy, 
                                  CATMathInterval &amp; fy2) const;


  friend CATBoolean ShiftCheck (const double iShiftX1, const double iShiftX2,
    const double iShiftY1, const double iShiftY2);


  // Internal use only
  // Method used to perform internally a deep Horner scheme so as to compute all values of current
  // polynom up to third derivatives.
  // Be careful: some values returned must be re-scaled, for instance:
  //    d2P / dx^2 = 2. * oFx2by2.
  //    d3P / dx^3 = 6. * oFx3by6.
  void HornerSchemeUpToThird(const double &amp; iX, const double &amp; iY,
                              double &amp; oF, double &amp; oFx,  double &amp; oFy,
                                     double &amp; oFx2by2, double &amp; oFxy, double &amp; oFy2by2,
                                     double &amp; oFx3by6, double &amp; oFx2yby2, double &amp; oFxy2by2, double &amp; oFy3by6) const;

public:
// Modify polynomial p(u,v) into p(alpha*u,beta*v);
    /** @nodoc */
  void ApplyScalingOnVariables(const double &amp; alpha, const double &amp; beta);

//#ifdef CATIAV5R14
// Modify polynom p(t,u)into p(t+beta,u+gamma) by coefficients modification
   /** @nodoc */
  void ApplyFormalShiftOnVariable(const double &amp; betaX,const double &amp; betaY);
//#endif

};

#ifdef CATIACGMV5R21
INLINE CATLONG32 CATMathPolynomXY::GetDegreeX() const
 {
  return _degreeX;
 };
INLINE CATLONG32 CATMathPolynomXY::GetDegreeY() const
 {
  return _degreeY;
 };
#endif

#endif
</div>
    
    <div class="navigation">
        <div><a href="CATMathPolynomX.html">‚Üê ‰∏ä‰∏ÄÈ°µ: CATMathPolynomX.h</a></div>
        <div><a href="CATMathSetOfPointsND.html">‰∏ã‰∏ÄÈ°µ: CATMathSetOfPointsND.h ‚Üí</a></div>
    </div>
</body>
</html>